package http

import (
	"net/http"
	"strconv"
	
	"github.com/labstack/echo/v4"
	"github.com/{{ .ModulePath }}/internal/application"
	"github.com/{{ .ModulePath }}/internal/domain"
	"go.uber.org/zap"
)

// {{ .EntityName }}Handler handles HTTP requests for {{ .EntityName }}
type {{ .EntityName }}Handler struct {
	useCase *application.{{ .EntityName }}UseCase
	logger  *zap.Logger
}

// New{{ .EntityName }}Handler creates a new {{ .EntityName }}Handler
func New{{ .EntityName }}Handler(useCase *application.{{ .EntityName }}UseCase) *{{ .EntityName }}Handler {
	return &{{ .EntityName }}Handler{
		useCase: useCase,
		logger:  logger.Get(),
	}
}

// Create handles POST /{{ .EntityName | lower }}
func (h *{{ .EntityName }}Handler) Create(c echo.Context) error {
	var entity domain.{{ .EntityName }}
	if err := c.Bind(&entity); err != nil {
		h.logger.Error("Failed to bind request", zap.Error(err))
		return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
	}
	
	if err := h.useCase.Create(c.Request().Context(), &entity); err != nil {
		h.logger.Error("Failed to create {{ .EntityName | lower }}", zap.Error(err))
		return echo.NewHTTPError(http.StatusInternalServerError, "Failed to create {{ .EntityName | lower }}")
	}
	
	return c.JSON(http.StatusCreated, entity)
}

// GetByID handles GET /{{ .EntityName | lower }}/:id
func (h *{{ .EntityName }}Handler) GetByID(c echo.Context) error {
	id := c.Param("id")
	
	entity, err := h.useCase.GetByID(c.Request().Context(), id)
	if err != nil {
		if err == domain.Err{{ .EntityName }}NotFound {
			return echo.NewHTTPError(http.StatusNotFound, "{{ .EntityName }} not found")
		}
		h.logger.Error("Failed to get {{ .EntityName | lower }}", zap.Error(err))
		return echo.NewHTTPError(http.StatusInternalServerError, "Failed to get {{ .EntityName | lower }}")
	}
	
	return c.JSON(http.StatusOK, entity)
}

// Update handles PUT /{{ .EntityName | lower }}/:id
func (h *{{ .EntityName }}Handler) Update(c echo.Context) error {
	id := c.Param("id")
	
	var entity domain.{{ .EntityName }}
	if err := c.Bind(&entity); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
	}
	
	entity.ID = id
	
	if err := h.useCase.Update(c.Request().Context(), &entity); err != nil {
		if err == domain.Err{{ .EntityName }}NotFound {
			return echo.NewHTTPError(http.StatusNotFound, "{{ .EntityName }} not found")
		}
		h.logger.Error("Failed to update {{ .EntityName | lower }}", zap.Error(err))
		return echo.NewHTTPError(http.StatusInternalServerError, "Failed to update {{ .EntityName | lower }}")
	}
	
	return c.JSON(http.StatusOK, entity)
}

// Delete handles DELETE /{{ .EntityName | lower }}/:id
func (h *{{ .EntityName }}Handler) Delete(c echo.Context) error {
	id := c.Param("id")
	
	if err := h.useCase.Delete(c.Request().Context(), id); err != nil {
		if err == domain.Err{{ .EntityName }}NotFound {
			return echo.NewHTTPError(http.StatusNotFound, "{{ .EntityName }} not found")
		}
		h.logger.Error("Failed to delete {{ .EntityName | lower }}", zap.Error(err))
		return echo.NewHTTPError(http.StatusInternalServerError, "Failed to delete {{ .EntityName | lower }}")
	}
	
	return c.NoContent(http.StatusNoContent)
}

// List handles GET /{{ .EntityName | lower }}
func (h *{{ .EntityName }}Handler) List(c echo.Context) error {
	limitStr := c.QueryParam("limit")
	offsetStr := c.QueryParam("offset")
	
	limit := 10
	offset := 0
	
	if l, err := strconv.Atoi(limitStr); err == nil && l > 0 {
		limit = l
	}
	
	if o, err := strconv.Atoi(offsetStr); err == nil && o >= 0 {
		offset = o
	}
	
	entities, err := h.useCase.List(c.Request().Context(), limit, offset)
	if err != nil {
		h.logger.Error("Failed to list {{ .EntityName | lower }}", zap.Error(err))
		return echo.NewHTTPError(http.StatusInternalServerError, "Failed to list {{ .EntityName | lower }}")
	}
	
	return c.JSON(http.StatusOK, map[string]interface{}{
		"data":  entities,
		"count": len(entities),
		"limit": limit,
		"offset": offset,
	})
}