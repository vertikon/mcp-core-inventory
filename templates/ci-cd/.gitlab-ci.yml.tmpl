stages:
  - test
  - build
  - security
  - deploy-staging
  - deploy-production

variables:
  REGISTRY: {{ .Registry | default "registry.gitlab.com" }}
  IMAGE_NAME: {{ .ServiceName }}
  DOCKER_DRIVER: overlay2

{{- if .TestEnabled }}
test:
  stage: test
  image: golang:1.21-alpine
  parallel:
    matrix:
      - GO_VERSION: ['1.19', '1.20', '1.21']
  
  before_script:
    - apk add --no-cache git
    - mkdir -p /go/src/app
    - cp -r . /go/src/app
    - cd /go/src/app
    
  script:
    - go mod download
    - go test -v -race -coverprofile=coverage.out ./...
    - go tool cover -html=coverage.out -o coverage.html
    
  coverage: '/coverage: \d+\.\d+% of statements/'
  
  artifacts:
    when: always
    reports:
      junit: report.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.html
    expire_in: 1 week
{{- end }}

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest
    
  only:
    - main
    - develop

security:
  stage: security
  image: aquasec/trivy:latest
  script:
    - trivy image --exit-code 0 --no-progress --format template --template "@contrib/sarif.tpl" -o gl-sast-report.json $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  
  artifacts:
    reports:
      sast: gl-sast-report.json
    expire_in: 1 week
    
  allow_failure: true

deploy-staging:
  stage: deploy-staging
  image: alpine:latest
  environment:
    name: staging
    url: https://{{ .ServiceName }}-staging.example.com
  
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$STAGING_SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $STAGING_HOST >> ~/.ssh/known_ids
    - chmod 644 ~/.ssh/known_ids
    
  script:
    - ssh $STAGING_USER@$STAGING_HOST "cd /opt/{{ .ServiceName }} && docker-compose pull && docker-compose up -d"
    
  only:
    - develop

deploy-production:
  stage: deploy-production
  image: bitnami/kubectl:latest
  environment:
    name: production
    url: https://{{ .ServiceName }}.example.com
  
  before_script:
    - kubectl config use-context $KUBE_CONTEXT_PROD
    
  script:
    - helm upgrade --install {{ .ServiceName }} ./k8s \
      --namespace production \
      --set image.tag=$CI_COMMIT_SHA \
      --set environment=production \
      --wait --timeout=10m
      
    - kubectl rollout status deployment/{{ .ServiceName }} -n production --timeout=300s
    
  only:
    - main
  when: manual