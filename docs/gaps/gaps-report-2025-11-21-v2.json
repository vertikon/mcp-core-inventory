{
  "project_name": "mcp-core-inventory",
  "project_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory",
  "timestamp": "2025-11-21 20:37:12",
  "validator_version": "9.4",
  "critical": [
    {
      "type": "No Code Conflicts",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Conflitos de declaracao detectados",
      "suggestion": "Remova ou renomeie as declaracoes duplicadas",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "manual_steps": "1. Identifique qual declaracao manter\n2. Remova ou renomeie as duplicatas\n3. Atualize referencias",
        "non_fixable_reason": "ARCHITECTURAL",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "15-30 minutos",
        "confidence": 0
      },
      "examples": [
        "registry: 'TemplateInfo' declarado em mcp_registry.go, template_registry.go",
        "cli: 'init' declarado em ai.go, generate.go, monitor.go, root.go, state.go, template.go, version.go",
        "pubsub: 'PubSubClient' declarado em nats_pubsub.go, pubsub_client.go",
        "encryption: 'Manager' declarado em certificate_manager.go, encryption_manager.go, key_manager.go",
        "crush: 'min' declarado em batch_processor.go, parallel_processor.go",
        "crush: 'max' declarado em batch_processor.go, parallel_processor.go",
        "protocol: 'parseParams' declarado em handlers.go, router.go",
        "analytics: 'init' declarado em metrics.go, performance.go"
      ],
      "non_fixable_reason": "ARCHITECTURAL",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 17,
          "code_snippet": "    12 | \t\"go.uber.org/zap\"\r\n    13 | \t\"gopkg.in/yaml.v3\"\r\n    14 | )\r\n    15 | \r\n    16 | // TemplateInfo holds information about a registered template\r\nâ†’   17 | type TemplateInfo struct {\r\n    18 | \tName         string            `json:\"name\"`\r\n    19 | \tStack        string            `json:\"stack\"`\r\n    20 | \tVersion      string            `json:\"version\"`\r\n    21 | \tSummary      string            `json:\"summary\"`\r\n    22 | \tPlaceholders []string          `json:\"placeholders\"`\r\n",
          "full_function": "type TemplateInfo struct {\r\n\tName         string            `json:\"name\"`\r\n\tStack        string            `json:\"stack\"`\r\n\tVersion      string            `json:\"version\"`\r\n\tSummary      string            `json:\"summary\"`\r\n\tPlaceholders []string          `json:\"placeholders\"`\r\n\tFiles        []string          `json:\"files\"`\r\n\tPath         string            `json:\"path\"`\r\n\tMetadata     map[string]string `json:\"metadata\"`\r\n\tLastModified string            `json:\"last_modified\"`\r\n}\r",
          "symbol_name": "TemplateInfo",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\generate.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"MCP project generation initiated\")\r\n    40 | \t\treturn nil\r\n    41 | \t},\r\n    42 | }\r\n    43 | \r\nâ†’   44 | func init() {\r\n    45 | \trootCmd.AddCommand(generateCmd)\r\n    46 | \tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\r\n    47 | \tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\r\n    48 | \tgenerateCmd.MarkFlagRequired(\"template\")\r\n    49 | }\r\n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(generateCmd)\r\n\tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\r\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\r\n\tgenerateCmd.MarkFlagRequired(\"template\")\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/internal/services",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\monitor.go",
          "line_number": 24,
          "code_snippet": "    19 | \t\tcmd.Println(\"System status: Operational\")\r\n    20 | \t\treturn nil\r\n    21 | \t},\r\n    22 | }\r\n    23 | \r\nâ†’   24 | func init() {\r\n    25 | \trootCmd.AddCommand(monitorCmd)\r\n    26 | }\r\n    27 | \r\n    28 | // SetMonitoringService sets the monitoring service\r\n    29 | func SetMonitoringService(service *services.MonitoringAppService) {\r\n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(monitorCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/internal/services",
            "github.com/vertikon/mcp-core-inventory/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\root.go",
          "line_number": 37,
          "code_snippet": "    32 | \t\tos.Exit(1)\r\n    33 | \t}\r\n    34 | }\r\n    35 | \r\n    36 | // init initializes the CLI\r\nâ†’   37 | func init() {\r\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n    40 | \t\r\n    41 | \t// Add subcommand groups\r\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n",
          "full_function": "func init() {\r\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n\t\r\n\t// Add subcommand groups\r\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n\trootCmd.AddCommand(ci.CICmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\state.go",
          "line_number": 20,
          "code_snippet": "    15 | \t\tcmd.Println(\"State management - service implementation pending\")\r\n    16 | \t\treturn nil\r\n    17 | \t},\r\n    18 | }\r\n    19 | \r\nâ†’   20 | func init() {\r\n    21 | \trootCmd.AddCommand(stateCmd)\r\n    22 | }\r\n    23 | \n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(stateCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\template.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"Template created\")\r\n    40 | \t\treturn nil\r\n    41 | \t},\r\n    42 | }\r\n    43 | \r\nâ†’   44 | func init() {\r\n    45 | \trootCmd.AddCommand(templateCmd)\r\n    46 | \ttemplateCmd.AddCommand(templateListCmd)\r\n    47 | \ttemplateCmd.AddCommand(templateCreateCmd)\r\n    48 | \ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\r\n    49 | \ttemplateCreateCmd.MarkFlagRequired(\"name\")\r\n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(templateCmd)\r\n\ttemplateCmd.AddCommand(templateListCmd)\r\n\ttemplateCmd.AddCommand(templateCreateCmd)\r\n\ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\r\n\ttemplateCreateCmd.MarkFlagRequired(\"name\")\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/internal/services",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\version.go",
          "line_number": 21,
          "code_snippet": "    16 | \t\tfmt.Printf(\"Version: %s\\n\", Version)\r\n    17 | \t\tfmt.Printf(\"Build Date: %s\\n\", BuildDate)\r\n    18 | \t},\r\n    19 | }\r\n    20 | \r\nâ†’   21 | func init() {\r\n    22 | \trootCmd.AddCommand(versionCmd)\r\n    23 | }\r\n    24 | \n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(versionCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\messaging\\pubsub\\pubsub_client.go",
          "line_number": 9,
          "code_snippet": "     4 | import (\r\n     5 | \t\"context\"\r\n     6 | )\r\n     7 | \r\n     8 | // PubSubClient provides generic pub/sub interface\r\nâ†’    9 | type PubSubClient interface {\r\n    10 | \t// Publish publishes a message to a topic\r\n    11 | \tPublish(ctx context.Context, topic string, message []byte) error\r\n    12 | \r\n    13 | \t// Subscribe subscribes to a topic\r\n    14 | \tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n",
          "full_function": "type PubSubClient interface {\r\n\t// Publish publishes a message to a topic\r\n\tPublish(ctx context.Context, topic string, message []byte) error\r\n\r\n\t// Subscribe subscribes to a topic\r\n\tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n\r\n\t// Close closes the client connection\r\n\tClose() error\r\n}\r",
          "symbol_name": "PubSubClient",
          "package_name": "pubsub",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 622,
          "code_snippet": "   617 | \t\treturn a\r\n   618 | \t}\r\n   619 | \treturn b\r\n   620 | }\r\n   621 | \r\nâ†’  622 | func max(a, b time.Time) time.Time {\r\n   623 | \tif a.After(b) {\r\n   624 | \t\treturn a\r\n   625 | \t}\r\n   626 | \treturn b\r\n   627 | }\n",
          "full_function": "func max(a, b time.Time) time.Time {\r\n\tif a.After(b) {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "max",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 56,
          "code_snippet": "    51 | \t// Verify verifies a signature using RSA\r\n    52 | \tVerify(data, signature []byte, publicKey *rsa.PublicKey) bool\r\n    53 | }\r\n    54 | \r\n    55 | // Manager implements EncryptionManager\r\nâ†’   56 | type Manager struct {\r\n    57 | \tkeyManager KeyManager\r\n    58 | \tlogger     *zap.Logger\r\n    59 | }\r\n    60 | \r\n    61 | // NewEncryptionManager creates a new EncryptionManager\r\n",
          "full_function": "type Manager struct {\r\n\tkeyManager KeyManager\r\n\tlogger     *zap.Logger\r\n}\r",
          "symbol_name": "Manager",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 52,
          "code_snippet": "    47 | \t// LoadKeyFromFile loads key from file\r\n    48 | \tLoadKeyFromFile(filePath string) error\r\n    49 | }\r\n    50 | \r\n    51 | // Manager implements KeyManager\r\nâ†’   52 | type Manager struct {\r\n    53 | \tencryptionKey []byte\r\n    54 | \tkeyVersion    string\r\n    55 | \trsaPrivateKey *rsa.PrivateKey\r\n    56 | \trsaPublicKey  *rsa.PublicKey\r\n    57 | \trotationTTL  time.Duration\r\n",
          "full_function": "type Manager struct {\r\n\tencryptionKey []byte\r\n\tkeyVersion    string\r\n\trsaPrivateKey *rsa.PrivateKey\r\n\trsaPublicKey  *rsa.PublicKey\r\n\trotationTTL  time.Duration\r\n\tlastRotation  time.Time\r\n\tmu            sync.RWMutex\r\n\tlogger        *zap.Logger\r\n}\r",
          "symbol_name": "Manager",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 625,
          "code_snippet": "   620 | \tas.stats.ScaleDownEvents++\r\n   621 | \tnow := time.Now()\r\n   622 | \tas.stats.LastScalingTime = \u0026now\r\n   623 | }\r\n   624 | \r\nâ†’  625 | func min(a, b int) int {\r\n   626 | \tif a \u003c b {\r\n   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n",
          "full_function": "func min(a, b int) int {\r\n\tif a \u003c b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r",
          "symbol_name": "min",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 632,
          "code_snippet": "   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n   631 | \r\nâ†’  632 | func max(a, b int) int {\r\n   633 | \tif a \u003e b {\r\n   634 | \t\treturn a\r\n   635 | \t}\r\n   636 | \treturn b\r\n   637 | }\n",
          "full_function": "func max(a, b int) int {\r\n\tif a \u003e b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "max",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\protocol\\router.go",
          "line_number": 215,
          "code_snippet": "   210 | \r\n   211 | \treturn nil\r\n   212 | }\r\n   213 | \r\n   214 | // parseParams parses parameters from a JSON-RPC request\r\nâ†’  215 | func parseParams(params interface{}, target interface{}) error {\r\n   216 | \tif params == nil {\r\n   217 | \t\treturn nil\r\n   218 | \t}\r\n   219 | \r\n   220 | \t// This is a simplified parameter parsing\r\n",
          "full_function": "",
          "symbol_name": "parseParams",
          "package_name": "protocol",
          "dependencies": [
            "context",
            "fmt",
            "strings",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\analytics\\performance.go",
          "line_number": 23,
          "code_snippet": "    18 | \t\tcmd.Println(\"  P95 Latency: 0ms\")\r\n    19 | \t\treturn nil\r\n    20 | \t},\r\n    21 | }\r\n    22 | \r\nâ†’   23 | func init() {\r\n    24 | \tAnalyticsCmd.AddCommand(performanceCmd)\r\n    25 | }\r\n    26 | \n",
          "full_function": "func init() {\r\n\tAnalyticsCmd.AddCommand(performanceCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "analytics",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "10-30 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Codigo compila",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Nao compila: # github.com/vertikon/mcp-core-inventory/internal/core/scheduler\ninternal\\core\\scheduler\\scheduler.go:62:19: undefined: nats.ErrStreamNameExist\n# github.com/vertikon/mcp-core-inventory/internal/adapte...",
      "suggestion": "Corrija os erros de compilacao listados",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "Variavel - depende dos erros",
        "confidence": 0
      },
      "examples": [
        "ðŸ“„ Log completo: E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\docs\\validation\\raw\\2025-11-21-20-35-21-compilation.log",
        "",
        "# github.com/vertikon/mcp-core-inventory/internal/core/scheduler",
        "internal\\core\\scheduler\\scheduler.go:62:19: undefined: nats.ErrStreamNameExist",
        "# github.com/vertikon/mcp-core-inventory/internal/adapters/postgres",
        "internal\\adapters\\postgres\\ledger_repository.go:103:8: res.id undefined (type ledger.Reservation has no field or method id)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:17: res.ledgerID undefined (type ledger.Reservation has no field or method ledgerID, but does have method LedgerID)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:32: res.sku undefined (type ledger.Reservation has no field or method sku)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:42: res.location undefined (type ledger.Reservation has no field or method location, but does have method Location)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:57: res.quantity undefined (type ledger.Reservation has no field or method quantity, but does have method Quantity)",
        "internal\\adapters\\postgres\\ledger_repository.go:104:8: res.idempotencyKey undefined (type ledger.Reservation has no field or method idempotencyKey, but does have method IdempotencyKey)",
        "internal\\adapters\\postgres\\ledger_repository.go:114:6: res.status undefined (type ledger.Reservation has no field or method status, but does have method Status)",
        "internal\\adapters\\postgres\\ledger_repository.go:115:6: res.expiresAt undefined (type ledger.Reservation has no field or method expiresAt, but does have method ExpiresAt)",
        "internal\\adapters\\postgres\\ledger_repository.go:116:6: res.createdAt undefined (type ledger.Reservation has no field or method createdAt, but does have method CreatedAt)",
        "internal\\adapters\\postgres\\ledger_repository.go:117:6: res.updatedAt undefined (type ledger.Reservation has no field or method updatedAt, but does have method UpdatedAt)",
        "internal\\adapters\\postgres\\ledger_repository.go:117:6: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/app",
        "internal\\app\\query_available.go:7:2: \"github.com/vertikon/mcp-core-inventory/internal/domain/ledger\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/mcp/generators",
        "internal\\mcp\\generators\\generator_factory.go:317:32: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:319:50: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:323:54: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:334:75: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:350:39: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\tinygo_generator.go:324:3: cannot use \"project\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:324:14: cannot use req.Name (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:3: cannot use \"language\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:15: cannot use g.language (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: cannot use \"features\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/mcp/registry",
        "internal\\mcp\\registry\\template_registry.go:17:6: TemplateInfo redeclared in this block",
        "\tinternal\\mcp\\registry\\mcp_registry.go:301:6: other declaration of TemplateInfo",
        "internal\\mcp\\registry\\template_registry.go:75:17: templateInfo.Path undefined (type *TemplateInfo has no field or method Path)",
        "internal\\mcp\\registry\\template_registry.go:124:3: unknown field Summary in struct literal of type TemplateInfo",
        "internal\\mcp\\registry\\template_registry.go:125:3: unknown field Placeholders in struct literal of type TemplateInfo",
        "internal\\mcp\\registry\\discovery.go:21:13: undefined: logger",
        "internal\\mcp\\registry\\discovery.go:27:5: sd.mu undefined (type *ServiceDiscovery has no field or method mu)",
        "internal\\mcp\\registry\\discovery.go:28:11: sd.mu undefined (type *ServiceDiscovery has no field or method mu)",
        "internal\\mcp\\registry\\discovery.go:51:11: service.Description undefined (type *ServiceInfo has no field or method Description)",
        "internal\\mcp\\registry\\service_registry.go:33:10: service.LastChecked undefined (type *ServiceInfo has no field or method LastChecked)",
        "internal\\mcp\\registry\\service_registry.go:96:10: service.LastChecked undefined (type *ServiceInfo has no field or method LastChecked)",
        "internal\\mcp\\registry\\template_registry.go:125:3: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/adapters/redis",
        "internal\\adapters\\redis\\reservation_lock.go:55:2: declared and not used: script",
        "# github.com/vertikon/mcp-core-inventory/cmd/tools-validator",
        "cmd\\tools-validator\\main.go:60:4: unknown field StrictMode in struct literal of type \"github.com/vertikon/mcp-core-inventory/tools/validators\".ConfigValidateRequest",
        "# github.com/vertikon/mcp-core-inventory/internal/core/crush",
        "internal\\core\\crush\\memory_optimizer.go:31:2: PolicyLRU redeclared in this block",
        "\tinternal\\core\\crush\\batch_processor.go:155:2: other declaration of PolicyLRU",
        "internal\\core\\crush\\memory_optimizer.go:395:8: invalid case PolicyLRU in switch on mo.config.EvictionPolicy (mismatched types PrefetchPolicy and EvictionPolicy)",
        "internal\\core\\crush\\parallel_processor.go:625:6: min redeclared in this block",
        "\tinternal\\core\\crush\\batch_processor.go:796:6: other declaration of min",
        "internal\\core\\crush\\parallel_processor.go:632:6: max redeclared in this block",
        "\tinternal\\core\\crush\\batch_processor.go:803:6: other declaration of max",
        "internal\\core\\crush\\batch_processor.go:269:19: undefined: runtime",
        "internal\\core\\crush\\batch_processor.go:427:6: declared and not used: id",
        "internal\\core\\crush\\batch_processor.go:560:18: cannot use \u0026bp.stats.TotalProcessingTime (value of type *time.Duration) as *int64 value in argument to atomic.AddInt64",
        "internal\\core\\crush\\batch_processor.go:584:42: cannot use \u0026bp.stats.TotalProcessingTime (value of type *time.Duration) as *int64 value in argument to atomic.LoadInt64",
        "internal\\core\\crush\\batch_processor.go:781:15: undefined: NewWorkerPool",
        "internal\\core\\crush\\batch_processor.go:792:23: too many arguments in call to abp.workerPool.Start",
        "\thave (context.Context)",
        "\twant ()",
        "internal\\core\\crush\\memory_optimizer.go:395:8: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/domain/services",
        "internal\\domain\\services\\ai_domain_service.go:33:17: context.documents undefined (type *entities.KnowledgeContext has no field or method documents, but does have method Documents)",
        "# github.com/vertikon/mcp-core-inventory/internal/core/state",
        "internal\\core\\state\\distributed_store.go:543:22: invalid operation: cannot take address of dss.stats.LockWaitTime.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:649:31: invalid operation: cannot take address of dss.stats.AvgReadLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:651:21: invalid operation: cannot take address of dss.stats.AvgReadLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:656:31: invalid operation: cannot take address of dss.stats.AvgWriteLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:658:21: invalid operation: cannot take address of dss.stats.AvgWriteLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\store.go:10:2: \"github.com/vertikon/mcp-core-inventory/pkg/logger\" imported and not used",
        "internal\\core\\state\\store.go:11:2: \"go.uber.org/zap\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/core/transformer",
        "internal\\core\\transformer\\feedforward.go:194:21: ffn.router undefined (type *FeedForwardNetwork has no field or method router)",
        "internal\\core\\transformer\\transformer.go:152:38: not enough arguments in call to t.embeddings.Forward",
        "\thave (*Tensor)",
        "\twant (context.Context, *Tensor)",
        "internal\\core\\transformer\\transformer.go:209:79: cannot use attentionMask (variable of type *Tensor) as *AttentionMask value in argument to l.attention.Forward",
        "internal\\core\\transformer\\transformer.go:215:28: cannot use attnOutput (variable of type *AttentionResult) as *Tensor value in argument to t.add",
        "internal\\core\\transformer\\transformer.go:249:65: cannot use ln.eps (variable of type float64) as *Tensor value in argument to t.add",
        "internal\\core\\transformer\\positional_encoding.go:6:2: \"fmt\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/compute/serverless",
        "internal\\infrastructure\\compute\\serverless\\cloud_functions.go:14:46: undefined: FunctionConfig",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/messaging/pubsub",
        "internal\\infrastructure\\messaging\\pubsub\\pubsub_client.go:9:6: PubSubClient redeclared in this block",
        "\tinternal\\infrastructure\\messaging\\pubsub\\nats_pubsub.go:9:6: other declaration of PubSubClient",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/messaging/streaming",
        "internal\\infrastructure\\messaging\\streaming\\nats_jetstream.go:178:18: undefined: nats.ErrStreamNameExist",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/persistence/relational",
        "internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go:87:6: declared and not used: knowledge",
        "internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go:204:9: cannot use \u0026knowledge (value of type **entities.Knowledge) as *entities.Knowledge value in return statement",
        "# github.com/vertikon/mcp-core-inventory/internal/interfaces/cli",
        "internal\\interfaces\\cli\\root.go:42:21: undefined: analytics",
        "internal\\interfaces\\cli\\root.go:43:21: undefined: ci",
        "# github.com/vertikon/mcp-core-inventory/tools/deployers",
        "tools\\deployers\\hybrid_deployer.go:10:2: \"github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/security/encryption",
        "internal\\security\\encryption\\encryption_manager.go:56:6: Manager redeclared in this block",
        "\tinternal\\security\\encryption\\certificate_manager.go:42:6: other declaration of Manager",
        "internal\\security\\encryption\\encryption_manager.go:64:3: unknown field keyManager in struct literal of type Manager",
        "internal\\security\\encryption\\encryption_manager.go:71:16: m.keyManager undefined (type *Manager has no field or method keyManager)",
        "internal\\security\\encryption\\encryption_manager.go:81:16: m.keyManager undefined (type *Manager has no field or method keyManager)",
        "internal\\security\\encryption\\key_manager.go:52:6: Manager redeclared in this block",
        "\tinternal\\security\\encryption\\certificate_manager.go:42:6: other declaration of Manager",
        "internal\\security\\encryption\\key_manager.go:72:3: unknown field keyVersion in struct literal of type Manager",
        "internal\\security\\encryption\\key_manager.go:82:6: km.encryptionKey undefined (type *Manager has no field or method encryptionKey)",
        "internal\\security\\encryption\\key_manager.go:96:4: m.mu undefined (type *Manager has no field or method mu)",
        "internal\\security\\encryption\\key_manager.go:97:10: m.mu undefined (type *Manager has no field or method mu)",
        "internal\\security\\encryption\\key_manager.go:99:7: m.encryptionKey undefined (type *Manager has no field or method encryptionKey)",
        "internal\\security\\encryption\\key_manager.go:99:7: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/state/cache",
        "internal\\state\\cache\\cache_coherency.go:162:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "internal\\state\\cache\\cache_coherency.go:217:11: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:253:34: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:342:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "# github.com/vertikon/mcp-core-inventory/internal/state/store",
        "internal\\state\\store\\conflict_resolver.go:236:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:238:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:251:2: declared and not used: localTime",
        "internal\\state\\store\\conflict_resolver.go:252:2: declared and not used: remoteTime",
        "internal\\state\\store\\conflict_resolver.go:283:51: too many arguments in call to r.isMergeableValue",
        "\thave (interface{}, interface{})",
        "\twant (interface{})",
        "internal\\state\\store\\conflict_resolver.go:396:9: v declared and not used",
        "internal\\state\\store\\conflict_resolver.go:415:13: r.mergeMaps undefined (type map[string]interface{} has no field or method mergeMaps)",
        "internal\\state\\store\\conflict_resolver.go:419:13: r.mergeArrays undefined (type []interface{} has no field or method mergeArrays)",
        "internal\\state\\store\\conflict_resolver.go:516:35: cannot use localTS (variable of struct type time.Time) as uint64 value in argument to max",
        "internal\\state\\store\\conflict_resolver.go:622:6: max redeclared in this block",
        "\tinternal\\state\\store\\conflict_resolver.go:615:6: other declaration of max",
        "internal\\state\\store\\conflict_resolver.go:516:35: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/state/events",
        "internal\\state\\events\\event_replay.go:249:2: declared and not used: snapshot",
        "internal\\state\\events\\event_replay.go:290:2: declared and not used: events",
        "internal\\state\\events\\event_versioning.go:140:4: invalid operation: cannot call copy (variable of struct type VersionInfo): VersionInfo is not a function",
        "internal\\state\\events\\event_versioning.go:216:30: ev.resolveVersionConflict undefined (type *EventVersioningImpl has no field or method resolveVersionConflict, but does have method ResolveVersionConflict)",
        ""
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\scheduler\\scheduler.go",
          "line_number": 62,
          "code_snippet": "    57 | \t\t\tMaxAge:    24 * time.Hour,\r\n    58 | \t\t}\r\n    59 | \r\n    60 | \t\t_, err := s.js.AddStream(cfg)\r\n    61 | \t\tif err != nil {\r\nâ†’   62 | \t\t\tif err == nats.ErrStreamNameExist {\r\n    63 | \t\t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", stream.name))\r\n    64 | \t\t\t\tcontinue\r\n    65 | \t\t\t}\r\n    66 | \t\t\treturn err\r\n    67 | \t\t}\r\n",
          "full_function": "func (s *Scheduler) InitializeStreams(ctx context.Context) error {\r\n\tstreams := []struct {\r\n\t\tname    string\r\n\t\tsubjects []string\r\n\t}{\r\n\t\t{\r\n\t\t\tname:     \"hulk.engine.tasks\",\r\n\t\t\tsubjects: []string{\"hulk.task.created\", \"hulk.task.completed\", \"hulk.task.failed\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"hulk.engine.events\",\r\n\t\t\tsubjects: []string{\"hulk.engine.*\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"hulk.scheduler.queue\",\r\n\t\t\tsubjects: []string{\"hulk.scheduler.tick\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"hulk.errors\",\r\n\t\t\tsubjects: []string{\"hulk.error.*\"},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, stream := range streams {\r\n\t\tcfg := \u0026nats.StreamConfig{\r\n\t\t\tName:      stream.name,\r\n\t\t\tSubjects: stream.subjects,\r\n\t\t\tReplicas:  1,\r\n\t\t\tMaxAge:    24 * time.Hour,\r\n\t\t}\r\n\r\n\t\t_, err := s.js.AddStream(cfg)\r\n\t\tif err != nil {\r\n\t\t\tif err == nats.ErrStreamNameExist {\r\n\t\t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", stream.name))\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\ts.streams[stream.name] = cfg\r\n\t\tlogger.Info(\"Stream created\", zap.String(\"stream\", stream.name))\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "scheduler",
          "dependencies": [
            "context",
            "encoding/json",
            "time",
            "github.com/nats-io/nats.go",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 104,
          "code_snippet": "    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\n   103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\nâ†’  104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n   109 | \t\t}\r\n",
          "full_function": "\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 114,
          "code_snippet": "   109 | \t\t}\r\n   110 | \t\treturn nil, err\r\n   111 | \t}\r\n   112 | \r\n   113 | \t// Reconstruct reservation\r\nâ†’  114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\n   117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n",
          "full_function": "\tres.status = ledger.ReservationStatus(status)\r\n\tres.expiresAt = expiresAt\r\n\tres.createdAt = createdAt\r\n\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 115,
          "code_snippet": "   110 | \t\treturn nil, err\r\n   111 | \t}\r\n   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\nâ†’  115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\n   117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n",
          "full_function": "\tres.expiresAt = expiresAt\r\n\tres.createdAt = createdAt\r\n\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 116,
          "code_snippet": "   111 | \t}\r\n   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\nâ†’  116 | \tres.createdAt = createdAt\r\n   117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n   121 | \r\n",
          "full_function": "\tres.createdAt = createdAt\r\n\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 117,
          "code_snippet": "   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\nâ†’  117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n   121 | \r\n   122 | // FindByID finds a reservation by ID\r\n",
          "full_function": "\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 117,
          "code_snippet": "   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\nâ†’  117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n   121 | \r\n   122 | // FindByID finds a reservation by ID\r\n",
          "full_function": "\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\app\\query_available.go",
          "line_number": 7,
          "code_snippet": "     2 | \r\n     3 | import (\r\n     4 | \t\"context\"\r\n     5 | \t\"fmt\"\r\n     6 | \r\nâ†’    7 | \t\"github.com/vertikon/mcp-core-inventory/internal/domain/ledger\"\r\n     8 | )\r\n     9 | \r\n    10 | // QueryAvailableRequest represents a request to query available stock\r\n    11 | type QueryAvailableRequest struct {\r\n    12 | \tSKU      string\r\n",
          "full_function": "\t\"github.com/vertikon/mcp-core-inventory/internal/domain/ledger\"\r\n)\r\n\r\n// QueryAvailableRequest represents a request to query available stock\r\ntype QueryAvailableRequest struct {\r\n\tSKU      string\r\n\tLocation string\r\n}\r",
          "symbol_name": "",
          "package_name": "app",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 317,
          "code_snippet": "   312 | \tif req.Path == \"\" {\r\n   313 | \t\treturn fmt.Errorf(\"output path is required\")\r\n   314 | \t}\r\n   315 | \r\n   316 | \t// Check if stack is supported\r\nâ†’  317 | \t_, exists := f.generators[req.Stack]\r\n   318 | \tif !exists {\r\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n   320 | \t}\r\n   321 | \r\n   322 | \t// Validate stack configuration\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 319,
          "code_snippet": "   314 | \t}\r\n   315 | \r\n   316 | \t// Check if stack is supported\r\n   317 | \t_, exists := f.generators[req.Stack]\r\n   318 | \tif !exists {\r\nâ†’  319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n   320 | \t}\r\n   321 | \r\n   322 | \t// Validate stack configuration\r\n   323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n   324 | \t\t// Validate features\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 323,
          "code_snippet": "   318 | \tif !exists {\r\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n   320 | \t}\r\n   321 | \r\n   322 | \t// Validate stack configuration\r\nâ†’  323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n   324 | \t\t// Validate features\r\n   325 | \t\tfor _, feature := range req.Features {\r\n   326 | \t\t\tvalidFeature := false\r\n   327 | \t\t\tfor _, validFeat := range stackConfig.Features {\r\n   328 | \t\t\t\tif feature == validFeat {\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 334,
          "code_snippet": "   329 | \t\t\t\t\tvalidFeature = true\r\n   330 | \t\t\t\t\tbreak\r\n   331 | \t\t\t\t}\r\n   332 | \t\t\t}\r\n   333 | \t\t\tif !validFeature {\r\nâ†’  334 | \t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n   335 | \t\t\t}\r\n   336 | \t\t}\r\n   337 | \t}\r\n   338 | \r\n   339 | \treturn nil\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 350,
          "code_snippet": "   345 | \tif err := f.ValidateRequest(req); err != nil {\r\n   346 | \t\treturn nil, err\r\n   347 | \t}\r\n   348 | \r\n   349 | \t// Get generator\r\nâ†’  350 | \tgenerator, err := f.GetGenerator(req.Stack)\r\n   351 | \tif err != nil {\r\n   352 | \t\treturn nil, err\r\n   353 | \t}\r\n   354 | \r\n   355 | \t// Generate project\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\r\n   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\nâ†’  324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\r\n   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\nâ†’  324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\nâ†’  325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\nâ†’  325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\nâ†’  326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n   331 | // Validate validates wasm generator\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\nâ†’  326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n   331 | // Validate validates wasm generator\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 17,
          "code_snippet": "    12 | \t\"go.uber.org/zap\"\r\n    13 | \t\"gopkg.in/yaml.v3\"\r\n    14 | )\r\n    15 | \r\n    16 | // TemplateInfo holds information about a registered template\r\nâ†’   17 | type TemplateInfo struct {\r\n    18 | \tName         string            `json:\"name\"`\r\n    19 | \tStack        string            `json:\"stack\"`\r\n    20 | \tVersion      string            `json:\"version\"`\r\n    21 | \tSummary      string            `json:\"summary\"`\r\n    22 | \tPlaceholders []string          `json:\"placeholders\"`\r\n",
          "full_function": "type TemplateInfo struct {\r\n\tName         string            `json:\"name\"`\r\n\tStack        string            `json:\"stack\"`\r\n\tVersion      string            `json:\"version\"`\r\n\tSummary      string            `json:\"summary\"`\r\n\tPlaceholders []string          `json:\"placeholders\"`\r\n\tFiles        []string          `json:\"files\"`\r\n\tPath         string            `json:\"path\"`\r\n\tMetadata     map[string]string `json:\"metadata\"`\r\n\tLastModified string            `json:\"last_modified\"`\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\mcp\\registry\\mcp_registry.go",
          "line_number": 301,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 75,
          "code_snippet": "    70 | \t\t\t\t\tzap.String(\"path\", path), \r\n    71 | \t\t\t\t\tzap.Error(err))\r\n    72 | \t\t\t\treturn nil // Continue loading other templates\r\n    73 | \t\t\t}\r\n    74 | \r\nâ†’   75 | \t\t\ttemplateInfo.Path = relPath\r\n    76 | \t\t\ttr.templates[templateInfo.Name] = templateInfo\r\n    77 | \t\t\ttr.logger.Info(\"Loaded template\", \r\n    78 | \t\t\t\tzap.String(\"name\", templateInfo.Name),\r\n    79 | \t\t\t\tzap.String(\"stack\", templateInfo.Stack))\r\n    80 | \t\t}\r\n",
          "full_function": "func (tr *TemplateRegistry) LoadTemplates(ctx context.Context) error {\r\n\ttr.mu.Lock()\r\n\tdefer tr.mu.Unlock()\r\n\r\n\ttr.logger.Info(\"Loading templates from\", zap.String(\"path\", tr.basePath))\r\n\r\n\t// Walk through the templates directory\r\n\terr := filepath.WalkDir(tr.basePath, func(path string, d fs.DirEntry, err error) error {\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\t// Look for manifest.yaml files\r\n\t\tif d.Name() == \"manifest.yaml\" {\r\n\t\t\ttemplateDir := filepath.Dir(path)\r\n\t\t\trelPath, err := filepath.Rel(tr.basePath, templateDir)\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn err\r\n\t\t\t}\r\n\r\n\t\t\ttemplateInfo, err := tr.loadTemplateFromManifest(path)\r\n\t\t\tif err != nil {\r\n\t\t\t\ttr.logger.Error(\"Failed to load template\", \r\n\t\t\t\t\tzap.String(\"path\", path), \r\n\t\t\t\t\tzap.Error(err))\r\n\t\t\t\treturn nil // Continue loading other templates\r\n\t\t\t}\r\n\r\n\t\t\ttemplateInfo.Path = relPath\r\n\t\t\ttr.templates[templateInfo.Name] = templateInfo\r\n\t\t\ttr.logger.Info(\"Loaded template\", \r\n\t\t\t\tzap.String(\"name\", templateInfo.Name),\r\n\t\t\t\tzap.String(\"stack\", templateInfo.Stack))\r\n\t\t}\r\n\r\n\t\treturn nil\r\n\t})\r\n\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed to walk templates directory: %w\", err)\r\n\t}\r\n\r\n\ttr.logger.Info(\"Templates loaded successfully\", zap.Int(\"count\", len(tr.templates)))\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 124,
          "code_snippet": "   119 | \r\n   120 | \ttemplateInfo := \u0026TemplateInfo{\r\n   121 | \t\tName:         manifest.Name,\r\n   122 | \t\tStack:        manifest.Stack,\r\n   123 | \t\tVersion:      manifest.Version,\r\nâ†’  124 | \t\tSummary:      manifest.Summary,\r\n   125 | \t\tPlaceholders: manifest.Placeholders,\r\n   126 | \t\tFiles:        manifest.Files,\r\n   127 | \t\tMetadata:     make(map[string]string),\r\n   128 | \t}\r\n   129 | \r\n",
          "full_function": "\t\tSummary:      manifest.Summary,\r\n\t\tPlaceholders: manifest.Placeholders,\r\n\t\tFiles:        manifest.Files,\r\n\t\tMetadata:     make(map[string]string),\r\n\t}\r\n\r\n\treturn templateInfo, nil\r\n}\r\n\r\n// GetTemplate returns a template by name\r\nfunc (tr *TemplateRegistry) GetTemplate(name string) (*TemplateInfo, error) {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplate, exists := tr.templates[name]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"template '%s' not found\", name)\r\n\t}\r\n\r\n\treturn template, nil\r\n}\r\n\r\n// ListTemplates returns all registered templates\r\nfunc (tr *TemplateRegistry) ListTemplates() []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplates := make([]*TemplateInfo, 0, len(tr.templates))\r\n\tfor _, template := range tr.templates {\r\n\t\ttemplates = append(templates, template)\r\n\t}\r\n\r\n\treturn templates\r\n}\r\n\r\n// ListTemplatesByStack returns templates filtered by stack\r\nfunc (tr *TemplateRegistry) ListTemplatesByStack(stack string) []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\tvar templates []*TemplateInfo\r\n\tfor _, template := range tr.templates {\r\n\t\tif template.Stack == stack {\r\n\t\t\ttemplates = append(templates, template)\r\n\t\t}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 125,
          "code_snippet": "   120 | \ttemplateInfo := \u0026TemplateInfo{\r\n   121 | \t\tName:         manifest.Name,\r\n   122 | \t\tStack:        manifest.Stack,\r\n   123 | \t\tVersion:      manifest.Version,\r\n   124 | \t\tSummary:      manifest.Summary,\r\nâ†’  125 | \t\tPlaceholders: manifest.Placeholders,\r\n   126 | \t\tFiles:        manifest.Files,\r\n   127 | \t\tMetadata:     make(map[string]string),\r\n   128 | \t}\r\n   129 | \r\n   130 | \treturn templateInfo, nil\r\n",
          "full_function": "\t\tPlaceholders: manifest.Placeholders,\r\n\t\tFiles:        manifest.Files,\r\n\t\tMetadata:     make(map[string]string),\r\n\t}\r\n\r\n\treturn templateInfo, nil\r\n}\r\n\r\n// GetTemplate returns a template by name\r\nfunc (tr *TemplateRegistry) GetTemplate(name string) (*TemplateInfo, error) {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplate, exists := tr.templates[name]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"template '%s' not found\", name)\r\n\t}\r\n\r\n\treturn template, nil\r\n}\r\n\r\n// ListTemplates returns all registered templates\r\nfunc (tr *TemplateRegistry) ListTemplates() []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplates := make([]*TemplateInfo, 0, len(tr.templates))\r\n\tfor _, template := range tr.templates {\r\n\t\ttemplates = append(templates, template)\r\n\t}\r\n\r\n\treturn templates\r\n}\r\n\r\n// ListTemplatesByStack returns templates filtered by stack\r\nfunc (tr *TemplateRegistry) ListTemplatesByStack(stack string) []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\tvar templates []*TemplateInfo\r\n\tfor _, template := range tr.templates {\r\n\t\tif template.Stack == stack {\r\n\t\t\ttemplates = append(templates, template)\r\n\t\t}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 21,
          "code_snippet": "    16 | \r\n    17 | // NewServiceDiscovery creates a new service discovery instance\r\n    18 | func NewServiceDiscovery(registry *MCPRegistry) *ServiceDiscovery {\r\n    19 | \treturn \u0026ServiceDiscovery{\r\n    20 | \t\tregistry: registry,\r\nâ†’   21 | \t\tlogger:   logger.GetLogger(),\r\n    22 | \t}\r\n    23 | }\r\n    24 | \r\n    25 | // DiscoverServices discovers services in the registry\r\n    26 | func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n",
          "full_function": "func NewServiceDiscovery(registry *MCPRegistry) *ServiceDiscovery {\r\n\treturn \u0026ServiceDiscovery{\r\n\t\tregistry: registry,\r\n\t\tlogger:   logger.GetLogger(),\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 27,
          "code_snippet": "    22 | \t}\r\n    23 | }\r\n    24 | \r\n    25 | // DiscoverServices discovers services in the registry\r\n    26 | func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\nâ†’   27 | \tsd.mu.RLock()\r\n    28 | \tdefer sd.mu.RUnlock()\r\n    29 | \r\n    30 | \tvar results []*ServiceInfo\r\n    31 | \t\r\n    32 | \tfor _, service := range sd.registry.services {\r\n",
          "full_function": "func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n\tsd.mu.RLock()\r\n\tdefer sd.mu.RUnlock()\r\n\r\n\tvar results []*ServiceInfo\r\n\t\r\n\tfor _, service := range sd.registry.services {\r\n\t\tif matchesQuery(service, query) {\r\n\t\t\tresults = append(results, service)\r\n\t\t}\r\n\t}\r\n\r\n\treturn results, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 28,
          "code_snippet": "    23 | }\r\n    24 | \r\n    25 | // DiscoverServices discovers services in the registry\r\n    26 | func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n    27 | \tsd.mu.RLock()\r\nâ†’   28 | \tdefer sd.mu.RUnlock()\r\n    29 | \r\n    30 | \tvar results []*ServiceInfo\r\n    31 | \t\r\n    32 | \tfor _, service := range sd.registry.services {\r\n    33 | \t\tif matchesQuery(service, query) {\r\n",
          "full_function": "func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n\tsd.mu.RLock()\r\n\tdefer sd.mu.RUnlock()\r\n\r\n\tvar results []*ServiceInfo\r\n\t\r\n\tfor _, service := range sd.registry.services {\r\n\t\tif matchesQuery(service, query) {\r\n\t\t\tresults = append(results, service)\r\n\t\t}\r\n\t}\r\n\r\n\treturn results, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 51,
          "code_snippet": "    46 | \t\r\n    47 | \t// Simple string matching - could be enhanced with regex or fuzzy matching\r\n    48 | \treturn fmt.Sprintf(\"%s %s %s\", \r\n    49 | \t\tservice.Name, \r\n    50 | \t\tservice.Type, \r\nâ†’   51 | \t\tservice.Description) == query\r\n    52 | }\r\n    53 | \r\n    54 | // WatchServices watches for changes in services\r\n    55 | func (sd *ServiceDiscovery) WatchServices(ctx context.Context) (\u003c-chan *ServiceEvent, error) {\r\n    56 | \teventChan := make(chan *ServiceEvent, 100)\r\n",
          "full_function": "func matchesQuery(service *ServiceInfo, query string) bool {\r\n\tif query == \"\" {\r\n\t\treturn true\r\n\t}\r\n\t\r\n\t// Simple string matching - could be enhanced with regex or fuzzy matching\r\n\treturn fmt.Sprintf(\"%s %s %s\", \r\n\t\tservice.Name, \r\n\t\tservice.Type, \r\n\t\tservice.Description) == query\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\service_registry.go",
          "line_number": 33,
          "code_snippet": "    28 | // RegisterService registers a new service\r\n    29 | func (sr *ServiceRegistry) RegisterService(ctx context.Context, service *ServiceInfo) error {\r\n    30 | \tsr.mu.Lock()\r\n    31 | \tdefer sr.mu.Unlock()\r\n    32 | \r\nâ†’   33 | \tservice.LastChecked = time.Now()\r\n    34 | \tsr.services[service.ID] = service\r\n    35 | \t\r\n    36 | \tsr.logger.Info(\"Service registered\",\r\n    37 | \t\tzap.String(\"id\", service.ID),\r\n    38 | \t\tzap.String(\"name\", service.Name),\r\n",
          "full_function": "func (sr *ServiceRegistry) RegisterService(ctx context.Context, service *ServiceInfo) error {\r\n\tsr.mu.Lock()\r\n\tdefer sr.mu.Unlock()\r\n\r\n\tservice.LastChecked = time.Now()\r\n\tsr.services[service.ID] = service\r\n\t\r\n\tsr.logger.Info(\"Service registered\",\r\n\t\tzap.String(\"id\", service.ID),\r\n\t\tzap.String(\"name\", service.Name),\r\n\t\tzap.String(\"type\", service.Type))\r\n\t\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\service_registry.go",
          "line_number": 96,
          "code_snippet": "    91 | \tif !exists {\r\n    92 | \t\treturn fmt.Errorf(\"service %s not found\", serviceID)\r\n    93 | \t}\r\n    94 | \r\n    95 | \tservice.Status = status\r\nâ†’   96 | \tservice.LastChecked = time.Now()\r\n    97 | \t\r\n    98 | \tsr.logger.Info(\"Service status updated\",\r\n    99 | \t\tzap.String(\"id\", serviceID),\r\n   100 | \t\tzap.String(\"status\", status))\r\n   101 | \t\r\n",
          "full_function": "func (sr *ServiceRegistry) UpdateServiceStatus(ctx context.Context, serviceID, status string) error {\r\n\tsr.mu.Lock()\r\n\tdefer sr.mu.Unlock()\r\n\r\n\tservice, exists := sr.services[serviceID]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"service %s not found\", serviceID)\r\n\t}\r\n\r\n\tservice.Status = status\r\n\tservice.LastChecked = time.Now()\r\n\t\r\n\tsr.logger.Info(\"Service status updated\",\r\n\t\tzap.String(\"id\", serviceID),\r\n\t\tzap.String(\"status\", status))\r\n\t\r\n\treturn nil\r\n}",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 125,
          "code_snippet": "   120 | \ttemplateInfo := \u0026TemplateInfo{\r\n   121 | \t\tName:         manifest.Name,\r\n   122 | \t\tStack:        manifest.Stack,\r\n   123 | \t\tVersion:      manifest.Version,\r\n   124 | \t\tSummary:      manifest.Summary,\r\nâ†’  125 | \t\tPlaceholders: manifest.Placeholders,\r\n   126 | \t\tFiles:        manifest.Files,\r\n   127 | \t\tMetadata:     make(map[string]string),\r\n   128 | \t}\r\n   129 | \r\n   130 | \treturn templateInfo, nil\r\n",
          "full_function": "\t\tPlaceholders: manifest.Placeholders,\r\n\t\tFiles:        manifest.Files,\r\n\t\tMetadata:     make(map[string]string),\r\n\t}\r\n\r\n\treturn templateInfo, nil\r\n}\r\n\r\n// GetTemplate returns a template by name\r\nfunc (tr *TemplateRegistry) GetTemplate(name string) (*TemplateInfo, error) {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplate, exists := tr.templates[name]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"template '%s' not found\", name)\r\n\t}\r\n\r\n\treturn template, nil\r\n}\r\n\r\n// ListTemplates returns all registered templates\r\nfunc (tr *TemplateRegistry) ListTemplates() []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplates := make([]*TemplateInfo, 0, len(tr.templates))\r\n\tfor _, template := range tr.templates {\r\n\t\ttemplates = append(templates, template)\r\n\t}\r\n\r\n\treturn templates\r\n}\r\n\r\n// ListTemplatesByStack returns templates filtered by stack\r\nfunc (tr *TemplateRegistry) ListTemplatesByStack(stack string) []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\tvar templates []*TemplateInfo\r\n\tfor _, template := range tr.templates {\r\n\t\tif template.Stack == stack {\r\n\t\t\ttemplates = append(templates, template)\r\n\t\t}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\redis\\reservation_lock.go",
          "line_number": 55,
          "code_snippet": "    50 | // ReleaseLock releases a distributed lock\r\n    51 | func (l *ReservationLock) ReleaseLock(ctx context.Context, key string) error {\r\n    52 | \tlockKey := lockKey(key)\r\n    53 | \r\n    54 | \t// Lua script for atomic lock release (only if we own it)\r\nâ†’   55 | \tscript := `\r\n    56 | \t\tif redis.call(\"get\", KEYS[1]) == ARGV[1] then\r\n    57 | \t\t\treturn redis.call(\"del\", KEYS[1])\r\n    58 | \t\telse\r\n    59 | \t\t\treturn 0\r\n    60 | \t\tend\r\n",
          "full_function": "func (l *ReservationLock) ReleaseLock(ctx context.Context, key string) error {\r\n\tlockKey := lockKey(key)\r\n\r\n\t// Lua script for atomic lock release (only if we own it)\r\n\tscript := `\r\n\t\tif redis.call(\"get\", KEYS[1]) == ARGV[1] then\r\n\t\t\treturn redis.call(\"del\", KEYS[1])\r\n\t\telse\r\n\t\t\treturn 0\r\n\t\tend\r\n\t`\r\n\r\n\t// Note: In a real implementation, we'd need to store the lock value\r\n\t// to properly release it. For simplicity, we'll use a simpler approach.\r\n\t_, err := l.client.Del(ctx, lockKey).Result()\r\n\treturn err\r\n}\r",
          "symbol_name": "",
          "package_name": "redis",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "github.com/go-redis/redis/v8"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\cmd\\tools-validator\\main.go",
          "line_number": 60,
          "code_snippet": "    55 | \t\tresult, err = validator.ValidateTemplate(ctx, req)\r\n    56 | \r\n    57 | \tcase \"config\":\r\n    58 | \t\treq := validators.ConfigValidateRequest{\r\n    59 | \t\t\tPath:       path,\r\nâ†’   60 | \t\t\tStrictMode: strictMode,\r\n    61 | \t\t}\r\n    62 | \t\tvalidator := validators.NewConfigValidator()\r\n    63 | \t\tresult, err = validator.ValidateConfig(ctx, req)\r\n    64 | \r\n    65 | \tcase \"code\":\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "encoding/json",
            "flag",
            "fmt",
            "os",
            "github.com/vertikon/mcp-core-inventory/tools/validators"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\memory_optimizer.go",
          "line_number": 31,
          "code_snippet": "    26 | \r\n    27 | // EvictionPolicy represents different eviction strategies\r\n    28 | type EvictionPolicy string\r\n    29 | \r\n    30 | const (\r\nâ†’   31 | \tPolicyLRU      EvictionPolicy = \"lru\"\r\n    32 | \tPolicyLFU      EvictionPolicy = \"lfu\"\r\n    33 | \tPolicyFIFO     EvictionPolicy = \"fifo\"\r\n    34 | \tPolicyRandom   EvictionPolicy = \"random\"\r\n    35 | \tPolicyTTL      EvictionPolicy = \"ttl\"\r\n    36 | )\r\n",
          "full_function": "\tPolicyLRU      EvictionPolicy = \"lru\"\r\n\tPolicyLFU      EvictionPolicy = \"lfu\"\r\n\tPolicyFIFO     EvictionPolicy = \"fifo\"\r\n\tPolicyRandom   EvictionPolicy = \"random\"\r\n\tPolicyTTL      EvictionPolicy = \"ttl\"\r\n)\r\n\r\n// MemoryPool represents a pooled memory allocator\r\ntype MemoryPool struct {\r\n\tconfig         MemoryOptimizerConfig\r\n\tpools          map[int]*MemorySegment\r\n\tfreeSegments   chan *MemorySegment\r\n\tusedSegments   map[string]*MemorySegment\r\n\tsegmentsMu     sync.RWMutex\r\n\tstats          *MemoryPoolStats\r\n\tcompactor      *MemoryCompactor\r\n\tgarbageCollector *GarbageCollector\r\n\tctx            context.Context\r\n\tcancel         context.CancelFunc\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\core\\crush\\batch_processor.go",
          "line_number": 155,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\memory_optimizer.go",
          "line_number": 395,
          "code_snippet": "   390 | \t\t\tcontinue\r\n   391 | \t\t}\r\n   392 | \r\n   393 | \t\t// Check based on policy\r\n   394 | \t\tswitch mo.config.EvictionPolicy {\r\nâ†’  395 | \t\tcase PolicyLRU:\r\n   396 | \t\t\t// Will be sorted by LastUsed\r\n   397 | \t\tcase PolicyLFU:\r\n   398 | \t\t\t// Will be sorted by AccessCount\r\n   399 | \t\tcase PolicyTTL:\r\n   400 | \t\t\t// Already handled\r\n",
          "full_function": "\t\tcase PolicyLRU:\r\n\t\t\t// Will be sorted by LastUsed\r\n\t\tcase PolicyLFU:\r\n\t\t\t// Will be sorted by AccessCount\r\n\t\tcase PolicyTTL:\r\n\t\t\t// Already handled\r\n\t\t}\r\n\t}\r\n\r\n\t// Sort candidates based on eviction policy\r\n\tmo.sortEvictionCandidates(candidates)\r\n\r\n\t// Evict candidates (remove oldest 20%)\r\n\tevictCount := max(1, len(candidates)/5)\r\n\tfor i := 0; i \u003c evictCount \u0026\u0026 i \u003c len(candidates); i++ {\r\n\t\tsegment := candidates[i]\r\n\t\tdelete(mo.usedSegments, segment.ID)\r\n\t\t\r\n\t\t// Add to free pool\r\n\t\tselect {\r\n\t\tcase mo.freeSegments \u003c- segment:\r\n\t\tdefault:\r\n\t\t}\r\n\t\t\r\n\t\tatomic.AddInt64(\u0026mo.stats.Evictions, 1)\r\n\t\t\r\n\t\tlogger.Debug(\"Evicted memory segment\",\r\n\t\t\tzap.String(\"segment_id\", segment.ID),\r\n\t\t\tzap.Int(\"size\", segment.Size),\r\n\t\t)\r\n\t}\r\n}\r\n\r\n// sortEvictionCandidates sorts candidates based on eviction policy\r\nfunc (mo *MemoryPool) sortEvictionCandidates(candidates []*MemorySegment) {\r\n\tswitch mo.config.EvictionPolicy {\r\n\tcase PolicyLRU:\r\n\t\t// Sort by LastUsed (oldest first)\r\n\t\tfor i := 0; i \u003c len(candidates)-1; i++ {\r\n\t\t\tfor j := i + 1; j \u003c len(candidates); j++ {\r\n\t\t\t\tif candidates[i].LastUsed.After(candidates[j].LastUsed) {\r\n\t\t\t\t\tcandidates[i], candidates[j] = candidates[j], candidates[i]\r\n\t\t\t\t}\r\n\t\t\t}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 625,
          "code_snippet": "   620 | \tas.stats.ScaleDownEvents++\r\n   621 | \tnow := time.Now()\r\n   622 | \tas.stats.LastScalingTime = \u0026now\r\n   623 | }\r\n   624 | \r\nâ†’  625 | func min(a, b int) int {\r\n   626 | \tif a \u003c b {\r\n   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n",
          "full_function": "func min(a, b int) int {\r\n\tif a \u003c b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\core\\crush\\batch_processor.go",
          "line_number": 796,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 632,
          "code_snippet": "   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n   631 | \r\nâ†’  632 | func max(a, b int) int {\r\n   633 | \tif a \u003e b {\r\n   634 | \t\treturn a\r\n   635 | \t}\r\n   636 | \treturn b\r\n   637 | }\n",
          "full_function": "func max(a, b int) int {\r\n\tif a \u003e b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\core\\crush\\batch_processor.go",
          "line_number": 803,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 269,
          "code_snippet": "   264 | \r\n   265 | \t// Initialize async processor\r\n   266 | \tif config.EnableAsync {\r\n   267 | \t\tprocessor.asyncProcessor = NewAsyncBatchProcessor(AsyncProcessingConfig{\r\n   268 | \t\t\tEnabled:       true,\r\nâ†’  269 | \t\t\tNumWorkers:    runtime.NumCPU(),\r\n   270 | \t\t\tQueueSize:     100,\r\n   271 | \t\t\tWorkerTimeout: config.Timeout,\r\n   272 | \t\t\tRetryAttempts: 3,\r\n   273 | \t\t})\r\n   274 | \t}\r\n",
          "full_function": "func NewBatchProcessor(config BatchProcessorConfig) *BatchProcessor {\r\n\tif config.MaxBatchSize == 0 {\r\n\t\tconfig.MaxBatchSize = 32\r\n\t}\r\n\tif config.MinBatchSize == 0 {\r\n\t\tconfig.MinBatchSize = 1\r\n\t}\r\n\tif config.Timeout == 0 {\r\n\t\tconfig.Timeout = 5 * time.Second\r\n\t}\r\n\r\n\tlogger.Info(\"Creating batch processor\",\r\n\t\tzap.Int(\"max_batch_size\", config.MaxBatchSize),\r\n\t\tzap.Int(\"min_batch_size\", config.MinBatchSize),\r\n\t\tzap.Duration(\"timeout\", config.Timeout),\r\n\t\tzap.Bool(\"dynamic_batching\", config.EnableDynamicBatching),\r\n\t\tzap.Bool(\"prefetch\", config.EnablePrefetch),\r\n\t\tzap.Bool(\"async\", config.EnableAsync),\r\n\t)\r\n\r\n\tctx, cancel := context.WithCancel(context.Background())\r\n\t\r\n\tprocessor := \u0026BatchProcessor{\r\n\t\tconfig:      config,\r\n\t\tbatches:     make(map[string]*Batch),\r\n\t\tbatchQueue:  make(chan *Batch, 100),\r\n\t\tresultQueue: make(chan *BatchResult, 100),\r\n\t\tctx:         ctx,\r\n\t\tcancel:      cancel,\r\n\t\tstats:       \u0026BatchProcessorStats{},\r\n\t}\r\n\r\n\t// Initialize dynamic sizing\r\n\tif config.EnableDynamicBatching {\r\n\t\tprocessor.dynamicSizing = NewDynamicBatchSizer(DynamicSizingConfig{\r\n\t\t\tEnabled:   true,\r\n\t\t\tStrategy:  StrategyAdaptive,\r\n\t\t\tMinSize:   config.MinBatchSize,\r\n\t\t\tMaxSize:   config.MaxBatchSize,\r\n\t\t\tTargetLatency: config.MaxLatency,\r\n\t\t})\r\n\t}\r\n\r\n\t// Initialize prefetcher\r\n\tif config.EnablePrefetch {\r\n\t\tprocessor.prefetcher = NewBatchPrefetcher(PrefetchConfig{\r\n\t\t\tEnabled:      true,\r\n\t\t\tPrefetchSize: config.MaxBatchSize,\r\n\t\t\tCacheSize:    100,\r\n\t\t\tPrefetchPolicy: PolicyPredictive,\r\n\t\t})\r\n\t}\r\n\r\n\t// Initialize async processor\r\n\tif config.EnableAsync {\r\n\t\tprocessor.asyncProcessor = NewAsyncBatchProcessor(AsyncProcessingConfig{\r\n\t\t\tEnabled:       true,\r\n\t\t\tNumWorkers:    runtime.NumCPU(),\r\n\t\t\tQueueSize:     100,\r\n\t\t\tWorkerTimeout: config.Timeout,\r\n\t\t\tRetryAttempts: 3,\r\n\t\t})\r\n\t}\r\n\r\n\treturn processor\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 427,
          "code_snippet": "   422 | func (bp *BatchProcessor) checkBatchTimeouts() {\r\n   423 | \tbp.mu.Lock()\r\n   424 | \tdefer bp.mu.Unlock()\r\n   425 | \r\n   426 | \tnow := time.Now()\r\nâ†’  427 | \tfor id, batch := range bp.batches {\r\n   428 | \t\tif now.Sub(batch.CreatedAt) \u003e= batch.Timeout \u0026\u0026 len(batch.Items) \u003e 0 {\r\n   429 | \t\t\tbp.submitBatch(batch)\r\n   430 | \t\t}\r\n   431 | \t}\r\n   432 | }\r\n",
          "full_function": "func (bp *BatchProcessor) checkBatchTimeouts() {\r\n\tbp.mu.Lock()\r\n\tdefer bp.mu.Unlock()\r\n\r\n\tnow := time.Now()\r\n\tfor id, batch := range bp.batches {\r\n\t\tif now.Sub(batch.CreatedAt) \u003e= batch.Timeout \u0026\u0026 len(batch.Items) \u003e 0 {\r\n\t\t\tbp.submitBatch(batch)\r\n\t\t}\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 560,
          "code_snippet": "   555 | // updateStats updates batch processing statistics\r\n   556 | func (bp *BatchProcessor) updateStats(batch *Batch, result *BatchResult) {\r\n   557 | \tatomic.AddInt64(\u0026bp.stats.TotalBatches, 1)\r\n   558 | \tatomic.AddInt64(\u0026bp.stats.TotalItems, int64(batch.Size))\r\n   559 | \tatomic.AddInt64(\u0026bp.stats.CompletedBatches, 1)\r\nâ†’  560 | \tatomic.AddInt64(\u0026bp.stats.TotalProcessingTime, int64(result.Duration))\r\n   561 | \r\n   562 | \tif len(result.Errors) \u003e 0 {\r\n   563 | \t\tatomic.AddInt64(\u0026bp.stats.FailedBatches, 1)\r\n   564 | \t}\r\n   565 | }\r\n",
          "full_function": "func (bp *BatchProcessor) updateStats(batch *Batch, result *BatchResult) {\r\n\tatomic.AddInt64(\u0026bp.stats.TotalBatches, 1)\r\n\tatomic.AddInt64(\u0026bp.stats.TotalItems, int64(batch.Size))\r\n\tatomic.AddInt64(\u0026bp.stats.CompletedBatches, 1)\r\n\tatomic.AddInt64(\u0026bp.stats.TotalProcessingTime, int64(result.Duration))\r\n\r\n\tif len(result.Errors) \u003e 0 {\r\n\t\tatomic.AddInt64(\u0026bp.stats.FailedBatches, 1)\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 584,
          "code_snippet": "   579 | \t\tbp.stats.AvgBatchSize = float64(totalItems) / float64(totalBatches)\r\n   580 | \t}\r\n   581 | \r\n   582 | \t// Calculate average processing time\r\n   583 | \tcompletedBatches := atomic.LoadInt64(\u0026bp.stats.CompletedBatches)\r\nâ†’  584 | \ttotalProcessingTime := atomic.LoadInt64(\u0026bp.stats.TotalProcessingTime)\r\n   585 | \t\r\n   586 | \tif completedBatches \u003e 0 {\r\n   587 | \t\tbp.stats.AvgProcessingTime = time.Duration(totalProcessingTime / completedBatches)\r\n   588 | \t}\r\n   589 | \r\n",
          "full_function": "func (bp *BatchProcessor) collectStats() {\r\n\tbp.stats.LastUpdated = time.Now()\r\n\r\n\t// Calculate queue utilization\r\n\tbp.stats.QueueUtilization = float64(len(bp.batchQueue)) / float64(cap(bp.batchQueue))\r\n\r\n\t// Calculate average batch size\r\n\ttotalBatches := atomic.LoadInt64(\u0026bp.stats.TotalBatches)\r\n\ttotalItems := atomic.LoadInt64(\u0026bp.stats.TotalItems)\r\n\t\r\n\tif totalBatches \u003e 0 {\r\n\t\tbp.stats.AvgBatchSize = float64(totalItems) / float64(totalBatches)\r\n\t}\r\n\r\n\t// Calculate average processing time\r\n\tcompletedBatches := atomic.LoadInt64(\u0026bp.stats.CompletedBatches)\r\n\ttotalProcessingTime := atomic.LoadInt64(\u0026bp.stats.TotalProcessingTime)\r\n\t\r\n\tif completedBatches \u003e 0 {\r\n\t\tbp.stats.AvgProcessingTime = time.Duration(totalProcessingTime / completedBatches)\r\n\t}\r\n\r\n\t// Calculate throughput\r\n\tif completedBatches \u003e 0 {\r\n\t\tbp.stats.Throughput = float64(totalItems) / time.Since(time.Now()).Seconds()\r\n\t}\r\n\r\n\tlogger.Debug(\"Batch processor stats\",\r\n\t\tzap.Float64(\"queue_utilization\", bp.stats.QueueUtilization),\r\n\t\tzap.Float64(\"avg_batch_size\", bp.stats.AvgBatchSize),\r\n\t\tzap.Duration(\"avg_processing_time\", bp.stats.AvgProcessingTime),\r\n\t\tzap.Float64(\"throughput\", bp.stats.Throughput),\r\n\t)\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 781,
          "code_snippet": "   776 | \r\n   777 | // NewAsyncBatchProcessor creates a new async batch processor\r\n   778 | func NewAsyncBatchProcessor(config AsyncProcessingConfig) *AsyncBatchProcessor {\r\n   779 | \treturn \u0026AsyncBatchProcessor{\r\n   780 | \t\tconfig:     config,\r\nâ†’  781 | \t\tworkerPool: NewWorkerPool(config.NumWorkers, config.QueueSize, config.WorkerTimeout),\r\n   782 | \t\tstats:      \u0026AsyncProcessingStats{},\r\n   783 | \t}\r\n   784 | }\r\n   785 | \r\n   786 | // Start starts async batch processor\r\n",
          "full_function": "func NewAsyncBatchProcessor(config AsyncProcessingConfig) *AsyncBatchProcessor {\r\n\treturn \u0026AsyncBatchProcessor{\r\n\t\tconfig:     config,\r\n\t\tworkerPool: NewWorkerPool(config.NumWorkers, config.QueueSize, config.WorkerTimeout),\r\n\t\tstats:      \u0026AsyncProcessingStats{},\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 792,
          "code_snippet": "   787 | func (abp *AsyncBatchProcessor) Start(ctx context.Context) {\r\n   788 | \tif !abp.config.Enabled {\r\n   789 | \t\treturn\r\n   790 | \t}\r\n   791 | \r\nâ†’  792 | \tabp.workerPool.Start(ctx)\r\n   793 | }\r\n   794 | \r\n   795 | // Additional helper functions\r\n   796 | func min(a, b int) int {\r\n   797 | \tif a \u003c b {\r\n",
          "full_function": "func (abp *AsyncBatchProcessor) Start(ctx context.Context) {\r\n\tif !abp.config.Enabled {\r\n\t\treturn\r\n\t}\r\n\r\n\tabp.workerPool.Start(ctx)\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\memory_optimizer.go",
          "line_number": 395,
          "code_snippet": "   390 | \t\t\tcontinue\r\n   391 | \t\t}\r\n   392 | \r\n   393 | \t\t// Check based on policy\r\n   394 | \t\tswitch mo.config.EvictionPolicy {\r\nâ†’  395 | \t\tcase PolicyLRU:\r\n   396 | \t\t\t// Will be sorted by LastUsed\r\n   397 | \t\tcase PolicyLFU:\r\n   398 | \t\t\t// Will be sorted by AccessCount\r\n   399 | \t\tcase PolicyTTL:\r\n   400 | \t\t\t// Already handled\r\n",
          "full_function": "\t\tcase PolicyLRU:\r\n\t\t\t// Will be sorted by LastUsed\r\n\t\tcase PolicyLFU:\r\n\t\t\t// Will be sorted by AccessCount\r\n\t\tcase PolicyTTL:\r\n\t\t\t// Already handled\r\n\t\t}\r\n\t}\r\n\r\n\t// Sort candidates based on eviction policy\r\n\tmo.sortEvictionCandidates(candidates)\r\n\r\n\t// Evict candidates (remove oldest 20%)\r\n\tevictCount := max(1, len(candidates)/5)\r\n\tfor i := 0; i \u003c evictCount \u0026\u0026 i \u003c len(candidates); i++ {\r\n\t\tsegment := candidates[i]\r\n\t\tdelete(mo.usedSegments, segment.ID)\r\n\t\t\r\n\t\t// Add to free pool\r\n\t\tselect {\r\n\t\tcase mo.freeSegments \u003c- segment:\r\n\t\tdefault:\r\n\t\t}\r\n\t\t\r\n\t\tatomic.AddInt64(\u0026mo.stats.Evictions, 1)\r\n\t\t\r\n\t\tlogger.Debug(\"Evicted memory segment\",\r\n\t\t\tzap.String(\"segment_id\", segment.ID),\r\n\t\t\tzap.Int(\"size\", segment.Size),\r\n\t\t)\r\n\t}\r\n}\r\n\r\n// sortEvictionCandidates sorts candidates based on eviction policy\r\nfunc (mo *MemoryPool) sortEvictionCandidates(candidates []*MemorySegment) {\r\n\tswitch mo.config.EvictionPolicy {\r\n\tcase PolicyLRU:\r\n\t\t// Sort by LastUsed (oldest first)\r\n\t\tfor i := 0; i \u003c len(candidates)-1; i++ {\r\n\t\t\tfor j := i + 1; j \u003c len(candidates); j++ {\r\n\t\t\t\tif candidates[i].LastUsed.After(candidates[j].LastUsed) {\r\n\t\t\t\t\tcandidates[i], candidates[j] = candidates[j], candidates[i]\r\n\t\t\t\t}\r\n\t\t\t}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\domain\\services\\ai_domain_service.go",
          "line_number": 33,
          "code_snippet": "    28 | \tcontext := mcp.Context()\r\n    29 | \tif context == nil {\r\n    30 | \t\treturn fmt.Errorf(\"knowledge context is nil\")\r\n    31 | \t}\r\n    32 | \r\nâ†’   33 | \tif len(context.documents) == 0 {\r\n    34 | \t\treturn fmt.Errorf(\"knowledge context must have at least one document\")\r\n    35 | \t}\r\n    36 | \r\n    37 | \treturn nil\r\n    38 | }\r\n",
          "full_function": "func (s *AIDomainService) ValidateKnowledgeContext(mcp *entities.MCP) error {\r\n\tif mcp == nil {\r\n\t\treturn fmt.Errorf(\"MCP cannot be nil\")\r\n\t}\r\n\r\n\tif !mcp.HasContext() {\r\n\t\treturn fmt.Errorf(\"MCP does not have knowledge context\")\r\n\t}\r\n\r\n\tcontext := mcp.Context()\r\n\tif context == nil {\r\n\t\treturn fmt.Errorf(\"knowledge context is nil\")\r\n\t}\r\n\r\n\tif len(context.documents) == 0 {\r\n\t\treturn fmt.Errorf(\"knowledge context must have at least one document\")\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "services",
          "dependencies": [
            "fmt",
            "github.com/vertikon/mcp-core-inventory/internal/domain/entities"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 543,
          "code_snippet": "   538 | \t}\r\n   539 | \r\n   540 | \tstart := time.Now()\r\n   541 | \tdefer func() {\r\n   542 | \t\tatomic.AddInt64(\u0026dss.stats.LockOperations, 1)\r\nâ†’  543 | \t\tatomic.StoreInt64(\u0026dss.stats.LockWaitTime.Nanoseconds(), time.Since(start).Nanoseconds())\r\n   544 | \t}()\r\n   545 | \r\n   546 | \t// Try remote store first\r\n   547 | \tlock, err := dss.remoteStore.Lock(ctx, key, ttl)\r\n   548 | \tif err == nil {\r\n",
          "full_function": "func (dss *DistributedStateStore) Lock(ctx context.Context, key string, ttl time.Duration) (*Lock, error) {\r\n\tif !dss.config.EnableLocking {\r\n\t\treturn nil, fmt.Errorf(\"locking is not enabled\")\r\n\t}\r\n\r\n\tstart := time.Now()\r\n\tdefer func() {\r\n\t\tatomic.AddInt64(\u0026dss.stats.LockOperations, 1)\r\n\t\tatomic.StoreInt64(\u0026dss.stats.LockWaitTime.Nanoseconds(), time.Since(start).Nanoseconds())\r\n\t}()\r\n\r\n\t// Try remote store first\r\n\tlock, err := dss.remoteStore.Lock(ctx, key, ttl)\r\n\tif err == nil {\r\n\t\treturn lock, nil\r\n\t}\r\n\r\n\t// Fallback to local store\r\n\treturn dss.localStore.Lock(ctx, key, ttl)\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 649,
          "code_snippet": "   644 | \treturn *dss.stats\r\n   645 | }\r\n   646 | \r\n   647 | // updateReadLatency updates read latency statistics\r\n   648 | func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\nâ†’  649 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n   650 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n   651 | \tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n   652 | }\r\n   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n",
          "full_function": "func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 651,
          "code_snippet": "   646 | \r\n   647 | // updateReadLatency updates read latency statistics\r\n   648 | func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\n   649 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n   650 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\nâ†’  651 | \tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n   652 | }\r\n   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n   655 | func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n   656 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n",
          "full_function": "func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 656,
          "code_snippet": "   651 | \tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n   652 | }\r\n   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n   655 | func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\nâ†’  656 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n   657 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n   658 | \tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n   659 | }\r\n   660 | \r\n   661 | // NewMemoryStateStore creates a new in-memory state store\r\n",
          "full_function": "func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 658,
          "code_snippet": "   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n   655 | func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n   656 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n   657 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\nâ†’  658 | \tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n   659 | }\r\n   660 | \r\n   661 | // NewMemoryStateStore creates a new in-memory state store\r\n   662 | func NewMemoryStateStore() *MemoryStateStore {\r\n   663 | \treturn \u0026MemoryStateStore{\r\n",
          "full_function": "func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\store.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"context\"\r\n     6 | \t\"encoding/json\"\r\n     7 | \t\"time\"\r\n     8 | \r\n     9 | \t\"github.com/dgraph-io/badger/v4\"\r\nâ†’   10 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n    11 | \t\"go.uber.org/zap\"\r\n    12 | )\r\n    13 | \r\n    14 | // Store provides persistent state storage using BadgerDB\r\n    15 | type Store struct {\r\n",
          "full_function": "\t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n\t\"go.uber.org/zap\"\r\n)\r\n\r\n// Store provides persistent state storage using BadgerDB\r\ntype Store struct {\r\n\tdb *badger.DB\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "time",
            "github.com/dgraph-io/badger/v4",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\store.go",
          "line_number": 11,
          "code_snippet": "     6 | \t\"encoding/json\"\r\n     7 | \t\"time\"\r\n     8 | \r\n     9 | \t\"github.com/dgraph-io/badger/v4\"\r\n    10 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\nâ†’   11 | \t\"go.uber.org/zap\"\r\n    12 | )\r\n    13 | \r\n    14 | // Store provides persistent state storage using BadgerDB\r\n    15 | type Store struct {\r\n    16 | \tdb *badger.DB\r\n",
          "full_function": "\t\"go.uber.org/zap\"\r\n)\r\n\r\n// Store provides persistent state storage using BadgerDB\r\ntype Store struct {\r\n\tdb *badger.DB\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "time",
            "github.com/dgraph-io/badger/v4",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\feedforward.go",
          "line_number": 194,
          "code_snippet": "   189 | }\r\n   190 | \r\n   191 | // forwardMoE performs mixture of experts computation\r\n   192 | func (ffn *FeedForwardNetwork) forwardMoE(ctx context.Context, input *Tensor) (*Tensor, error) {\r\n   193 | \t// Router determines which experts to use\r\nâ†’  194 | \trouter, err := ffn.router.Forward(input)\r\n   195 | \tif err != nil {\r\n   196 | \t\treturn nil, fmt.Errorf(\"routing error: %w\", err)\r\n   197 | \t}\r\n   198 | \r\n   199 | \t// Select top-k experts\r\n",
          "full_function": "func (ffn *FeedForwardNetwork) forwardMoE(ctx context.Context, input *Tensor) (*Tensor, error) {\r\n\t// Router determines which experts to use\r\n\trouter, err := ffn.router.Forward(input)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"routing error: %w\", err)\r\n\t}\r\n\r\n\t// Select top-k experts\r\n\tselectedExperts := ffn.selectTopKExperts(router)\r\n\r\n\t// Combine expert outputs\r\n\toutput := ffn.combineExperts(input, selectedExperts)\r\n\r\n\treturn output, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "math",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 152,
          "code_snippet": "   147 | \t\treturn nil, ctx.Err()\n   148 | \tdefault:\n   149 | \t}\n   150 | \n   151 | \t// Embedding layer\nâ†’  152 | \thidden, err := t.embeddings.Forward(input)\n   153 | \tif err != nil {\n   154 | \t\treturn nil, fmt.Errorf(\"embedding error: %w\", err)\n   155 | \t}\n   156 | \n   157 | \t// Add positional encoding\n",
          "full_function": "func (t *GLMTransformer) Forward(ctx context.Context, input *Tensor, attentionMask *Tensor) (*Tensor, error) {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\t// Embedding layer\n\thidden, err := t.embeddings.Forward(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"embedding error: %w\", err)\n\t}\n\n\t// Add positional encoding\n\tif t.posEncoding != nil {\n\t\tposEncoded, err := t.posEncoding.Forward(ctx, hidden, 0)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"positional encoding error: %w\", err)\n\t\t}\n\t\thidden = posEncoded\n\t}\n\n\t// Pass through transformer layers\n\tfor i, layer := range t.layers {\n\t\tselect {\n\t\tcase \u003c-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tlayerOutput, err := layer.Forward(ctx, hidden, attentionMask)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"layer %d error: %w\", i, err)\n\t\t}\n\t\thidden = layerOutput\n\n\t\tlogger.Debug(\"Transformer layer processed\",\n\t\t\tzap.Int(\"layer\", i),\n\t\t\tzap.Float64(\"mean_activation\", t.meanActivation(hidden)),\n\t\t)\n\t}\n\n\t// Final layer norm\n\toutput, err := t.layernorm.Forward(hidden)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"final layer norm error: %w\", err)\n\t}\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 209,
          "code_snippet": "   204 | \tnormInput, err := l.layernorm1.Forward(input)\n   205 | \tif err != nil {\n   206 | \t\treturn nil, fmt.Errorf(\"pre-norm error: %w\", err)\n   207 | \t}\n   208 | \nâ†’  209 | \tattnOutput, err := l.attention.Forward(ctx, normInput, normInput, normInput, attentionMask)\n   210 | \tif err != nil {\n   211 | \t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n   212 | \t}\n   213 | \n   214 | \t// Residual connection\n",
          "full_function": "func (l *TransformerLayer) Forward(ctx context.Context, input *Tensor, attentionMask *Tensor) (*Tensor, error) {\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\t// Pre-norm + attention\n\tnormInput, err := l.layernorm1.Forward(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"pre-norm error: %w\", err)\n\t}\n\n\tattnOutput, err := l.attention.Forward(ctx, normInput, normInput, normInput, attentionMask)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n\t}\n\n\t// Residual connection\n\tresidual1 := t.add(input, attnOutput)\n\n\t// Pre-norm + feed-forward\n\tnormResidual, err := l.layernorm2.Forward(residual1)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"post-norm error: %w\", err)\n\t}\n\n\tffOutput, err := l.feedForward.Forward(ctx, normResidual)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"feed-forward error: %w\", err)\n\t}\n\n\t// Residual connection\n\toutput := t.add(residual1, ffOutput)\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 215,
          "code_snippet": "   210 | \tif err != nil {\n   211 | \t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n   212 | \t}\n   213 | \n   214 | \t// Residual connection\nâ†’  215 | \tresidual1 := t.add(input, attnOutput)\n   216 | \n   217 | \t// Pre-norm + feed-forward\n   218 | \tnormResidual, err := l.layernorm2.Forward(residual1)\n   219 | \tif err != nil {\n   220 | \t\treturn nil, fmt.Errorf(\"post-norm error: %w\", err)\n",
          "full_function": "func (l *TransformerLayer) Forward(ctx context.Context, input *Tensor, attentionMask *Tensor) (*Tensor, error) {\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\t// Pre-norm + attention\n\tnormInput, err := l.layernorm1.Forward(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"pre-norm error: %w\", err)\n\t}\n\n\tattnOutput, err := l.attention.Forward(ctx, normInput, normInput, normInput, attentionMask)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n\t}\n\n\t// Residual connection\n\tresidual1 := t.add(input, attnOutput)\n\n\t// Pre-norm + feed-forward\n\tnormResidual, err := l.layernorm2.Forward(residual1)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"post-norm error: %w\", err)\n\t}\n\n\tffOutput, err := l.feedForward.Forward(ctx, normResidual)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"feed-forward error: %w\", err)\n\t}\n\n\t// Residual connection\n\toutput := t.add(residual1, ffOutput)\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 249,
          "code_snippet": "   244 | // Forward performs layer normalization\n   245 | func (ln *LayerNorm) Forward(input *Tensor) (*Tensor, error) {\n   246 | \t// Simplified layer norm implementation\n   247 | \tmean := t.mean(input, -1, true)\n   248 | \tvariance := t.variance(input, -1, true)\nâ†’  249 | \tnormalized := t.div(t.sub(input, mean), t.sqrt(t.add(variance, ln.eps)))\n   250 | \n   251 | \t// Scale and shift\n   252 | \toutput := t.mul(normalized, ln.weight)\n   253 | \toutput = t.add(output, ln.bias)\n   254 | \n",
          "full_function": "func (ln *LayerNorm) Forward(input *Tensor) (*Tensor, error) {\n\t// Simplified layer norm implementation\n\tmean := t.mean(input, -1, true)\n\tvariance := t.variance(input, -1, true)\n\tnormalized := t.div(t.sub(input, mean), t.sqrt(t.add(variance, ln.eps)))\n\n\t// Scale and shift\n\toutput := t.mul(normalized, ln.weight)\n\toutput = t.add(output, ln.bias)\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\positional_encoding.go",
          "line_number": 6,
          "code_snippet": "     1 | // Package transformer implements positional encoding for GLM-4.6\n     2 | package transformer\n     3 | \n     4 | import (\n     5 | \t\"context\"\nâ†’    6 | \t\"fmt\"\n     7 | \t\"math\"\n     8 | \t\"sync\"\n     9 | \t\"time\"\n    10 | \n    11 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\n",
          "full_function": "\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\n\t\"go.uber.org/zap\"\n)\n\n// PositionalEncodingType represents different positional encoding approaches\ntype PositionalEncodingType string\n\nconst (\n\tPosEncodingTypeSinusoidal PositionalEncodingType = \"sinusoidal\"\n\tPosEncodingTypeLearned    PositionalEncodingType = \"learned\"\n\tPosEncodingTypeRelative   PositionalEncodingType = \"relative\"\n\tPosEncodingTypeRotary     PositionalEncodingType = \"rotary\"\n\tPosEncodingTypeALiBi      PositionalEncodingType = \"alibi\"\n\tPosEncodingTypeXPos       PositionalEncodingType = \"xpos\"\n)\n\n// PositionalEncodingConfig represents positional encoding configuration\ntype PositionalEncodingConfig struct {\n\tType        PositionalEncodingType `json:\"type\"`\n\tMaxSeqLen   int                    `json:\"max_seq_len\"`\n\tHiddenSize  int                    `json:\"hidden_size\"`\n\tHeadDim     int                    `json:\"head_dim,omitempty\"`\n\tBase        float64                `json:\"base\"`\n\tScale       bool                   `json:\"scale\"`\n\tNormalize   bool                   `json:\"normalize\"`\n\tConcatenate bool                   `json:\"concatenate\"`\n\tRotateHalf  bool                   `json:\"rotate_half\"`\n\tUseRoPE     bool                   `json:\"use_rope\"`\n\tUseXPos     bool                   `json:\"use_xpos\"`\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "math",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\compute\\serverless\\cloud_functions.go",
          "line_number": 14,
          "code_snippet": "     9 | type CloudFunctions interface {\r\n    10 | \t// Invoke invokes a cloud function\r\n    11 | \tInvoke(ctx context.Context, functionName string, payload []byte) ([]byte, error)\r\n    12 | \r\n    13 | \t// CreateFunction creates a cloud function\r\nâ†’   14 | \tCreateFunction(ctx context.Context, config *FunctionConfig) error\r\n    15 | \r\n    16 | \t// DeleteFunction deletes a cloud function\r\n    17 | \tDeleteFunction(ctx context.Context, functionName string) error\r\n    18 | }\r\n    19 | \n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "serverless",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\messaging\\pubsub\\pubsub_client.go",
          "line_number": 9,
          "code_snippet": "     4 | import (\r\n     5 | \t\"context\"\r\n     6 | )\r\n     7 | \r\n     8 | // PubSubClient provides generic pub/sub interface\r\nâ†’    9 | type PubSubClient interface {\r\n    10 | \t// Publish publishes a message to a topic\r\n    11 | \tPublish(ctx context.Context, topic string, message []byte) error\r\n    12 | \r\n    13 | \t// Subscribe subscribes to a topic\r\n    14 | \tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n",
          "full_function": "type PubSubClient interface {\r\n\t// Publish publishes a message to a topic\r\n\tPublish(ctx context.Context, topic string, message []byte) error\r\n\r\n\t// Subscribe subscribes to a topic\r\n\tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n\r\n\t// Close closes the client connection\r\n\tClose() error\r\n}\r",
          "symbol_name": "",
          "package_name": "pubsub",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\infrastructure\\messaging\\pubsub\\nats_pubsub.go",
          "line_number": 9,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\messaging\\streaming\\nats_jetstream.go",
          "line_number": 178,
          "code_snippet": "   173 | \t\tRetention: config.Retention,\r\n   174 | \t}\r\n   175 | \r\n   176 | \t_, err := c.js.AddStream(streamConfig)\r\n   177 | \tif err != nil {\r\nâ†’  178 | \t\tif err == nats.ErrStreamNameExist {\r\n   179 | \t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", config.Name))\r\n   180 | \t\t\treturn nil\r\n   181 | \t\t}\r\n   182 | \t\treturn fmt.Errorf(\"failed to create stream %s: %w\", config.Name, err)\r\n   183 | \t}\r\n",
          "full_function": "func (c *natsJetStreamClient) CreateStream(ctx context.Context, config *StreamConfig) error {\r\n\tstreamConfig := \u0026nats.StreamConfig{\r\n\t\tName:      config.Name,\r\n\t\tSubjects:  config.Subjects,\r\n\t\tReplicas:  config.Replicas,\r\n\t\tMaxAge:    config.MaxAge,\r\n\t\tMaxBytes:  config.MaxBytes,\r\n\t\tMaxMsgs:   config.MaxMsgs,\r\n\t\tRetention: config.Retention,\r\n\t}\r\n\r\n\t_, err := c.js.AddStream(streamConfig)\r\n\tif err != nil {\r\n\t\tif err == nats.ErrStreamNameExist {\r\n\t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", config.Name))\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\treturn fmt.Errorf(\"failed to create stream %s: %w\", config.Name, err)\r\n\t}\r\n\r\n\tlogger.Info(\"Created stream\",\r\n\t\tzap.String(\"stream\", config.Name),\r\n\t\tzap.Strings(\"subjects\", config.Subjects),\r\n\t)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "streaming",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "time",
            "github.com/nats-io/nats.go",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go",
          "line_number": 87,
          "code_snippet": "    82 | \t\tSELECT id, name, description, documents, embeddings, version, created_at, updated_at\r\n    83 | \t\tFROM knowledge\r\n    84 | \t\tWHERE id = $1\r\n    85 | \t`\r\n    86 | \r\nâ†’   87 | \tvar knowledge entities.Knowledge\r\n    88 | \tvar documentsJSON, embeddingsJSON []byte\r\n    89 | \tvar name, description string\r\n    90 | \tvar version int\r\n    91 | \tvar createdAt, updatedAt time.Time\r\n    92 | \r\n",
          "full_function": "\tvar knowledge entities.Knowledge\r\n\tvar documentsJSON, embeddingsJSON []byte\r\n\tvar name, description string\r\n\tvar version int\r\n\tvar createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026id,\r\n\t\t\u0026name,\r\n\t\t\u0026description,\r\n\t\t\u0026documentsJSON,\r\n\t\t\u0026embeddingsJSON,\r\n\t\t\u0026version,\r\n\t\t\u0026createdAt,\r\n\t\t\u0026updatedAt,\r\n\t)\r\n\r\n\tif err == sql.ErrNoRows {\r\n\t\treturn nil, fmt.Errorf(\"Knowledge not found: %s\", id)\r\n\t}\r",
          "symbol_name": "",
          "package_name": "relational",
          "dependencies": [
            "context",
            "database/sql",
            "encoding/json",
            "fmt",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/entities",
            "github.com/vertikon/mcp-core-inventory/internal/domain/repositories",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go",
          "line_number": 204,
          "code_snippet": "   199 | \tknowledge, err := entities.NewKnowledge(name, description)\r\n   200 | \tif err != nil {\r\n   201 | \t\treturn nil, fmt.Errorf(\"failed to create Knowledge entity: %w\", err)\r\n   202 | \t}\r\n   203 | \r\nâ†’  204 | \treturn \u0026knowledge, nil\r\n   205 | }\r\n   206 | \r\n   207 | // List lists all Knowledge entities with optional filters\r\n   208 | func (r *PostgresKnowledgeRepository) List(ctx context.Context, filters *repositories.KnowledgeFilters) ([]*entities.Knowledge, error) {\r\n   209 | \tquery := \"SELECT id, name, description, documents, embeddings, version, created_at, updated_at FROM knowledge WHERE 1=1\"\r\n",
          "full_function": "\treturn \u0026knowledge, nil\r\n}\r\n\r\n// List lists all Knowledge entities with optional filters\r\nfunc (r *PostgresKnowledgeRepository) List(ctx context.Context, filters *repositories.KnowledgeFilters) ([]*entities.Knowledge, error) {\r\n\tquery := \"SELECT id, name, description, documents, embeddings, version, created_at, updated_at FROM knowledge WHERE 1=1\"\r\n\targs := []interface{}{}\r",
          "symbol_name": "",
          "package_name": "relational",
          "dependencies": [
            "context",
            "database/sql",
            "encoding/json",
            "fmt",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/entities",
            "github.com/vertikon/mcp-core-inventory/internal/domain/repositories",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\root.go",
          "line_number": 42,
          "code_snippet": "    37 | func init() {\r\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n    40 | \t\r\n    41 | \t// Add subcommand groups\r\nâ†’   42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n    43 | \trootCmd.AddCommand(ci.CICmd)\r\n    44 | }\r\n    45 | \r\n    46 | // GetRootCmd returns the root command (for testing)\r\n    47 | func GetRootCmd() *cobra.Command {\r\n",
          "full_function": "func init() {\r\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n\t\r\n\t// Add subcommand groups\r\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n\trootCmd.AddCommand(ci.CICmd)\r\n}\r",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\root.go",
          "line_number": 43,
          "code_snippet": "    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n    40 | \t\r\n    41 | \t// Add subcommand groups\r\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\r\nâ†’   43 | \trootCmd.AddCommand(ci.CICmd)\r\n    44 | }\r\n    45 | \r\n    46 | // GetRootCmd returns the root command (for testing)\r\n    47 | func GetRootCmd() *cobra.Command {\r\n    48 | \treturn rootCmd\r\n",
          "full_function": "func init() {\r\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n\t\r\n\t// Add subcommand groups\r\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n\trootCmd.AddCommand(ci.CICmd)\r\n}\r",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\tools\\deployers\\hybrid_deployer.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"fmt\"\r\n     6 | \t\"os\"\r\n     7 | \t\"path/filepath\"\r\n     8 | \t\"time\"\r\n     9 | \r\nâ†’   10 | \t\"github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes\"\r\n    11 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n    12 | \t\"go.uber.org/zap\"\r\n    13 | )\r\n    14 | \r\n    15 | // HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\r\n",
          "full_function": "\t\"github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes\"\r\n\t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n\t\"go.uber.org/zap\"\r\n)\r\n\r\n// HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\r\n// This deployer intelligently selects the best deployment strategy based on workload characteristics\r\ntype HybridDeployer struct {\r\n\tdockerDeployer     *DockerDeployer\r\n\tkubernetesDeployer *KubernetesDeployer\r\n\tserverlessDeployer *ServerlessDeployer\r\n\tlogger             *zap.Logger\r\n}\r",
          "symbol_name": "",
          "package_name": "deployers",
          "dependencies": [
            "context",
            "fmt",
            "os",
            "path/filepath",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 56,
          "code_snippet": "    51 | \t// Verify verifies a signature using RSA\r\n    52 | \tVerify(data, signature []byte, publicKey *rsa.PublicKey) bool\r\n    53 | }\r\n    54 | \r\n    55 | // Manager implements EncryptionManager\r\nâ†’   56 | type Manager struct {\r\n    57 | \tkeyManager KeyManager\r\n    58 | \tlogger     *zap.Logger\r\n    59 | }\r\n    60 | \r\n    61 | // NewEncryptionManager creates a new EncryptionManager\r\n",
          "full_function": "type Manager struct {\r\n\tkeyManager KeyManager\r\n\tlogger     *zap.Logger\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\security\\encryption\\certificate_manager.go",
          "line_number": 42,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 64,
          "code_snippet": "    59 | }\r\n    60 | \r\n    61 | // NewEncryptionManager creates a new EncryptionManager\r\n    62 | func NewEncryptionManager(keyManager KeyManager) EncryptionManager {\r\n    63 | \treturn \u0026Manager{\r\nâ†’   64 | \t\tkeyManager: keyManager,\r\n    65 | \t\tlogger:     logger.WithContext(nil),\r\n    66 | \t}\r\n    67 | }\r\n    68 | \r\n    69 | // Encrypt encrypts data using AES-256-GCM with default key\r\n",
          "full_function": "func NewEncryptionManager(keyManager KeyManager) EncryptionManager {\r\n\treturn \u0026Manager{\r\n\t\tkeyManager: keyManager,\r\n\t\tlogger:     logger.WithContext(nil),\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 71,
          "code_snippet": "    66 | \t}\r\n    67 | }\r\n    68 | \r\n    69 | // Encrypt encrypts data using AES-256-GCM with default key\r\n    70 | func (m *Manager) Encrypt(plaintext []byte) ([]byte, error) {\r\nâ†’   71 | \tkey, err := m.keyManager.GetEncryptionKey()\r\n    72 | \tif err != nil {\r\n    73 | \t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n    74 | \t\treturn nil, err\r\n    75 | \t}\r\n    76 | \treturn m.EncryptWithKey(plaintext, key)\r\n",
          "full_function": "func (m *Manager) Encrypt(plaintext []byte) ([]byte, error) {\r\n\tkey, err := m.keyManager.GetEncryptionKey()\r\n\tif err != nil {\r\n\t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n\t\treturn nil, err\r\n\t}\r\n\treturn m.EncryptWithKey(plaintext, key)\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 81,
          "code_snippet": "    76 | \treturn m.EncryptWithKey(plaintext, key)\r\n    77 | }\r\n    78 | \r\n    79 | // Decrypt decrypts data using AES-256-GCM with default key\r\n    80 | func (m *Manager) Decrypt(ciphertext []byte) ([]byte, error) {\r\nâ†’   81 | \tkey, err := m.keyManager.GetEncryptionKey()\r\n    82 | \tif err != nil {\r\n    83 | \t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n    84 | \t\treturn nil, err\r\n    85 | \t}\r\n    86 | \treturn m.DecryptWithKey(ciphertext, key)\r\n",
          "full_function": "func (m *Manager) Decrypt(ciphertext []byte) ([]byte, error) {\r\n\tkey, err := m.keyManager.GetEncryptionKey()\r\n\tif err != nil {\r\n\t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n\t\treturn nil, err\r\n\t}\r\n\treturn m.DecryptWithKey(ciphertext, key)\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 52,
          "code_snippet": "    47 | \t// LoadKeyFromFile loads key from file\r\n    48 | \tLoadKeyFromFile(filePath string) error\r\n    49 | }\r\n    50 | \r\n    51 | // Manager implements KeyManager\r\nâ†’   52 | type Manager struct {\r\n    53 | \tencryptionKey []byte\r\n    54 | \tkeyVersion    string\r\n    55 | \trsaPrivateKey *rsa.PrivateKey\r\n    56 | \trsaPublicKey  *rsa.PublicKey\r\n    57 | \trotationTTL  time.Duration\r\n",
          "full_function": "type Manager struct {\r\n\tencryptionKey []byte\r\n\tkeyVersion    string\r\n\trsaPrivateKey *rsa.PrivateKey\r\n\trsaPublicKey  *rsa.PublicKey\r\n\trotationTTL  time.Duration\r\n\tlastRotation  time.Time\r\n\tmu            sync.RWMutex\r\n\tlogger        *zap.Logger\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\security\\encryption\\certificate_manager.go",
          "line_number": 42,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 72,
          "code_snippet": "    67 | }\r\n    68 | \r\n    69 | // NewKeyManager creates a new KeyManager\r\n    70 | func NewKeyManager(config KeyManagerConfig) KeyManager {\r\n    71 | \tkm := \u0026Manager{\r\nâ†’   72 | \t\tkeyVersion:   \"v1\",\r\n    73 | \t\trotationTTL: config.RotationTTL,\r\n    74 | \t\tlogger:       logger.WithContext(nil),\r\n    75 | \t}\r\n    76 | \r\n    77 | \t// Generate initial encryption key\r\n",
          "full_function": "func NewKeyManager(config KeyManagerConfig) KeyManager {\r\n\tkm := \u0026Manager{\r\n\t\tkeyVersion:   \"v1\",\r\n\t\trotationTTL: config.RotationTTL,\r\n\t\tlogger:       logger.WithContext(nil),\r\n\t}\r\n\r\n\t// Generate initial encryption key\r\n\tkey := make([]byte, 32) // AES-256\r\n\tif _, err := rand.Read(key); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate encryption key\", zap.Error(err))\r\n\t} else {\r\n\t\tkm.encryptionKey = key\r\n\t}\r\n\r\n\t// Generate RSA key pair\r\n\tif err := km.generateRSAKeys(config.KeySize); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate RSA keys\", zap.Error(err))\r\n\t}\r\n\r\n\tkm.lastRotation = time.Now()\r\n\treturn km\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 82,
          "code_snippet": "    77 | \t// Generate initial encryption key\r\n    78 | \tkey := make([]byte, 32) // AES-256\r\n    79 | \tif _, err := rand.Read(key); err != nil {\r\n    80 | \t\tkm.logger.Error(\"Failed to generate encryption key\", zap.Error(err))\r\n    81 | \t} else {\r\nâ†’   82 | \t\tkm.encryptionKey = key\r\n    83 | \t}\r\n    84 | \r\n    85 | \t// Generate RSA key pair\r\n    86 | \tif err := km.generateRSAKeys(config.KeySize); err != nil {\r\n    87 | \t\tkm.logger.Error(\"Failed to generate RSA keys\", zap.Error(err))\r\n",
          "full_function": "func NewKeyManager(config KeyManagerConfig) KeyManager {\r\n\tkm := \u0026Manager{\r\n\t\tkeyVersion:   \"v1\",\r\n\t\trotationTTL: config.RotationTTL,\r\n\t\tlogger:       logger.WithContext(nil),\r\n\t}\r\n\r\n\t// Generate initial encryption key\r\n\tkey := make([]byte, 32) // AES-256\r\n\tif _, err := rand.Read(key); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate encryption key\", zap.Error(err))\r\n\t} else {\r\n\t\tkm.encryptionKey = key\r\n\t}\r\n\r\n\t// Generate RSA key pair\r\n\tif err := km.generateRSAKeys(config.KeySize); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate RSA keys\", zap.Error(err))\r\n\t}\r\n\r\n\tkm.lastRotation = time.Now()\r\n\treturn km\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 96,
          "code_snippet": "    91 | \treturn km\r\n    92 | }\r\n    93 | \r\n    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\nâ†’   96 | \tm.mu.RLock()\r\n    97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\n    99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 97,
          "code_snippet": "    92 | }\r\n    93 | \r\n    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n    96 | \tm.mu.RLock()\r\nâ†’   97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\n    99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n   102 | \r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 99,
          "code_snippet": "    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n    96 | \tm.mu.RLock()\r\n    97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\nâ†’   99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n   102 | \r\n   103 | \t// Check if rotation is needed\r\n   104 | \tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 99,
          "code_snippet": "    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n    96 | \tm.mu.RLock()\r\n    97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\nâ†’   99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n   102 | \r\n   103 | \t// Check if rotation is needed\r\n   104 | \tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 162,
          "code_snippet": "   157 | \tcm.stats.TotalInvalidations++\r\n   158 | \tcm.stats.InvalidationsByReason[reason]++\r\n   159 | \tcm.mu.Unlock()\r\n   160 | \r\n   161 | \t// Delete from cache\r\nâ†’  162 | \tcm.cache.Delete(key)\r\n   163 | \r\n   164 | \t// Create invalidation event\r\n   165 | \tevent := \u0026InvalidationEvent{\r\n   166 | \t\tKey:       key,\r\n   167 | \t\tReason:    reason,\r\n",
          "full_function": "func (cm *CoherencyManagerImpl) Invalidate(ctx context.Context, key string, reason string) error {\r\n\tstart := time.Now()\r\n\r\n\tcm.mu.Lock()\r\n\tcm.stats.TotalInvalidations++\r\n\tcm.stats.InvalidationsByReason[reason]++\r\n\tcm.mu.Unlock()\r\n\r\n\t// Delete from cache\r\n\tcm.cache.Delete(key)\r\n\r\n\t// Create invalidation event\r\n\tevent := \u0026InvalidationEvent{\r\n\t\tKey:       key,\r\n\t\tReason:    reason,\r\n\t\tTimestamp: time.Now(),\r\n\t\tSource:    \"coherency_manager\",\r\n\t}\r\n\r\n\t// Send to invalidation channel\r\n\tselect {\r\n\tcase cm.invalidationCh \u003c- event:\r\n\tdefault:\r\n\t\tcm.logger.Warn(\"Invalidation channel full, dropping event\",\r\n\t\t\tzap.String(\"key\", key))\r\n\t}\r\n\r\n\tcm.mu.Lock()\r\n\tcm.stats.AverageInvalidationTime = time.Since(start)\r\n\tlastTime := time.Now()\r\n\tcm.stats.LastInvalidation = \u0026lastTime\r\n\tcm.mu.Unlock()\r\n\r\n\tcm.logger.Debug(\"Cache key invalidated\",\r\n\t\tzap.String(\"key\", key),\r\n\t\tzap.String(\"reason\", reason))\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 217,
          "code_snippet": "   212 | }\r\n   213 | \r\n   214 | // Update updates a cache entry\r\n   215 | func (cm *CoherencyManagerImpl) Update(ctx context.Context, key string, value interface{}) error {\r\n   216 | \tcm.mu.Lock()\r\nâ†’  217 | \tcm.stats.TotalUpdates++\r\n   218 | \tcm.mu.Unlock()\r\n   219 | \r\n   220 | \t// Update cache based on strategy\r\n   221 | \tswitch cm.config.Strategy {\r\n   222 | \tcase CoherencyStrategyWriteThrough:\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 253,
          "code_snippet": "   248 | \t\tStrategy:             cm.config.Strategy,\r\n   249 | \t\tLevel:                cm.config.Level,\r\n   250 | \t\tIsCoherent:           true, // Simplified\r\n   251 | \t\tPendingInvalidations: len(cm.pendingInvalidations),\r\n   252 | \t\tTotalInvalidations:   cm.stats.TotalInvalidations,\r\nâ†’  253 | \t\tTotalUpdates:         cm.stats.TotalUpdates,\r\n   254 | \t}, nil\r\n   255 | }\r\n   256 | \r\n   257 | // GetInvalidationStats returns invalidation statistics\r\n   258 | func (cm *CoherencyManagerImpl) GetInvalidationStats(ctx context.Context) (*InvalidationStats, error) {\r\n",
          "full_function": "func (cm *CoherencyManagerImpl) GetCoherencyStatus(ctx context.Context) (*CoherencyStatus, error) {\r\n\tcm.mu.RLock()\r\n\tdefer cm.mu.RUnlock()\r\n\r\n\treturn \u0026CoherencyStatus{\r\n\t\tStrategy:             cm.config.Strategy,\r\n\t\tLevel:                cm.config.Level,\r\n\t\tIsCoherent:           true, // Simplified\r\n\t\tPendingInvalidations: len(cm.pendingInvalidations),\r\n\t\tTotalInvalidations:   cm.stats.TotalInvalidations,\r\n\t\tTotalUpdates:         cm.stats.TotalUpdates,\r\n\t}, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 342,
          "code_snippet": "   337 | \tcm.mu.Lock()\r\n   338 | \tcm.pendingInvalidations[event.Key] = event\r\n   339 | \tcm.mu.Unlock()\r\n   340 | \r\n   341 | \t// Process invalidation\r\nâ†’  342 | \tcm.cache.Delete(event.Key)\r\n   343 | \r\n   344 | \tcm.mu.Lock()\r\n   345 | \tdelete(cm.pendingInvalidations, event.Key)\r\n   346 | \tcm.mu.Unlock()\r\n   347 | \r\n",
          "full_function": "func (cm *CoherencyManagerImpl) processInvalidation(event *InvalidationEvent) {\r\n\tcm.mu.Lock()\r\n\tcm.pendingInvalidations[event.Key] = event\r\n\tcm.mu.Unlock()\r\n\r\n\t// Process invalidation\r\n\tcm.cache.Delete(event.Key)\r\n\r\n\tcm.mu.Lock()\r\n\tdelete(cm.pendingInvalidations, event.Key)\r\n\tcm.mu.Unlock()\r\n\r\n\tcm.logger.Debug(\"Invalidation processed\",\r\n\t\tzap.String(\"key\", event.Key),\r\n\t\tzap.String(\"reason\", event.Reason))\r\n}\r",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 236,
          "code_snippet": "   231 | \t// Compare vector clocks\r\n   232 | \tcomparison := r.compareVectorClocks(localVC, remoteVC)\r\n   233 | \t\r\n   234 | \tswitch comparison {\r\n   235 | \tcase \"local_greater\":\r\nâ†’  236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n   237 | \tcase \"remote_greater\":\r\n   238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n   239 | \tcase \"concurrent\":\r\n   240 | \t\t// Conflict detected, need merge\r\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\r\n\t// Extract vector clocks from metadata\r\n\tlocalVC := r.getVectorClock(conflict.LocalState)\r\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\r\n\t\r\n\t// Compare vector clocks\r\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\r\n\t\r\n\tswitch comparison {\r\n\tcase \"local_greater\":\r\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n\tcase \"remote_greater\":\r\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n\tcase \"concurrent\":\r\n\t\t// Conflict detected, need merge\r\n\t\treturn r.resolveCRDTMerge(conflict)\r\n\tdefault:\r\n\t\t// Same vector clock, use timestamp as tie-breaker\r\n\t\treturn r.resolveLastWriteWins(conflict)\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 238,
          "code_snippet": "   233 | \t\r\n   234 | \tswitch comparison {\r\n   235 | \tcase \"local_greater\":\r\n   236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n   237 | \tcase \"remote_greater\":\r\nâ†’  238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n   239 | \tcase \"concurrent\":\r\n   240 | \t\t// Conflict detected, need merge\r\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\r\n   242 | \tdefault:\r\n   243 | \t\t// Same vector clock, use timestamp as tie-breaker\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\r\n\t// Extract vector clocks from metadata\r\n\tlocalVC := r.getVectorClock(conflict.LocalState)\r\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\r\n\t\r\n\t// Compare vector clocks\r\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\r\n\t\r\n\tswitch comparison {\r\n\tcase \"local_greater\":\r\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n\tcase \"remote_greater\":\r\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n\tcase \"concurrent\":\r\n\t\t// Conflict detected, need merge\r\n\t\treturn r.resolveCRDTMerge(conflict)\r\n\tdefault:\r\n\t\t// Same vector clock, use timestamp as tie-breaker\r\n\t\treturn r.resolveLastWriteWins(conflict)\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 251,
          "code_snippet": "   246 | }\r\n   247 | \r\n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\r\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\r\nâ†’  251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\n   252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n   253 | \t\r\n   254 | \t// Ensure both states have timestamps\r\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n\t// CRDT LWW uses timestamps for conflict resolution\r\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n\t\r\n\t// Ensure both states have timestamps\r\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n\t\r\n\tif localTS.After(remoteTS) {\r\n\t\treturn \u0026VersionedState{\r\n\t\t\tKey:     conflict.Key,\r\n\t\t\tValue:   conflict.LocalState.Value,\r\n\t\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\t\tTTL:     conflict.LocalState.TTL,\r\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t\t}, nil\r\n\t}\r\n\t\r\n\treturn \u0026VersionedState{\r\n\t\tKey:     conflict.Key,\r\n\t\tValue:   conflict.RemoteState.Value,\r\n\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\tTTL:     conflict.RemoteState.TTL,\r\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t}, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 252,
          "code_snippet": "   247 | \r\n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\r\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\r\n   251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\nâ†’  252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n   253 | \t\r\n   254 | \t// Ensure both states have timestamps\r\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n   257 | \t\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n\t// CRDT LWW uses timestamps for conflict resolution\r\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n\t\r\n\t// Ensure both states have timestamps\r\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n\t\r\n\tif localTS.After(remoteTS) {\r\n\t\treturn \u0026VersionedState{\r\n\t\t\tKey:     conflict.Key,\r\n\t\t\tValue:   conflict.LocalState.Value,\r\n\t\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\t\tTTL:     conflict.LocalState.TTL,\r\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t\t}, nil\r\n\t}\r\n\t\r\n\treturn \u0026VersionedState{\r\n\t\tKey:     conflict.Key,\r\n\t\tValue:   conflict.RemoteState.Value,\r\n\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\tTTL:     conflict.RemoteState.TTL,\r\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t}, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 283,
          "code_snippet": "   278 | func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\r\n   279 | \t// For simple values, use last-write-wins\r\n   280 | \t// For complex values (maps, sets, counters), perform actual CRDT merge\r\n   281 | \t\r\n   282 | \t// Check if values are mergeable\r\nâ†’  283 | \tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\r\n   284 | \t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\r\n   285 | \t\tif err != nil {\r\n   286 | \t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\r\n   287 | \t\t\t\tzap.String(\"key\", conflict.Key),\r\n   288 | \t\t\t\tzap.Error(err))\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\r\n\t// For simple values, use last-write-wins\r\n\t// For complex values (maps, sets, counters), perform actual CRDT merge\r\n\t\r\n\t// Check if values are mergeable\r\n\tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\r\n\t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\r\n\t\tif err != nil {\r\n\t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\r\n\t\t\t\tzap.String(\"key\", conflict.Key),\r\n\t\t\t\tzap.Error(err))\r\n\t\t\treturn r.resolveCRDTLastWriterWins(conflict)\r\n\t\t}\r\n\t\t\r\n\t\treturn \u0026VersionedState{\r\n\t\t\tKey:     conflict.Key,\r\n\t\t\tValue:   mergedValue,\r\n\t\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\t\tTTL:     r.mergeTTL(conflict.LocalState.TTL, conflict.RemoteState.TTL),\r\n\t\t\tMeta:    r.createCRDTMergeMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta),\r\n\t\t}, nil\r\n\t}\r\n\t\r\n\t// Non-mergeable, fall back to LWW\r\n\treturn r.resolveCRDTLastWriterWins(conflict)\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 396,
          "code_snippet": "   391 | \treturn ts\r\n   392 | }\r\n   393 | \r\n   394 | func (r *ConflictResolverImpl) isMergeableValue(value interface{}) bool {\r\n   395 | \t// Check if value is a type that can be merged\r\nâ†’  396 | \tswitch v := value.(type) {\r\n   397 | \tcase map[string]interface{}:\r\n   398 | \t\treturn true\r\n   399 | \tcase []interface{}:\r\n   400 | \t\treturn true\r\n   401 | \tcase map[string]string:\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 415,
          "code_snippet": "   410 | func (r *ConflictResolverImpl) mergeValues(local, remote interface{}) (interface{}, error) {\r\n   411 | \t// Implement actual CRDT merge logic based on value type\r\n   412 | \tswitch l := local.(type) {\r\n   413 | \tcase map[string]interface{}:\r\n   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\r\nâ†’  415 | \t\t\treturn r.mergeMaps(l, r), nil\r\n   416 | \t\t}\r\n   417 | \tcase []interface{}:\r\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\r\n   419 | \t\t\treturn r.mergeArrays(l, r), nil\r\n   420 | \t\t}\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 419,
          "code_snippet": "   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\r\n   415 | \t\t\treturn r.mergeMaps(l, r), nil\r\n   416 | \t\t}\r\n   417 | \tcase []interface{}:\r\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\r\nâ†’  419 | \t\t\treturn r.mergeArrays(l, r), nil\r\n   420 | \t\t}\r\n   421 | \t}\r\n   422 | \t\r\n   423 | \t// Cannot merge, return error\r\n   424 | \treturn nil, fmt.Errorf(\"values are not mergeable\")\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 516,
          "code_snippet": "   511 | \t\r\n   512 | \t// Add CRDT-specific metadata\r\n   513 | \tmerged[\"crdt_strategy\"] = \"last-writer-wins\"\r\n   514 | \tmerged[\"local_timestamp\"] = localTS\r\n   515 | \tmerged[\"remote_timestamp\"] = remoteTS\r\nâ†’  516 | \tmerged[\"winner_timestamp\"] = max(localTS, remoteTS)\r\n   517 | \t\r\n   518 | \treturn merged\r\n   519 | }\r\n   520 | \r\n   521 | func (r *ConflictResolverImpl) createCRDTMergeMeta(local, remote map[string]interface{}) map[string]interface{} {\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 622,
          "code_snippet": "   617 | \t\treturn a\r\n   618 | \t}\r\n   619 | \treturn b\r\n   620 | }\r\n   621 | \r\nâ†’  622 | func max(a, b time.Time) time.Time {\r\n   623 | \tif a.After(b) {\r\n   624 | \t\treturn a\r\n   625 | \t}\r\n   626 | \treturn b\r\n   627 | }\n",
          "full_function": "func max(a, b time.Time) time.Time {\r\n\tif a.After(b) {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\state\\store\\conflict_resolver.go",
          "line_number": 615,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 516,
          "code_snippet": "   511 | \t\r\n   512 | \t// Add CRDT-specific metadata\r\n   513 | \tmerged[\"crdt_strategy\"] = \"last-writer-wins\"\r\n   514 | \tmerged[\"local_timestamp\"] = localTS\r\n   515 | \tmerged[\"remote_timestamp\"] = remoteTS\r\nâ†’  516 | \tmerged[\"winner_timestamp\"] = max(localTS, remoteTS)\r\n   517 | \t\r\n   518 | \treturn merged\r\n   519 | }\r\n   520 | \r\n   521 | func (r *ConflictResolverImpl) createCRDTMergeMeta(local, remote map[string]interface{}) map[string]interface{} {\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_replay.go",
          "line_number": 249,
          "code_snippet": "   244 | }\r\n   245 | \r\n   246 | // ReplayFromSnapshot replays events from a snapshot version\r\n   247 | func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\r\n   248 | \t// Get snapshot\r\nâ†’  249 | \tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\r\n   250 | \tif err != nil {\r\n   251 | \t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\r\n   252 | \t}\r\n   253 | \r\n   254 | \t// Get events after snapshot version\r\n",
          "full_function": "func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\r\n\t// Get snapshot\r\n\tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\r\n\t}\r\n\r\n\t// Get events after snapshot version\r\n\tevents, err := er.store.GetEvents(ctx, aggregateID, snapshotVersion+1, 0)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to get events after snapshot: %w\", err)\r\n\t}\r\n\r\n\tif len(events) == 0 {\r\n\t\treturn \u0026ReplayProgress{\r\n\t\t\tTotalEvents:     0,\r\n\t\t\tProcessedEvents: 0,\r\n\t\t\tIsComplete:      true,\r\n\t\t}, nil\r\n\t}\r\n\r\n\tstartTime := time.Now()\r\n\tprogress := \u0026ReplayProgress{\r\n\t\tTotalEvents:    int64(len(events)),\r\n\t\tStartTime:      startTime,\r\n\t\tCurrentVersion: snapshotVersion + 1,\r\n\t}\r\n\r\n\terr = er.replaySequential(ctx, events, handler, progress)\r\n\tprogress.ElapsedTime = time.Since(startTime)\r\n\tprogress.IsComplete = true\r\n\r\n\tif err != nil {\r\n\t\tprogress.LastError = err.Error()\r\n\t\treturn progress, err\r\n\t}\r\n\r\n\treturn progress, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_replay.go",
          "line_number": 290,
          "code_snippet": "   285 | }\r\n   286 | \r\n   287 | // ReplayToState replays events to rebuild state at a specific version\r\n   288 | func (er *EventReplayImpl) ReplayToState(ctx context.Context, aggregateID string, targetVersion int64, handler ReplayHandler) (interface{}, error) {\r\n   289 | \t// Get all events up to target version\r\nâ†’  290 | \tevents, err := er.store.GetEvents(ctx, aggregateID, 1, targetVersion)\r\n   291 | \tif err != nil {\r\n   292 | \t\treturn nil, fmt.Errorf(\"failed to get events: %w\", err)\r\n   293 | \t}\r\n   294 | \r\n   295 | \t// Replay events\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_versioning.go",
          "line_number": 140,
          "code_snippet": "   135 | \tif exists {\r\n   136 | \t\t// Return copy\r\n   137 | \t\tcopy := *versionInfo\r\n   138 | \t\tif versionInfo.VersionHistory != nil {\r\n   139 | \t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\r\nâ†’  140 | \t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\r\n   141 | \t\t}\r\n   142 | \t\treturn \u0026copy, nil\r\n   143 | \t}\r\n   144 | \t\r\n   145 | \t// Load from event store\r\n",
          "full_function": "func (ev *EventVersioningImpl) GetVersion(ctx context.Context, aggregateID string) (*VersionInfo, error) {\r\n\tev.mu.RLock()\r\n\tversionInfo, exists := ev.versions[aggregateID]\r\n\tev.mu.RUnlock()\r\n\t\r\n\tif exists {\r\n\t\t// Return copy\r\n\t\tcopy := *versionInfo\r\n\t\tif versionInfo.VersionHistory != nil {\r\n\t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\r\n\t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\r\n\t\t}\r\n\t\treturn \u0026copy, nil\r\n\t}\r\n\t\r\n\t// Load from event store\r\n\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to get aggregate info: %w\", err)\r\n\t}\r\n\t\r\n\tversionInfo = \u0026VersionInfo{\r\n\t\tAggregateID:    aggregateID,\r\n\t\tAggregateType:  aggregateInfo.AggregateType,\r\n\t\tCurrentVersion: aggregateInfo.Version,\r\n\t\tMetadata:       make(map[string]interface{}),\r\n\t}\r\n\t\r\n\tif ev.config.EnableHistory {\r\n\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\r\n\t}\r\n\t\r\n\tev.mu.Lock()\r\n\tev.versions[aggregateID] = versionInfo\r\n\tev.mu.Unlock()\r\n\t\r\n\treturn versionInfo, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_versioning.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\tif ev.config.ConflictResolution == \"reject\" {\r\n   212 | \t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\r\n   213 | \t\t}\r\n   214 | \t\t\r\n   215 | \t\t// Resolve conflict\r\nâ†’  216 | \t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\r\n   217 | \t\tif err != nil {\r\n   218 | \t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\r\n   219 | \t\t}\r\n   220 | \t\t\r\n   221 | \t\tnewVersion = resolvedVersion\r\n",
          "full_function": "func (ev *EventVersioningImpl) IncrementVersion(ctx context.Context, aggregateID string, event *Event) (int64, error) {\r\n\tev.mu.Lock()\r\n\tdefer ev.mu.Unlock()\r\n\t\r\n\tversionInfo, exists := ev.versions[aggregateID]\r\n\tif !exists {\r\n\t\t// Load from store\r\n\t\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\r\n\t\tif err != nil {\r\n\t\t\treturn 0, fmt.Errorf(\"failed to get aggregate info: %w\", err)\r\n\t\t}\r\n\t\t\r\n\t\tversionInfo = \u0026VersionInfo{\r\n\t\t\tAggregateID:    aggregateID,\r\n\t\t\tAggregateType:  aggregateInfo.AggregateType,\r\n\t\t\tCurrentVersion: aggregateInfo.Version,\r\n\t\t\tMetadata:       make(map[string]interface{}),\r\n\t\t}\r\n\t\t\r\n\t\tif ev.config.EnableHistory {\r\n\t\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\r\n\t\t}\r\n\t\t\r\n\t\tev.versions[aggregateID] = versionInfo\r\n\t}\r\n\t\r\n\t// Increment version\r\n\tnewVersion := versionInfo.CurrentVersion + 1\r\n\t\r\n\t// Validate version continuity\r\n\tif event.Version != 0 \u0026\u0026 event.Version != newVersion {\r\n\t\tconflict := \u0026VersionConflict{\r\n\t\t\tAggregateID:     aggregateID,\r\n\t\t\tExpectedVersion: newVersion,\r\n\t\t\tActualVersion:   event.Version,\r\n\t\t\tConflictTime:    time.Now(),\r\n\t\t}\r\n\t\t\r\n\t\tev.stats.TotalConflicts++\r\n\t\tev.conflicts[aggregateID] = append(ev.conflicts[aggregateID], conflict)\r\n\t\t\r\n\t\tif ev.config.ConflictResolution == \"reject\" {\r\n\t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\r\n\t\t}\r\n\t\t\r\n\t\t// Resolve conflict\r\n\t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\r\n\t\tif err != nil {\r\n\t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\r\n\t\t}\r\n\t\t\r\n\t\tnewVersion = resolvedVersion\r\n\t\tconflict.Resolution = fmt.Sprintf(\"resolved to %d\", resolvedVersion)\r\n\t\tev.stats.ResolvedConflicts++\r\n\t}\r\n\t\r\n\t// Update version info\r\n\tversionInfo.CurrentVersion = newVersion\r\n\tversionInfo.LastEventID = event.ID\r\n\tversionInfo.LastEventTime = event.Timestamp\r\n\t\r\n\t// Add to history\r\n\tif ev.config.EnableHistory {\r\n\t\tentry := VersionHistoryEntry{\r\n\t\t\tVersion:   newVersion,\r\n\t\t\tEventID:   event.ID,\r\n\t\t\tTimestamp: event.Timestamp,\r\n\t\t\tEventType: event.Type,\r\n\t\t}\r\n\t\t\r\n\t\tversionInfo.VersionHistory = append(versionInfo.VersionHistory, entry)\r\n\t\t\r\n\t\t// Trim history if needed\r\n\t\tif len(versionInfo.VersionHistory) \u003e ev.config.HistoryRetention {\r\n\t\t\tversionInfo.VersionHistory = versionInfo.VersionHistory[len(versionInfo.VersionHistory)-ev.config.HistoryRetention:]\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Update statistics\r\n\tev.stats.TotalVersions++\r\n\tev.stats.VersionDistribution[newVersion]++\r\n\t\r\n\tev.logger.Debug(\"Version incremented\",\r\n\t\tzap.String(\"aggregate_id\", aggregateID),\r\n\t\tzap.Int64(\"version\", newVersion))\r\n\t\r\n\treturn newVersion, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 36,
        "affected_lines": 108,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "1-2 horas",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Nil Pointer Check",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "1 potencial(is) nil pointer issue(s)",
      "suggestion": "Adicione nil checks",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "tools": null,
        "executable_steps": null,
        "estimated_time": "",
        "confidence": 0
      },
      "examples": [
        "multi_level_cache.go:180"
      ],
      "code_contexts": null,
      "impact_analysis": {
        "severity": "",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "",
        "priority": 0,
        "risk_level": "",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    }
  ],
  "high": null,
  "medium": null,
  "low": [
    {
      "type": "Linter limpo",
      "severity": "low",
      "location": "multiplos arquivos",
      "description": "âœ— FAIL: 71 issues crÃ­ticos, 0 warnings",
      "suggestion": "Corrija os issues FAIL primeiro, depois warnings",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": [
          {
            "tool_name": "golangci-lint",
            "install_command": "go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
            "diagnose_command": "golangci-lint run",
            "fix_command": "# NAO use --fix automaticamente, revise cada issue",
            "config_required": true,
            "config_template": ".golangci.yml com linters selecionados",
            "documentation": "https://golangci-lint.run/",
            "alternative_tools": null
          },
          {
            "tool_name": "staticcheck",
            "install_command": "go install honnef.co/go/tools/cmd/staticcheck@latest",
            "diagnose_command": "staticcheck ./...",
            "fix_command": "# Manual - staticcheck nao tem auto-fix",
            "config_required": false,
            "config_template": "",
            "documentation": "https://staticcheck.io/",
            "alternative_tools": null
          },
          {
            "tool_name": "gosec",
            "install_command": "go install github.com/securego/gosec/v2/cmd/gosec@latest",
            "diagnose_command": "gosec ./...",
            "fix_command": "# Manual - corrija issues de seguranca",
            "config_required": false,
            "config_template": "",
            "documentation": "https://github.com/securego/gosec",
            "alternative_tools": null
          }
        ],
        "executable_steps": null,
        "estimated_time": "2h22m",
        "confidence": 0
      },
      "examples": [
        "ðŸ“¦ MÃ³dulos analisados: 1",
        "ðŸ“„ Linter Report v2: JSON + SARIF gerados",
        "",
        "ðŸ“Š Resumo por ferramenta (todos os mÃ³dulos):",
        "  â€¢ golangci-lint: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ govet: ð„‚ 71 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ staticcheck: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "",
        "ðŸ” Top issues prioritÃ¡rios (FAIL):",
        "  1. [govet] internal/core/scheduler/scheduler.go:62 - undefined: nats.ErrStreamNameExist (govet)",
        "  2. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.id undefined (type ledger.Reservation has no field or method id) (govet)",
        "  3. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.ledgerID undefined (type ledger.Reservation has no field or method... (govet)",
        "  4. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.sku undefined (type ledger.Reservation has no field or method sku) (govet)",
        "  5. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.location undefined (type ledger.Reservation has no field or method... (govet)",
        "  6. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.quantity undefined (type ledger.Reservation has no field or method... (govet)",
        "  7. [govet] internal/adapters/postgres/ledger_repository.go:104 - res.idempotencyKey undefined (type ledger.Reservation has no field or ... (govet)",
        "  8. [govet] internal/adapters/postgres/ledger_repository.go:114 - res.status undefined (type ledger.Reservation has no field or method s... (govet)",
        "  9. [govet] internal/adapters/postgres/ledger_repository.go:115 - res.expiresAt undefined (type ledger.Reservation has no field or metho... (govet)",
        "  10. [govet] internal/adapters/postgres/ledger_repository.go:116 - res.createdAt undefined (type ledger.Reservation has no field or metho... (govet)"
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": null,
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 71,
        "affected_lines": 71,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "2h22m",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [
        "performance",
        "memory-optimization"
      ],
      "error_breakdown": {
        "govet": 71
      },
      "top_files": [
        "internal/adapters/postgres/ledger_repository.go (11)",
        "internal/security/encryption/key_manager.go (7)",
        "internal/mcp/generators/tinygo_generator.go (6)",
        "internal/mcp/generators/generator_factory.go (5)",
        "internal/mcp/registry/template_registry.go (5)"
      ]
    },
    {
      "type": "NATS subjects documentados",
      "severity": "low",
      "location": "multiplos arquivos",
      "description": "NATS subjects nao documentados",
      "suggestion": "Crie docs/NATS_SUBJECTS.md",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "tools": null,
        "executable_steps": null,
        "estimated_time": "",
        "confidence": 0
      },
      "examples": null,
      "code_contexts": null,
      "impact_analysis": {
        "severity": "",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "",
        "priority": 0,
        "risk_level": "",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    }
  ],
  "total_gaps": 5,
  "score": 75,
  "auto_fixable": 0,
  "manual": 5,
  "top_priorities": [
    {
      "type": "Nil Pointer Check",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "1 potencial(is) nil pointer issue(s)",
      "suggestion": "Adicione nil checks",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "tools": null,
        "executable_steps": null,
        "estimated_time": "",
        "confidence": 0
      },
      "examples": [
        "multi_level_cache.go:180"
      ],
      "code_contexts": null,
      "impact_analysis": {
        "severity": "",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "",
        "priority": 0,
        "risk_level": "",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "NATS subjects documentados",
      "severity": "low",
      "location": "multiplos arquivos",
      "description": "NATS subjects nao documentados",
      "suggestion": "Crie docs/NATS_SUBJECTS.md",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "tools": null,
        "executable_steps": null,
        "estimated_time": "",
        "confidence": 0
      },
      "examples": null,
      "code_contexts": null,
      "impact_analysis": {
        "severity": "",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "",
        "priority": 0,
        "risk_level": "",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "No Code Conflicts",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Conflitos de declaracao detectados",
      "suggestion": "Remova ou renomeie as declaracoes duplicadas",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "manual_steps": "1. Identifique qual declaracao manter\n2. Remova ou renomeie as duplicatas\n3. Atualize referencias",
        "non_fixable_reason": "ARCHITECTURAL",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "15-30 minutos",
        "confidence": 0
      },
      "examples": [
        "registry: 'TemplateInfo' declarado em mcp_registry.go, template_registry.go",
        "cli: 'init' declarado em ai.go, generate.go, monitor.go, root.go, state.go, template.go, version.go",
        "pubsub: 'PubSubClient' declarado em nats_pubsub.go, pubsub_client.go",
        "encryption: 'Manager' declarado em certificate_manager.go, encryption_manager.go, key_manager.go",
        "crush: 'min' declarado em batch_processor.go, parallel_processor.go",
        "crush: 'max' declarado em batch_processor.go, parallel_processor.go",
        "protocol: 'parseParams' declarado em handlers.go, router.go",
        "analytics: 'init' declarado em metrics.go, performance.go"
      ],
      "non_fixable_reason": "ARCHITECTURAL",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 17,
          "code_snippet": "    12 | \t\"go.uber.org/zap\"\r\n    13 | \t\"gopkg.in/yaml.v3\"\r\n    14 | )\r\n    15 | \r\n    16 | // TemplateInfo holds information about a registered template\r\nâ†’   17 | type TemplateInfo struct {\r\n    18 | \tName         string            `json:\"name\"`\r\n    19 | \tStack        string            `json:\"stack\"`\r\n    20 | \tVersion      string            `json:\"version\"`\r\n    21 | \tSummary      string            `json:\"summary\"`\r\n    22 | \tPlaceholders []string          `json:\"placeholders\"`\r\n",
          "full_function": "type TemplateInfo struct {\r\n\tName         string            `json:\"name\"`\r\n\tStack        string            `json:\"stack\"`\r\n\tVersion      string            `json:\"version\"`\r\n\tSummary      string            `json:\"summary\"`\r\n\tPlaceholders []string          `json:\"placeholders\"`\r\n\tFiles        []string          `json:\"files\"`\r\n\tPath         string            `json:\"path\"`\r\n\tMetadata     map[string]string `json:\"metadata\"`\r\n\tLastModified string            `json:\"last_modified\"`\r\n}\r",
          "symbol_name": "TemplateInfo",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\generate.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"MCP project generation initiated\")\r\n    40 | \t\treturn nil\r\n    41 | \t},\r\n    42 | }\r\n    43 | \r\nâ†’   44 | func init() {\r\n    45 | \trootCmd.AddCommand(generateCmd)\r\n    46 | \tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\r\n    47 | \tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\r\n    48 | \tgenerateCmd.MarkFlagRequired(\"template\")\r\n    49 | }\r\n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(generateCmd)\r\n\tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\r\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\r\n\tgenerateCmd.MarkFlagRequired(\"template\")\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/internal/services",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\monitor.go",
          "line_number": 24,
          "code_snippet": "    19 | \t\tcmd.Println(\"System status: Operational\")\r\n    20 | \t\treturn nil\r\n    21 | \t},\r\n    22 | }\r\n    23 | \r\nâ†’   24 | func init() {\r\n    25 | \trootCmd.AddCommand(monitorCmd)\r\n    26 | }\r\n    27 | \r\n    28 | // SetMonitoringService sets the monitoring service\r\n    29 | func SetMonitoringService(service *services.MonitoringAppService) {\r\n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(monitorCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/internal/services",
            "github.com/vertikon/mcp-core-inventory/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\root.go",
          "line_number": 37,
          "code_snippet": "    32 | \t\tos.Exit(1)\r\n    33 | \t}\r\n    34 | }\r\n    35 | \r\n    36 | // init initializes the CLI\r\nâ†’   37 | func init() {\r\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n    40 | \t\r\n    41 | \t// Add subcommand groups\r\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n",
          "full_function": "func init() {\r\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n\t\r\n\t// Add subcommand groups\r\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n\trootCmd.AddCommand(ci.CICmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\state.go",
          "line_number": 20,
          "code_snippet": "    15 | \t\tcmd.Println(\"State management - service implementation pending\")\r\n    16 | \t\treturn nil\r\n    17 | \t},\r\n    18 | }\r\n    19 | \r\nâ†’   20 | func init() {\r\n    21 | \trootCmd.AddCommand(stateCmd)\r\n    22 | }\r\n    23 | \n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(stateCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\template.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"Template created\")\r\n    40 | \t\treturn nil\r\n    41 | \t},\r\n    42 | }\r\n    43 | \r\nâ†’   44 | func init() {\r\n    45 | \trootCmd.AddCommand(templateCmd)\r\n    46 | \ttemplateCmd.AddCommand(templateListCmd)\r\n    47 | \ttemplateCmd.AddCommand(templateCreateCmd)\r\n    48 | \ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\r\n    49 | \ttemplateCreateCmd.MarkFlagRequired(\"name\")\r\n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(templateCmd)\r\n\ttemplateCmd.AddCommand(templateListCmd)\r\n\ttemplateCmd.AddCommand(templateCreateCmd)\r\n\ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\r\n\ttemplateCreateCmd.MarkFlagRequired(\"name\")\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/internal/services",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\version.go",
          "line_number": 21,
          "code_snippet": "    16 | \t\tfmt.Printf(\"Version: %s\\n\", Version)\r\n    17 | \t\tfmt.Printf(\"Build Date: %s\\n\", BuildDate)\r\n    18 | \t},\r\n    19 | }\r\n    20 | \r\nâ†’   21 | func init() {\r\n    22 | \trootCmd.AddCommand(versionCmd)\r\n    23 | }\r\n    24 | \n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(versionCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\messaging\\pubsub\\pubsub_client.go",
          "line_number": 9,
          "code_snippet": "     4 | import (\r\n     5 | \t\"context\"\r\n     6 | )\r\n     7 | \r\n     8 | // PubSubClient provides generic pub/sub interface\r\nâ†’    9 | type PubSubClient interface {\r\n    10 | \t// Publish publishes a message to a topic\r\n    11 | \tPublish(ctx context.Context, topic string, message []byte) error\r\n    12 | \r\n    13 | \t// Subscribe subscribes to a topic\r\n    14 | \tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n",
          "full_function": "type PubSubClient interface {\r\n\t// Publish publishes a message to a topic\r\n\tPublish(ctx context.Context, topic string, message []byte) error\r\n\r\n\t// Subscribe subscribes to a topic\r\n\tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n\r\n\t// Close closes the client connection\r\n\tClose() error\r\n}\r",
          "symbol_name": "PubSubClient",
          "package_name": "pubsub",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 622,
          "code_snippet": "   617 | \t\treturn a\r\n   618 | \t}\r\n   619 | \treturn b\r\n   620 | }\r\n   621 | \r\nâ†’  622 | func max(a, b time.Time) time.Time {\r\n   623 | \tif a.After(b) {\r\n   624 | \t\treturn a\r\n   625 | \t}\r\n   626 | \treturn b\r\n   627 | }\n",
          "full_function": "func max(a, b time.Time) time.Time {\r\n\tif a.After(b) {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "max",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 56,
          "code_snippet": "    51 | \t// Verify verifies a signature using RSA\r\n    52 | \tVerify(data, signature []byte, publicKey *rsa.PublicKey) bool\r\n    53 | }\r\n    54 | \r\n    55 | // Manager implements EncryptionManager\r\nâ†’   56 | type Manager struct {\r\n    57 | \tkeyManager KeyManager\r\n    58 | \tlogger     *zap.Logger\r\n    59 | }\r\n    60 | \r\n    61 | // NewEncryptionManager creates a new EncryptionManager\r\n",
          "full_function": "type Manager struct {\r\n\tkeyManager KeyManager\r\n\tlogger     *zap.Logger\r\n}\r",
          "symbol_name": "Manager",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 52,
          "code_snippet": "    47 | \t// LoadKeyFromFile loads key from file\r\n    48 | \tLoadKeyFromFile(filePath string) error\r\n    49 | }\r\n    50 | \r\n    51 | // Manager implements KeyManager\r\nâ†’   52 | type Manager struct {\r\n    53 | \tencryptionKey []byte\r\n    54 | \tkeyVersion    string\r\n    55 | \trsaPrivateKey *rsa.PrivateKey\r\n    56 | \trsaPublicKey  *rsa.PublicKey\r\n    57 | \trotationTTL  time.Duration\r\n",
          "full_function": "type Manager struct {\r\n\tencryptionKey []byte\r\n\tkeyVersion    string\r\n\trsaPrivateKey *rsa.PrivateKey\r\n\trsaPublicKey  *rsa.PublicKey\r\n\trotationTTL  time.Duration\r\n\tlastRotation  time.Time\r\n\tmu            sync.RWMutex\r\n\tlogger        *zap.Logger\r\n}\r",
          "symbol_name": "Manager",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 625,
          "code_snippet": "   620 | \tas.stats.ScaleDownEvents++\r\n   621 | \tnow := time.Now()\r\n   622 | \tas.stats.LastScalingTime = \u0026now\r\n   623 | }\r\n   624 | \r\nâ†’  625 | func min(a, b int) int {\r\n   626 | \tif a \u003c b {\r\n   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n",
          "full_function": "func min(a, b int) int {\r\n\tif a \u003c b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r",
          "symbol_name": "min",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 632,
          "code_snippet": "   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n   631 | \r\nâ†’  632 | func max(a, b int) int {\r\n   633 | \tif a \u003e b {\r\n   634 | \t\treturn a\r\n   635 | \t}\r\n   636 | \treturn b\r\n   637 | }\n",
          "full_function": "func max(a, b int) int {\r\n\tif a \u003e b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "max",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\protocol\\router.go",
          "line_number": 215,
          "code_snippet": "   210 | \r\n   211 | \treturn nil\r\n   212 | }\r\n   213 | \r\n   214 | // parseParams parses parameters from a JSON-RPC request\r\nâ†’  215 | func parseParams(params interface{}, target interface{}) error {\r\n   216 | \tif params == nil {\r\n   217 | \t\treturn nil\r\n   218 | \t}\r\n   219 | \r\n   220 | \t// This is a simplified parameter parsing\r\n",
          "full_function": "",
          "symbol_name": "parseParams",
          "package_name": "protocol",
          "dependencies": [
            "context",
            "fmt",
            "strings",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\analytics\\performance.go",
          "line_number": 23,
          "code_snippet": "    18 | \t\tcmd.Println(\"  P95 Latency: 0ms\")\r\n    19 | \t\treturn nil\r\n    20 | \t},\r\n    21 | }\r\n    22 | \r\nâ†’   23 | func init() {\r\n    24 | \tAnalyticsCmd.AddCommand(performanceCmd)\r\n    25 | }\r\n    26 | \n",
          "full_function": "func init() {\r\n\tAnalyticsCmd.AddCommand(performanceCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "analytics",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "10-30 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Linter limpo",
      "severity": "low",
      "location": "multiplos arquivos",
      "description": "âœ— FAIL: 71 issues crÃ­ticos, 0 warnings",
      "suggestion": "Corrija os issues FAIL primeiro, depois warnings",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": [
          {
            "tool_name": "golangci-lint",
            "install_command": "go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
            "diagnose_command": "golangci-lint run",
            "fix_command": "# NAO use --fix automaticamente, revise cada issue",
            "config_required": true,
            "config_template": ".golangci.yml com linters selecionados",
            "documentation": "https://golangci-lint.run/",
            "alternative_tools": null
          },
          {
            "tool_name": "staticcheck",
            "install_command": "go install honnef.co/go/tools/cmd/staticcheck@latest",
            "diagnose_command": "staticcheck ./...",
            "fix_command": "# Manual - staticcheck nao tem auto-fix",
            "config_required": false,
            "config_template": "",
            "documentation": "https://staticcheck.io/",
            "alternative_tools": null
          },
          {
            "tool_name": "gosec",
            "install_command": "go install github.com/securego/gosec/v2/cmd/gosec@latest",
            "diagnose_command": "gosec ./...",
            "fix_command": "# Manual - corrija issues de seguranca",
            "config_required": false,
            "config_template": "",
            "documentation": "https://github.com/securego/gosec",
            "alternative_tools": null
          }
        ],
        "executable_steps": null,
        "estimated_time": "2h22m",
        "confidence": 0
      },
      "examples": [
        "ðŸ“¦ MÃ³dulos analisados: 1",
        "ðŸ“„ Linter Report v2: JSON + SARIF gerados",
        "",
        "ðŸ“Š Resumo por ferramenta (todos os mÃ³dulos):",
        "  â€¢ golangci-lint: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ govet: ð„‚ 71 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "  â€¢ staticcheck: ð„‚ 0 FAIL / âš  0 WARN / â„¹ 0 INFO",
        "",
        "ðŸ” Top issues prioritÃ¡rios (FAIL):",
        "  1. [govet] internal/core/scheduler/scheduler.go:62 - undefined: nats.ErrStreamNameExist (govet)",
        "  2. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.id undefined (type ledger.Reservation has no field or method id) (govet)",
        "  3. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.ledgerID undefined (type ledger.Reservation has no field or method... (govet)",
        "  4. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.sku undefined (type ledger.Reservation has no field or method sku) (govet)",
        "  5. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.location undefined (type ledger.Reservation has no field or method... (govet)",
        "  6. [govet] internal/adapters/postgres/ledger_repository.go:103 - res.quantity undefined (type ledger.Reservation has no field or method... (govet)",
        "  7. [govet] internal/adapters/postgres/ledger_repository.go:104 - res.idempotencyKey undefined (type ledger.Reservation has no field or ... (govet)",
        "  8. [govet] internal/adapters/postgres/ledger_repository.go:114 - res.status undefined (type ledger.Reservation has no field or method s... (govet)",
        "  9. [govet] internal/adapters/postgres/ledger_repository.go:115 - res.expiresAt undefined (type ledger.Reservation has no field or metho... (govet)",
        "  10. [govet] internal/adapters/postgres/ledger_repository.go:116 - res.createdAt undefined (type ledger.Reservation has no field or metho... (govet)"
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": null,
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 71,
        "affected_lines": 71,
        "blocks_deploy": false,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "2h22m",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [
        "performance",
        "memory-optimization"
      ],
      "error_breakdown": {
        "govet": 71
      },
      "top_files": [
        "internal/adapters/postgres/ledger_repository.go (11)",
        "internal/security/encryption/key_manager.go (7)",
        "internal/mcp/generators/tinygo_generator.go (6)",
        "internal/mcp/generators/generator_factory.go (5)",
        "internal/mcp/registry/template_registry.go (5)"
      ]
    },
    {
      "type": "Codigo compila",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Nao compila: # github.com/vertikon/mcp-core-inventory/internal/core/scheduler\ninternal\\core\\scheduler\\scheduler.go:62:19: undefined: nats.ErrStreamNameExist\n# github.com/vertikon/mcp-core-inventory/internal/adapte...",
      "suggestion": "Corrija os erros de compilacao listados",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "Variavel - depende dos erros",
        "confidence": 0
      },
      "examples": [
        "ðŸ“„ Log completo: E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\docs\\validation\\raw\\2025-11-21-20-35-21-compilation.log",
        "",
        "# github.com/vertikon/mcp-core-inventory/internal/core/scheduler",
        "internal\\core\\scheduler\\scheduler.go:62:19: undefined: nats.ErrStreamNameExist",
        "# github.com/vertikon/mcp-core-inventory/internal/adapters/postgres",
        "internal\\adapters\\postgres\\ledger_repository.go:103:8: res.id undefined (type ledger.Reservation has no field or method id)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:17: res.ledgerID undefined (type ledger.Reservation has no field or method ledgerID, but does have method LedgerID)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:32: res.sku undefined (type ledger.Reservation has no field or method sku)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:42: res.location undefined (type ledger.Reservation has no field or method location, but does have method Location)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:57: res.quantity undefined (type ledger.Reservation has no field or method quantity, but does have method Quantity)",
        "internal\\adapters\\postgres\\ledger_repository.go:104:8: res.idempotencyKey undefined (type ledger.Reservation has no field or method idempotencyKey, but does have method IdempotencyKey)",
        "internal\\adapters\\postgres\\ledger_repository.go:114:6: res.status undefined (type ledger.Reservation has no field or method status, but does have method Status)",
        "internal\\adapters\\postgres\\ledger_repository.go:115:6: res.expiresAt undefined (type ledger.Reservation has no field or method expiresAt, but does have method ExpiresAt)",
        "internal\\adapters\\postgres\\ledger_repository.go:116:6: res.createdAt undefined (type ledger.Reservation has no field or method createdAt, but does have method CreatedAt)",
        "internal\\adapters\\postgres\\ledger_repository.go:117:6: res.updatedAt undefined (type ledger.Reservation has no field or method updatedAt, but does have method UpdatedAt)",
        "internal\\adapters\\postgres\\ledger_repository.go:117:6: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/app",
        "internal\\app\\query_available.go:7:2: \"github.com/vertikon/mcp-core-inventory/internal/domain/ledger\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/mcp/generators",
        "internal\\mcp\\generators\\generator_factory.go:317:32: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:319:50: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:323:54: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:334:75: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:350:39: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\tinygo_generator.go:324:3: cannot use \"project\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:324:14: cannot use req.Name (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:3: cannot use \"language\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:15: cannot use g.language (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: cannot use \"features\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/mcp/registry",
        "internal\\mcp\\registry\\template_registry.go:17:6: TemplateInfo redeclared in this block",
        "\tinternal\\mcp\\registry\\mcp_registry.go:301:6: other declaration of TemplateInfo",
        "internal\\mcp\\registry\\template_registry.go:75:17: templateInfo.Path undefined (type *TemplateInfo has no field or method Path)",
        "internal\\mcp\\registry\\template_registry.go:124:3: unknown field Summary in struct literal of type TemplateInfo",
        "internal\\mcp\\registry\\template_registry.go:125:3: unknown field Placeholders in struct literal of type TemplateInfo",
        "internal\\mcp\\registry\\discovery.go:21:13: undefined: logger",
        "internal\\mcp\\registry\\discovery.go:27:5: sd.mu undefined (type *ServiceDiscovery has no field or method mu)",
        "internal\\mcp\\registry\\discovery.go:28:11: sd.mu undefined (type *ServiceDiscovery has no field or method mu)",
        "internal\\mcp\\registry\\discovery.go:51:11: service.Description undefined (type *ServiceInfo has no field or method Description)",
        "internal\\mcp\\registry\\service_registry.go:33:10: service.LastChecked undefined (type *ServiceInfo has no field or method LastChecked)",
        "internal\\mcp\\registry\\service_registry.go:96:10: service.LastChecked undefined (type *ServiceInfo has no field or method LastChecked)",
        "internal\\mcp\\registry\\template_registry.go:125:3: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/adapters/redis",
        "internal\\adapters\\redis\\reservation_lock.go:55:2: declared and not used: script",
        "# github.com/vertikon/mcp-core-inventory/cmd/tools-validator",
        "cmd\\tools-validator\\main.go:60:4: unknown field StrictMode in struct literal of type \"github.com/vertikon/mcp-core-inventory/tools/validators\".ConfigValidateRequest",
        "# github.com/vertikon/mcp-core-inventory/internal/core/crush",
        "internal\\core\\crush\\memory_optimizer.go:31:2: PolicyLRU redeclared in this block",
        "\tinternal\\core\\crush\\batch_processor.go:155:2: other declaration of PolicyLRU",
        "internal\\core\\crush\\memory_optimizer.go:395:8: invalid case PolicyLRU in switch on mo.config.EvictionPolicy (mismatched types PrefetchPolicy and EvictionPolicy)",
        "internal\\core\\crush\\parallel_processor.go:625:6: min redeclared in this block",
        "\tinternal\\core\\crush\\batch_processor.go:796:6: other declaration of min",
        "internal\\core\\crush\\parallel_processor.go:632:6: max redeclared in this block",
        "\tinternal\\core\\crush\\batch_processor.go:803:6: other declaration of max",
        "internal\\core\\crush\\batch_processor.go:269:19: undefined: runtime",
        "internal\\core\\crush\\batch_processor.go:427:6: declared and not used: id",
        "internal\\core\\crush\\batch_processor.go:560:18: cannot use \u0026bp.stats.TotalProcessingTime (value of type *time.Duration) as *int64 value in argument to atomic.AddInt64",
        "internal\\core\\crush\\batch_processor.go:584:42: cannot use \u0026bp.stats.TotalProcessingTime (value of type *time.Duration) as *int64 value in argument to atomic.LoadInt64",
        "internal\\core\\crush\\batch_processor.go:781:15: undefined: NewWorkerPool",
        "internal\\core\\crush\\batch_processor.go:792:23: too many arguments in call to abp.workerPool.Start",
        "\thave (context.Context)",
        "\twant ()",
        "internal\\core\\crush\\memory_optimizer.go:395:8: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/domain/services",
        "internal\\domain\\services\\ai_domain_service.go:33:17: context.documents undefined (type *entities.KnowledgeContext has no field or method documents, but does have method Documents)",
        "# github.com/vertikon/mcp-core-inventory/internal/core/state",
        "internal\\core\\state\\distributed_store.go:543:22: invalid operation: cannot take address of dss.stats.LockWaitTime.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:649:31: invalid operation: cannot take address of dss.stats.AvgReadLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:651:21: invalid operation: cannot take address of dss.stats.AvgReadLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:656:31: invalid operation: cannot take address of dss.stats.AvgWriteLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:658:21: invalid operation: cannot take address of dss.stats.AvgWriteLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\store.go:10:2: \"github.com/vertikon/mcp-core-inventory/pkg/logger\" imported and not used",
        "internal\\core\\state\\store.go:11:2: \"go.uber.org/zap\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/core/transformer",
        "internal\\core\\transformer\\feedforward.go:194:21: ffn.router undefined (type *FeedForwardNetwork has no field or method router)",
        "internal\\core\\transformer\\transformer.go:152:38: not enough arguments in call to t.embeddings.Forward",
        "\thave (*Tensor)",
        "\twant (context.Context, *Tensor)",
        "internal\\core\\transformer\\transformer.go:209:79: cannot use attentionMask (variable of type *Tensor) as *AttentionMask value in argument to l.attention.Forward",
        "internal\\core\\transformer\\transformer.go:215:28: cannot use attnOutput (variable of type *AttentionResult) as *Tensor value in argument to t.add",
        "internal\\core\\transformer\\transformer.go:249:65: cannot use ln.eps (variable of type float64) as *Tensor value in argument to t.add",
        "internal\\core\\transformer\\positional_encoding.go:6:2: \"fmt\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/compute/serverless",
        "internal\\infrastructure\\compute\\serverless\\cloud_functions.go:14:46: undefined: FunctionConfig",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/messaging/pubsub",
        "internal\\infrastructure\\messaging\\pubsub\\pubsub_client.go:9:6: PubSubClient redeclared in this block",
        "\tinternal\\infrastructure\\messaging\\pubsub\\nats_pubsub.go:9:6: other declaration of PubSubClient",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/messaging/streaming",
        "internal\\infrastructure\\messaging\\streaming\\nats_jetstream.go:178:18: undefined: nats.ErrStreamNameExist",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/persistence/relational",
        "internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go:87:6: declared and not used: knowledge",
        "internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go:204:9: cannot use \u0026knowledge (value of type **entities.Knowledge) as *entities.Knowledge value in return statement",
        "# github.com/vertikon/mcp-core-inventory/internal/interfaces/cli",
        "internal\\interfaces\\cli\\root.go:42:21: undefined: analytics",
        "internal\\interfaces\\cli\\root.go:43:21: undefined: ci",
        "# github.com/vertikon/mcp-core-inventory/tools/deployers",
        "tools\\deployers\\hybrid_deployer.go:10:2: \"github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/security/encryption",
        "internal\\security\\encryption\\encryption_manager.go:56:6: Manager redeclared in this block",
        "\tinternal\\security\\encryption\\certificate_manager.go:42:6: other declaration of Manager",
        "internal\\security\\encryption\\encryption_manager.go:64:3: unknown field keyManager in struct literal of type Manager",
        "internal\\security\\encryption\\encryption_manager.go:71:16: m.keyManager undefined (type *Manager has no field or method keyManager)",
        "internal\\security\\encryption\\encryption_manager.go:81:16: m.keyManager undefined (type *Manager has no field or method keyManager)",
        "internal\\security\\encryption\\key_manager.go:52:6: Manager redeclared in this block",
        "\tinternal\\security\\encryption\\certificate_manager.go:42:6: other declaration of Manager",
        "internal\\security\\encryption\\key_manager.go:72:3: unknown field keyVersion in struct literal of type Manager",
        "internal\\security\\encryption\\key_manager.go:82:6: km.encryptionKey undefined (type *Manager has no field or method encryptionKey)",
        "internal\\security\\encryption\\key_manager.go:96:4: m.mu undefined (type *Manager has no field or method mu)",
        "internal\\security\\encryption\\key_manager.go:97:10: m.mu undefined (type *Manager has no field or method mu)",
        "internal\\security\\encryption\\key_manager.go:99:7: m.encryptionKey undefined (type *Manager has no field or method encryptionKey)",
        "internal\\security\\encryption\\key_manager.go:99:7: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/state/cache",
        "internal\\state\\cache\\cache_coherency.go:162:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "internal\\state\\cache\\cache_coherency.go:217:11: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:253:34: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:342:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "# github.com/vertikon/mcp-core-inventory/internal/state/store",
        "internal\\state\\store\\conflict_resolver.go:236:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:238:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:251:2: declared and not used: localTime",
        "internal\\state\\store\\conflict_resolver.go:252:2: declared and not used: remoteTime",
        "internal\\state\\store\\conflict_resolver.go:283:51: too many arguments in call to r.isMergeableValue",
        "\thave (interface{}, interface{})",
        "\twant (interface{})",
        "internal\\state\\store\\conflict_resolver.go:396:9: v declared and not used",
        "internal\\state\\store\\conflict_resolver.go:415:13: r.mergeMaps undefined (type map[string]interface{} has no field or method mergeMaps)",
        "internal\\state\\store\\conflict_resolver.go:419:13: r.mergeArrays undefined (type []interface{} has no field or method mergeArrays)",
        "internal\\state\\store\\conflict_resolver.go:516:35: cannot use localTS (variable of struct type time.Time) as uint64 value in argument to max",
        "internal\\state\\store\\conflict_resolver.go:622:6: max redeclared in this block",
        "\tinternal\\state\\store\\conflict_resolver.go:615:6: other declaration of max",
        "internal\\state\\store\\conflict_resolver.go:516:35: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/state/events",
        "internal\\state\\events\\event_replay.go:249:2: declared and not used: snapshot",
        "internal\\state\\events\\event_replay.go:290:2: declared and not used: events",
        "internal\\state\\events\\event_versioning.go:140:4: invalid operation: cannot call copy (variable of struct type VersionInfo): VersionInfo is not a function",
        "internal\\state\\events\\event_versioning.go:216:30: ev.resolveVersionConflict undefined (type *EventVersioningImpl has no field or method resolveVersionConflict, but does have method ResolveVersionConflict)",
        ""
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\scheduler\\scheduler.go",
          "line_number": 62,
          "code_snippet": "    57 | \t\t\tMaxAge:    24 * time.Hour,\r\n    58 | \t\t}\r\n    59 | \r\n    60 | \t\t_, err := s.js.AddStream(cfg)\r\n    61 | \t\tif err != nil {\r\nâ†’   62 | \t\t\tif err == nats.ErrStreamNameExist {\r\n    63 | \t\t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", stream.name))\r\n    64 | \t\t\t\tcontinue\r\n    65 | \t\t\t}\r\n    66 | \t\t\treturn err\r\n    67 | \t\t}\r\n",
          "full_function": "func (s *Scheduler) InitializeStreams(ctx context.Context) error {\r\n\tstreams := []struct {\r\n\t\tname    string\r\n\t\tsubjects []string\r\n\t}{\r\n\t\t{\r\n\t\t\tname:     \"hulk.engine.tasks\",\r\n\t\t\tsubjects: []string{\"hulk.task.created\", \"hulk.task.completed\", \"hulk.task.failed\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"hulk.engine.events\",\r\n\t\t\tsubjects: []string{\"hulk.engine.*\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"hulk.scheduler.queue\",\r\n\t\t\tsubjects: []string{\"hulk.scheduler.tick\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"hulk.errors\",\r\n\t\t\tsubjects: []string{\"hulk.error.*\"},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, stream := range streams {\r\n\t\tcfg := \u0026nats.StreamConfig{\r\n\t\t\tName:      stream.name,\r\n\t\t\tSubjects: stream.subjects,\r\n\t\t\tReplicas:  1,\r\n\t\t\tMaxAge:    24 * time.Hour,\r\n\t\t}\r\n\r\n\t\t_, err := s.js.AddStream(cfg)\r\n\t\tif err != nil {\r\n\t\t\tif err == nats.ErrStreamNameExist {\r\n\t\t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", stream.name))\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\ts.streams[stream.name] = cfg\r\n\t\tlogger.Info(\"Stream created\", zap.String(\"stream\", stream.name))\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "scheduler",
          "dependencies": [
            "context",
            "encoding/json",
            "time",
            "github.com/nats-io/nats.go",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 104,
          "code_snippet": "    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\n   103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\nâ†’  104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n   109 | \t\t}\r\n",
          "full_function": "\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 114,
          "code_snippet": "   109 | \t\t}\r\n   110 | \t\treturn nil, err\r\n   111 | \t}\r\n   112 | \r\n   113 | \t// Reconstruct reservation\r\nâ†’  114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\n   117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n",
          "full_function": "\tres.status = ledger.ReservationStatus(status)\r\n\tres.expiresAt = expiresAt\r\n\tres.createdAt = createdAt\r\n\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 115,
          "code_snippet": "   110 | \t\treturn nil, err\r\n   111 | \t}\r\n   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\nâ†’  115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\n   117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n",
          "full_function": "\tres.expiresAt = expiresAt\r\n\tres.createdAt = createdAt\r\n\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 116,
          "code_snippet": "   111 | \t}\r\n   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\nâ†’  116 | \tres.createdAt = createdAt\r\n   117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n   121 | \r\n",
          "full_function": "\tres.createdAt = createdAt\r\n\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 117,
          "code_snippet": "   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\nâ†’  117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n   121 | \r\n   122 | // FindByID finds a reservation by ID\r\n",
          "full_function": "\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 117,
          "code_snippet": "   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\nâ†’  117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n   121 | \r\n   122 | // FindByID finds a reservation by ID\r\n",
          "full_function": "\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\app\\query_available.go",
          "line_number": 7,
          "code_snippet": "     2 | \r\n     3 | import (\r\n     4 | \t\"context\"\r\n     5 | \t\"fmt\"\r\n     6 | \r\nâ†’    7 | \t\"github.com/vertikon/mcp-core-inventory/internal/domain/ledger\"\r\n     8 | )\r\n     9 | \r\n    10 | // QueryAvailableRequest represents a request to query available stock\r\n    11 | type QueryAvailableRequest struct {\r\n    12 | \tSKU      string\r\n",
          "full_function": "\t\"github.com/vertikon/mcp-core-inventory/internal/domain/ledger\"\r\n)\r\n\r\n// QueryAvailableRequest represents a request to query available stock\r\ntype QueryAvailableRequest struct {\r\n\tSKU      string\r\n\tLocation string\r\n}\r",
          "symbol_name": "",
          "package_name": "app",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 317,
          "code_snippet": "   312 | \tif req.Path == \"\" {\r\n   313 | \t\treturn fmt.Errorf(\"output path is required\")\r\n   314 | \t}\r\n   315 | \r\n   316 | \t// Check if stack is supported\r\nâ†’  317 | \t_, exists := f.generators[req.Stack]\r\n   318 | \tif !exists {\r\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n   320 | \t}\r\n   321 | \r\n   322 | \t// Validate stack configuration\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 319,
          "code_snippet": "   314 | \t}\r\n   315 | \r\n   316 | \t// Check if stack is supported\r\n   317 | \t_, exists := f.generators[req.Stack]\r\n   318 | \tif !exists {\r\nâ†’  319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n   320 | \t}\r\n   321 | \r\n   322 | \t// Validate stack configuration\r\n   323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n   324 | \t\t// Validate features\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 323,
          "code_snippet": "   318 | \tif !exists {\r\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n   320 | \t}\r\n   321 | \r\n   322 | \t// Validate stack configuration\r\nâ†’  323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n   324 | \t\t// Validate features\r\n   325 | \t\tfor _, feature := range req.Features {\r\n   326 | \t\t\tvalidFeature := false\r\n   327 | \t\t\tfor _, validFeat := range stackConfig.Features {\r\n   328 | \t\t\t\tif feature == validFeat {\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 334,
          "code_snippet": "   329 | \t\t\t\t\tvalidFeature = true\r\n   330 | \t\t\t\t\tbreak\r\n   331 | \t\t\t\t}\r\n   332 | \t\t\t}\r\n   333 | \t\t\tif !validFeature {\r\nâ†’  334 | \t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n   335 | \t\t\t}\r\n   336 | \t\t}\r\n   337 | \t}\r\n   338 | \r\n   339 | \treturn nil\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 350,
          "code_snippet": "   345 | \tif err := f.ValidateRequest(req); err != nil {\r\n   346 | \t\treturn nil, err\r\n   347 | \t}\r\n   348 | \r\n   349 | \t// Get generator\r\nâ†’  350 | \tgenerator, err := f.GetGenerator(req.Stack)\r\n   351 | \tif err != nil {\r\n   352 | \t\treturn nil, err\r\n   353 | \t}\r\n   354 | \r\n   355 | \t// Generate project\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\r\n   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\nâ†’  324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\r\n   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\nâ†’  324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\nâ†’  325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\nâ†’  325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\nâ†’  326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n   331 | // Validate validates wasm generator\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\nâ†’  326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n   331 | // Validate validates wasm generator\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 17,
          "code_snippet": "    12 | \t\"go.uber.org/zap\"\r\n    13 | \t\"gopkg.in/yaml.v3\"\r\n    14 | )\r\n    15 | \r\n    16 | // TemplateInfo holds information about a registered template\r\nâ†’   17 | type TemplateInfo struct {\r\n    18 | \tName         string            `json:\"name\"`\r\n    19 | \tStack        string            `json:\"stack\"`\r\n    20 | \tVersion      string            `json:\"version\"`\r\n    21 | \tSummary      string            `json:\"summary\"`\r\n    22 | \tPlaceholders []string          `json:\"placeholders\"`\r\n",
          "full_function": "type TemplateInfo struct {\r\n\tName         string            `json:\"name\"`\r\n\tStack        string            `json:\"stack\"`\r\n\tVersion      string            `json:\"version\"`\r\n\tSummary      string            `json:\"summary\"`\r\n\tPlaceholders []string          `json:\"placeholders\"`\r\n\tFiles        []string          `json:\"files\"`\r\n\tPath         string            `json:\"path\"`\r\n\tMetadata     map[string]string `json:\"metadata\"`\r\n\tLastModified string            `json:\"last_modified\"`\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\mcp\\registry\\mcp_registry.go",
          "line_number": 301,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 75,
          "code_snippet": "    70 | \t\t\t\t\tzap.String(\"path\", path), \r\n    71 | \t\t\t\t\tzap.Error(err))\r\n    72 | \t\t\t\treturn nil // Continue loading other templates\r\n    73 | \t\t\t}\r\n    74 | \r\nâ†’   75 | \t\t\ttemplateInfo.Path = relPath\r\n    76 | \t\t\ttr.templates[templateInfo.Name] = templateInfo\r\n    77 | \t\t\ttr.logger.Info(\"Loaded template\", \r\n    78 | \t\t\t\tzap.String(\"name\", templateInfo.Name),\r\n    79 | \t\t\t\tzap.String(\"stack\", templateInfo.Stack))\r\n    80 | \t\t}\r\n",
          "full_function": "func (tr *TemplateRegistry) LoadTemplates(ctx context.Context) error {\r\n\ttr.mu.Lock()\r\n\tdefer tr.mu.Unlock()\r\n\r\n\ttr.logger.Info(\"Loading templates from\", zap.String(\"path\", tr.basePath))\r\n\r\n\t// Walk through the templates directory\r\n\terr := filepath.WalkDir(tr.basePath, func(path string, d fs.DirEntry, err error) error {\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\t// Look for manifest.yaml files\r\n\t\tif d.Name() == \"manifest.yaml\" {\r\n\t\t\ttemplateDir := filepath.Dir(path)\r\n\t\t\trelPath, err := filepath.Rel(tr.basePath, templateDir)\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn err\r\n\t\t\t}\r\n\r\n\t\t\ttemplateInfo, err := tr.loadTemplateFromManifest(path)\r\n\t\t\tif err != nil {\r\n\t\t\t\ttr.logger.Error(\"Failed to load template\", \r\n\t\t\t\t\tzap.String(\"path\", path), \r\n\t\t\t\t\tzap.Error(err))\r\n\t\t\t\treturn nil // Continue loading other templates\r\n\t\t\t}\r\n\r\n\t\t\ttemplateInfo.Path = relPath\r\n\t\t\ttr.templates[templateInfo.Name] = templateInfo\r\n\t\t\ttr.logger.Info(\"Loaded template\", \r\n\t\t\t\tzap.String(\"name\", templateInfo.Name),\r\n\t\t\t\tzap.String(\"stack\", templateInfo.Stack))\r\n\t\t}\r\n\r\n\t\treturn nil\r\n\t})\r\n\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed to walk templates directory: %w\", err)\r\n\t}\r\n\r\n\ttr.logger.Info(\"Templates loaded successfully\", zap.Int(\"count\", len(tr.templates)))\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 124,
          "code_snippet": "   119 | \r\n   120 | \ttemplateInfo := \u0026TemplateInfo{\r\n   121 | \t\tName:         manifest.Name,\r\n   122 | \t\tStack:        manifest.Stack,\r\n   123 | \t\tVersion:      manifest.Version,\r\nâ†’  124 | \t\tSummary:      manifest.Summary,\r\n   125 | \t\tPlaceholders: manifest.Placeholders,\r\n   126 | \t\tFiles:        manifest.Files,\r\n   127 | \t\tMetadata:     make(map[string]string),\r\n   128 | \t}\r\n   129 | \r\n",
          "full_function": "\t\tSummary:      manifest.Summary,\r\n\t\tPlaceholders: manifest.Placeholders,\r\n\t\tFiles:        manifest.Files,\r\n\t\tMetadata:     make(map[string]string),\r\n\t}\r\n\r\n\treturn templateInfo, nil\r\n}\r\n\r\n// GetTemplate returns a template by name\r\nfunc (tr *TemplateRegistry) GetTemplate(name string) (*TemplateInfo, error) {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplate, exists := tr.templates[name]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"template '%s' not found\", name)\r\n\t}\r\n\r\n\treturn template, nil\r\n}\r\n\r\n// ListTemplates returns all registered templates\r\nfunc (tr *TemplateRegistry) ListTemplates() []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplates := make([]*TemplateInfo, 0, len(tr.templates))\r\n\tfor _, template := range tr.templates {\r\n\t\ttemplates = append(templates, template)\r\n\t}\r\n\r\n\treturn templates\r\n}\r\n\r\n// ListTemplatesByStack returns templates filtered by stack\r\nfunc (tr *TemplateRegistry) ListTemplatesByStack(stack string) []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\tvar templates []*TemplateInfo\r\n\tfor _, template := range tr.templates {\r\n\t\tif template.Stack == stack {\r\n\t\t\ttemplates = append(templates, template)\r\n\t\t}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 125,
          "code_snippet": "   120 | \ttemplateInfo := \u0026TemplateInfo{\r\n   121 | \t\tName:         manifest.Name,\r\n   122 | \t\tStack:        manifest.Stack,\r\n   123 | \t\tVersion:      manifest.Version,\r\n   124 | \t\tSummary:      manifest.Summary,\r\nâ†’  125 | \t\tPlaceholders: manifest.Placeholders,\r\n   126 | \t\tFiles:        manifest.Files,\r\n   127 | \t\tMetadata:     make(map[string]string),\r\n   128 | \t}\r\n   129 | \r\n   130 | \treturn templateInfo, nil\r\n",
          "full_function": "\t\tPlaceholders: manifest.Placeholders,\r\n\t\tFiles:        manifest.Files,\r\n\t\tMetadata:     make(map[string]string),\r\n\t}\r\n\r\n\treturn templateInfo, nil\r\n}\r\n\r\n// GetTemplate returns a template by name\r\nfunc (tr *TemplateRegistry) GetTemplate(name string) (*TemplateInfo, error) {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplate, exists := tr.templates[name]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"template '%s' not found\", name)\r\n\t}\r\n\r\n\treturn template, nil\r\n}\r\n\r\n// ListTemplates returns all registered templates\r\nfunc (tr *TemplateRegistry) ListTemplates() []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplates := make([]*TemplateInfo, 0, len(tr.templates))\r\n\tfor _, template := range tr.templates {\r\n\t\ttemplates = append(templates, template)\r\n\t}\r\n\r\n\treturn templates\r\n}\r\n\r\n// ListTemplatesByStack returns templates filtered by stack\r\nfunc (tr *TemplateRegistry) ListTemplatesByStack(stack string) []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\tvar templates []*TemplateInfo\r\n\tfor _, template := range tr.templates {\r\n\t\tif template.Stack == stack {\r\n\t\t\ttemplates = append(templates, template)\r\n\t\t}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 21,
          "code_snippet": "    16 | \r\n    17 | // NewServiceDiscovery creates a new service discovery instance\r\n    18 | func NewServiceDiscovery(registry *MCPRegistry) *ServiceDiscovery {\r\n    19 | \treturn \u0026ServiceDiscovery{\r\n    20 | \t\tregistry: registry,\r\nâ†’   21 | \t\tlogger:   logger.GetLogger(),\r\n    22 | \t}\r\n    23 | }\r\n    24 | \r\n    25 | // DiscoverServices discovers services in the registry\r\n    26 | func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n",
          "full_function": "func NewServiceDiscovery(registry *MCPRegistry) *ServiceDiscovery {\r\n\treturn \u0026ServiceDiscovery{\r\n\t\tregistry: registry,\r\n\t\tlogger:   logger.GetLogger(),\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 27,
          "code_snippet": "    22 | \t}\r\n    23 | }\r\n    24 | \r\n    25 | // DiscoverServices discovers services in the registry\r\n    26 | func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\nâ†’   27 | \tsd.mu.RLock()\r\n    28 | \tdefer sd.mu.RUnlock()\r\n    29 | \r\n    30 | \tvar results []*ServiceInfo\r\n    31 | \t\r\n    32 | \tfor _, service := range sd.registry.services {\r\n",
          "full_function": "func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n\tsd.mu.RLock()\r\n\tdefer sd.mu.RUnlock()\r\n\r\n\tvar results []*ServiceInfo\r\n\t\r\n\tfor _, service := range sd.registry.services {\r\n\t\tif matchesQuery(service, query) {\r\n\t\t\tresults = append(results, service)\r\n\t\t}\r\n\t}\r\n\r\n\treturn results, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 28,
          "code_snippet": "    23 | }\r\n    24 | \r\n    25 | // DiscoverServices discovers services in the registry\r\n    26 | func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n    27 | \tsd.mu.RLock()\r\nâ†’   28 | \tdefer sd.mu.RUnlock()\r\n    29 | \r\n    30 | \tvar results []*ServiceInfo\r\n    31 | \t\r\n    32 | \tfor _, service := range sd.registry.services {\r\n    33 | \t\tif matchesQuery(service, query) {\r\n",
          "full_function": "func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n\tsd.mu.RLock()\r\n\tdefer sd.mu.RUnlock()\r\n\r\n\tvar results []*ServiceInfo\r\n\t\r\n\tfor _, service := range sd.registry.services {\r\n\t\tif matchesQuery(service, query) {\r\n\t\t\tresults = append(results, service)\r\n\t\t}\r\n\t}\r\n\r\n\treturn results, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 51,
          "code_snippet": "    46 | \t\r\n    47 | \t// Simple string matching - could be enhanced with regex or fuzzy matching\r\n    48 | \treturn fmt.Sprintf(\"%s %s %s\", \r\n    49 | \t\tservice.Name, \r\n    50 | \t\tservice.Type, \r\nâ†’   51 | \t\tservice.Description) == query\r\n    52 | }\r\n    53 | \r\n    54 | // WatchServices watches for changes in services\r\n    55 | func (sd *ServiceDiscovery) WatchServices(ctx context.Context) (\u003c-chan *ServiceEvent, error) {\r\n    56 | \teventChan := make(chan *ServiceEvent, 100)\r\n",
          "full_function": "func matchesQuery(service *ServiceInfo, query string) bool {\r\n\tif query == \"\" {\r\n\t\treturn true\r\n\t}\r\n\t\r\n\t// Simple string matching - could be enhanced with regex or fuzzy matching\r\n\treturn fmt.Sprintf(\"%s %s %s\", \r\n\t\tservice.Name, \r\n\t\tservice.Type, \r\n\t\tservice.Description) == query\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\service_registry.go",
          "line_number": 33,
          "code_snippet": "    28 | // RegisterService registers a new service\r\n    29 | func (sr *ServiceRegistry) RegisterService(ctx context.Context, service *ServiceInfo) error {\r\n    30 | \tsr.mu.Lock()\r\n    31 | \tdefer sr.mu.Unlock()\r\n    32 | \r\nâ†’   33 | \tservice.LastChecked = time.Now()\r\n    34 | \tsr.services[service.ID] = service\r\n    35 | \t\r\n    36 | \tsr.logger.Info(\"Service registered\",\r\n    37 | \t\tzap.String(\"id\", service.ID),\r\n    38 | \t\tzap.String(\"name\", service.Name),\r\n",
          "full_function": "func (sr *ServiceRegistry) RegisterService(ctx context.Context, service *ServiceInfo) error {\r\n\tsr.mu.Lock()\r\n\tdefer sr.mu.Unlock()\r\n\r\n\tservice.LastChecked = time.Now()\r\n\tsr.services[service.ID] = service\r\n\t\r\n\tsr.logger.Info(\"Service registered\",\r\n\t\tzap.String(\"id\", service.ID),\r\n\t\tzap.String(\"name\", service.Name),\r\n\t\tzap.String(\"type\", service.Type))\r\n\t\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\service_registry.go",
          "line_number": 96,
          "code_snippet": "    91 | \tif !exists {\r\n    92 | \t\treturn fmt.Errorf(\"service %s not found\", serviceID)\r\n    93 | \t}\r\n    94 | \r\n    95 | \tservice.Status = status\r\nâ†’   96 | \tservice.LastChecked = time.Now()\r\n    97 | \t\r\n    98 | \tsr.logger.Info(\"Service status updated\",\r\n    99 | \t\tzap.String(\"id\", serviceID),\r\n   100 | \t\tzap.String(\"status\", status))\r\n   101 | \t\r\n",
          "full_function": "func (sr *ServiceRegistry) UpdateServiceStatus(ctx context.Context, serviceID, status string) error {\r\n\tsr.mu.Lock()\r\n\tdefer sr.mu.Unlock()\r\n\r\n\tservice, exists := sr.services[serviceID]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"service %s not found\", serviceID)\r\n\t}\r\n\r\n\tservice.Status = status\r\n\tservice.LastChecked = time.Now()\r\n\t\r\n\tsr.logger.Info(\"Service status updated\",\r\n\t\tzap.String(\"id\", serviceID),\r\n\t\tzap.String(\"status\", status))\r\n\t\r\n\treturn nil\r\n}",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 125,
          "code_snippet": "   120 | \ttemplateInfo := \u0026TemplateInfo{\r\n   121 | \t\tName:         manifest.Name,\r\n   122 | \t\tStack:        manifest.Stack,\r\n   123 | \t\tVersion:      manifest.Version,\r\n   124 | \t\tSummary:      manifest.Summary,\r\nâ†’  125 | \t\tPlaceholders: manifest.Placeholders,\r\n   126 | \t\tFiles:        manifest.Files,\r\n   127 | \t\tMetadata:     make(map[string]string),\r\n   128 | \t}\r\n   129 | \r\n   130 | \treturn templateInfo, nil\r\n",
          "full_function": "\t\tPlaceholders: manifest.Placeholders,\r\n\t\tFiles:        manifest.Files,\r\n\t\tMetadata:     make(map[string]string),\r\n\t}\r\n\r\n\treturn templateInfo, nil\r\n}\r\n\r\n// GetTemplate returns a template by name\r\nfunc (tr *TemplateRegistry) GetTemplate(name string) (*TemplateInfo, error) {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplate, exists := tr.templates[name]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"template '%s' not found\", name)\r\n\t}\r\n\r\n\treturn template, nil\r\n}\r\n\r\n// ListTemplates returns all registered templates\r\nfunc (tr *TemplateRegistry) ListTemplates() []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplates := make([]*TemplateInfo, 0, len(tr.templates))\r\n\tfor _, template := range tr.templates {\r\n\t\ttemplates = append(templates, template)\r\n\t}\r\n\r\n\treturn templates\r\n}\r\n\r\n// ListTemplatesByStack returns templates filtered by stack\r\nfunc (tr *TemplateRegistry) ListTemplatesByStack(stack string) []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\tvar templates []*TemplateInfo\r\n\tfor _, template := range tr.templates {\r\n\t\tif template.Stack == stack {\r\n\t\t\ttemplates = append(templates, template)\r\n\t\t}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\redis\\reservation_lock.go",
          "line_number": 55,
          "code_snippet": "    50 | // ReleaseLock releases a distributed lock\r\n    51 | func (l *ReservationLock) ReleaseLock(ctx context.Context, key string) error {\r\n    52 | \tlockKey := lockKey(key)\r\n    53 | \r\n    54 | \t// Lua script for atomic lock release (only if we own it)\r\nâ†’   55 | \tscript := `\r\n    56 | \t\tif redis.call(\"get\", KEYS[1]) == ARGV[1] then\r\n    57 | \t\t\treturn redis.call(\"del\", KEYS[1])\r\n    58 | \t\telse\r\n    59 | \t\t\treturn 0\r\n    60 | \t\tend\r\n",
          "full_function": "func (l *ReservationLock) ReleaseLock(ctx context.Context, key string) error {\r\n\tlockKey := lockKey(key)\r\n\r\n\t// Lua script for atomic lock release (only if we own it)\r\n\tscript := `\r\n\t\tif redis.call(\"get\", KEYS[1]) == ARGV[1] then\r\n\t\t\treturn redis.call(\"del\", KEYS[1])\r\n\t\telse\r\n\t\t\treturn 0\r\n\t\tend\r\n\t`\r\n\r\n\t// Note: In a real implementation, we'd need to store the lock value\r\n\t// to properly release it. For simplicity, we'll use a simpler approach.\r\n\t_, err := l.client.Del(ctx, lockKey).Result()\r\n\treturn err\r\n}\r",
          "symbol_name": "",
          "package_name": "redis",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "github.com/go-redis/redis/v8"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\cmd\\tools-validator\\main.go",
          "line_number": 60,
          "code_snippet": "    55 | \t\tresult, err = validator.ValidateTemplate(ctx, req)\r\n    56 | \r\n    57 | \tcase \"config\":\r\n    58 | \t\treq := validators.ConfigValidateRequest{\r\n    59 | \t\t\tPath:       path,\r\nâ†’   60 | \t\t\tStrictMode: strictMode,\r\n    61 | \t\t}\r\n    62 | \t\tvalidator := validators.NewConfigValidator()\r\n    63 | \t\tresult, err = validator.ValidateConfig(ctx, req)\r\n    64 | \r\n    65 | \tcase \"code\":\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "encoding/json",
            "flag",
            "fmt",
            "os",
            "github.com/vertikon/mcp-core-inventory/tools/validators"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\memory_optimizer.go",
          "line_number": 31,
          "code_snippet": "    26 | \r\n    27 | // EvictionPolicy represents different eviction strategies\r\n    28 | type EvictionPolicy string\r\n    29 | \r\n    30 | const (\r\nâ†’   31 | \tPolicyLRU      EvictionPolicy = \"lru\"\r\n    32 | \tPolicyLFU      EvictionPolicy = \"lfu\"\r\n    33 | \tPolicyFIFO     EvictionPolicy = \"fifo\"\r\n    34 | \tPolicyRandom   EvictionPolicy = \"random\"\r\n    35 | \tPolicyTTL      EvictionPolicy = \"ttl\"\r\n    36 | )\r\n",
          "full_function": "\tPolicyLRU      EvictionPolicy = \"lru\"\r\n\tPolicyLFU      EvictionPolicy = \"lfu\"\r\n\tPolicyFIFO     EvictionPolicy = \"fifo\"\r\n\tPolicyRandom   EvictionPolicy = \"random\"\r\n\tPolicyTTL      EvictionPolicy = \"ttl\"\r\n)\r\n\r\n// MemoryPool represents a pooled memory allocator\r\ntype MemoryPool struct {\r\n\tconfig         MemoryOptimizerConfig\r\n\tpools          map[int]*MemorySegment\r\n\tfreeSegments   chan *MemorySegment\r\n\tusedSegments   map[string]*MemorySegment\r\n\tsegmentsMu     sync.RWMutex\r\n\tstats          *MemoryPoolStats\r\n\tcompactor      *MemoryCompactor\r\n\tgarbageCollector *GarbageCollector\r\n\tctx            context.Context\r\n\tcancel         context.CancelFunc\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\core\\crush\\batch_processor.go",
          "line_number": 155,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\memory_optimizer.go",
          "line_number": 395,
          "code_snippet": "   390 | \t\t\tcontinue\r\n   391 | \t\t}\r\n   392 | \r\n   393 | \t\t// Check based on policy\r\n   394 | \t\tswitch mo.config.EvictionPolicy {\r\nâ†’  395 | \t\tcase PolicyLRU:\r\n   396 | \t\t\t// Will be sorted by LastUsed\r\n   397 | \t\tcase PolicyLFU:\r\n   398 | \t\t\t// Will be sorted by AccessCount\r\n   399 | \t\tcase PolicyTTL:\r\n   400 | \t\t\t// Already handled\r\n",
          "full_function": "\t\tcase PolicyLRU:\r\n\t\t\t// Will be sorted by LastUsed\r\n\t\tcase PolicyLFU:\r\n\t\t\t// Will be sorted by AccessCount\r\n\t\tcase PolicyTTL:\r\n\t\t\t// Already handled\r\n\t\t}\r\n\t}\r\n\r\n\t// Sort candidates based on eviction policy\r\n\tmo.sortEvictionCandidates(candidates)\r\n\r\n\t// Evict candidates (remove oldest 20%)\r\n\tevictCount := max(1, len(candidates)/5)\r\n\tfor i := 0; i \u003c evictCount \u0026\u0026 i \u003c len(candidates); i++ {\r\n\t\tsegment := candidates[i]\r\n\t\tdelete(mo.usedSegments, segment.ID)\r\n\t\t\r\n\t\t// Add to free pool\r\n\t\tselect {\r\n\t\tcase mo.freeSegments \u003c- segment:\r\n\t\tdefault:\r\n\t\t}\r\n\t\t\r\n\t\tatomic.AddInt64(\u0026mo.stats.Evictions, 1)\r\n\t\t\r\n\t\tlogger.Debug(\"Evicted memory segment\",\r\n\t\t\tzap.String(\"segment_id\", segment.ID),\r\n\t\t\tzap.Int(\"size\", segment.Size),\r\n\t\t)\r\n\t}\r\n}\r\n\r\n// sortEvictionCandidates sorts candidates based on eviction policy\r\nfunc (mo *MemoryPool) sortEvictionCandidates(candidates []*MemorySegment) {\r\n\tswitch mo.config.EvictionPolicy {\r\n\tcase PolicyLRU:\r\n\t\t// Sort by LastUsed (oldest first)\r\n\t\tfor i := 0; i \u003c len(candidates)-1; i++ {\r\n\t\t\tfor j := i + 1; j \u003c len(candidates); j++ {\r\n\t\t\t\tif candidates[i].LastUsed.After(candidates[j].LastUsed) {\r\n\t\t\t\t\tcandidates[i], candidates[j] = candidates[j], candidates[i]\r\n\t\t\t\t}\r\n\t\t\t}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 625,
          "code_snippet": "   620 | \tas.stats.ScaleDownEvents++\r\n   621 | \tnow := time.Now()\r\n   622 | \tas.stats.LastScalingTime = \u0026now\r\n   623 | }\r\n   624 | \r\nâ†’  625 | func min(a, b int) int {\r\n   626 | \tif a \u003c b {\r\n   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n",
          "full_function": "func min(a, b int) int {\r\n\tif a \u003c b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\core\\crush\\batch_processor.go",
          "line_number": 796,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 632,
          "code_snippet": "   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n   631 | \r\nâ†’  632 | func max(a, b int) int {\r\n   633 | \tif a \u003e b {\r\n   634 | \t\treturn a\r\n   635 | \t}\r\n   636 | \treturn b\r\n   637 | }\n",
          "full_function": "func max(a, b int) int {\r\n\tif a \u003e b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\core\\crush\\batch_processor.go",
          "line_number": 803,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 269,
          "code_snippet": "   264 | \r\n   265 | \t// Initialize async processor\r\n   266 | \tif config.EnableAsync {\r\n   267 | \t\tprocessor.asyncProcessor = NewAsyncBatchProcessor(AsyncProcessingConfig{\r\n   268 | \t\t\tEnabled:       true,\r\nâ†’  269 | \t\t\tNumWorkers:    runtime.NumCPU(),\r\n   270 | \t\t\tQueueSize:     100,\r\n   271 | \t\t\tWorkerTimeout: config.Timeout,\r\n   272 | \t\t\tRetryAttempts: 3,\r\n   273 | \t\t})\r\n   274 | \t}\r\n",
          "full_function": "func NewBatchProcessor(config BatchProcessorConfig) *BatchProcessor {\r\n\tif config.MaxBatchSize == 0 {\r\n\t\tconfig.MaxBatchSize = 32\r\n\t}\r\n\tif config.MinBatchSize == 0 {\r\n\t\tconfig.MinBatchSize = 1\r\n\t}\r\n\tif config.Timeout == 0 {\r\n\t\tconfig.Timeout = 5 * time.Second\r\n\t}\r\n\r\n\tlogger.Info(\"Creating batch processor\",\r\n\t\tzap.Int(\"max_batch_size\", config.MaxBatchSize),\r\n\t\tzap.Int(\"min_batch_size\", config.MinBatchSize),\r\n\t\tzap.Duration(\"timeout\", config.Timeout),\r\n\t\tzap.Bool(\"dynamic_batching\", config.EnableDynamicBatching),\r\n\t\tzap.Bool(\"prefetch\", config.EnablePrefetch),\r\n\t\tzap.Bool(\"async\", config.EnableAsync),\r\n\t)\r\n\r\n\tctx, cancel := context.WithCancel(context.Background())\r\n\t\r\n\tprocessor := \u0026BatchProcessor{\r\n\t\tconfig:      config,\r\n\t\tbatches:     make(map[string]*Batch),\r\n\t\tbatchQueue:  make(chan *Batch, 100),\r\n\t\tresultQueue: make(chan *BatchResult, 100),\r\n\t\tctx:         ctx,\r\n\t\tcancel:      cancel,\r\n\t\tstats:       \u0026BatchProcessorStats{},\r\n\t}\r\n\r\n\t// Initialize dynamic sizing\r\n\tif config.EnableDynamicBatching {\r\n\t\tprocessor.dynamicSizing = NewDynamicBatchSizer(DynamicSizingConfig{\r\n\t\t\tEnabled:   true,\r\n\t\t\tStrategy:  StrategyAdaptive,\r\n\t\t\tMinSize:   config.MinBatchSize,\r\n\t\t\tMaxSize:   config.MaxBatchSize,\r\n\t\t\tTargetLatency: config.MaxLatency,\r\n\t\t})\r\n\t}\r\n\r\n\t// Initialize prefetcher\r\n\tif config.EnablePrefetch {\r\n\t\tprocessor.prefetcher = NewBatchPrefetcher(PrefetchConfig{\r\n\t\t\tEnabled:      true,\r\n\t\t\tPrefetchSize: config.MaxBatchSize,\r\n\t\t\tCacheSize:    100,\r\n\t\t\tPrefetchPolicy: PolicyPredictive,\r\n\t\t})\r\n\t}\r\n\r\n\t// Initialize async processor\r\n\tif config.EnableAsync {\r\n\t\tprocessor.asyncProcessor = NewAsyncBatchProcessor(AsyncProcessingConfig{\r\n\t\t\tEnabled:       true,\r\n\t\t\tNumWorkers:    runtime.NumCPU(),\r\n\t\t\tQueueSize:     100,\r\n\t\t\tWorkerTimeout: config.Timeout,\r\n\t\t\tRetryAttempts: 3,\r\n\t\t})\r\n\t}\r\n\r\n\treturn processor\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 427,
          "code_snippet": "   422 | func (bp *BatchProcessor) checkBatchTimeouts() {\r\n   423 | \tbp.mu.Lock()\r\n   424 | \tdefer bp.mu.Unlock()\r\n   425 | \r\n   426 | \tnow := time.Now()\r\nâ†’  427 | \tfor id, batch := range bp.batches {\r\n   428 | \t\tif now.Sub(batch.CreatedAt) \u003e= batch.Timeout \u0026\u0026 len(batch.Items) \u003e 0 {\r\n   429 | \t\t\tbp.submitBatch(batch)\r\n   430 | \t\t}\r\n   431 | \t}\r\n   432 | }\r\n",
          "full_function": "func (bp *BatchProcessor) checkBatchTimeouts() {\r\n\tbp.mu.Lock()\r\n\tdefer bp.mu.Unlock()\r\n\r\n\tnow := time.Now()\r\n\tfor id, batch := range bp.batches {\r\n\t\tif now.Sub(batch.CreatedAt) \u003e= batch.Timeout \u0026\u0026 len(batch.Items) \u003e 0 {\r\n\t\t\tbp.submitBatch(batch)\r\n\t\t}\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 560,
          "code_snippet": "   555 | // updateStats updates batch processing statistics\r\n   556 | func (bp *BatchProcessor) updateStats(batch *Batch, result *BatchResult) {\r\n   557 | \tatomic.AddInt64(\u0026bp.stats.TotalBatches, 1)\r\n   558 | \tatomic.AddInt64(\u0026bp.stats.TotalItems, int64(batch.Size))\r\n   559 | \tatomic.AddInt64(\u0026bp.stats.CompletedBatches, 1)\r\nâ†’  560 | \tatomic.AddInt64(\u0026bp.stats.TotalProcessingTime, int64(result.Duration))\r\n   561 | \r\n   562 | \tif len(result.Errors) \u003e 0 {\r\n   563 | \t\tatomic.AddInt64(\u0026bp.stats.FailedBatches, 1)\r\n   564 | \t}\r\n   565 | }\r\n",
          "full_function": "func (bp *BatchProcessor) updateStats(batch *Batch, result *BatchResult) {\r\n\tatomic.AddInt64(\u0026bp.stats.TotalBatches, 1)\r\n\tatomic.AddInt64(\u0026bp.stats.TotalItems, int64(batch.Size))\r\n\tatomic.AddInt64(\u0026bp.stats.CompletedBatches, 1)\r\n\tatomic.AddInt64(\u0026bp.stats.TotalProcessingTime, int64(result.Duration))\r\n\r\n\tif len(result.Errors) \u003e 0 {\r\n\t\tatomic.AddInt64(\u0026bp.stats.FailedBatches, 1)\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 584,
          "code_snippet": "   579 | \t\tbp.stats.AvgBatchSize = float64(totalItems) / float64(totalBatches)\r\n   580 | \t}\r\n   581 | \r\n   582 | \t// Calculate average processing time\r\n   583 | \tcompletedBatches := atomic.LoadInt64(\u0026bp.stats.CompletedBatches)\r\nâ†’  584 | \ttotalProcessingTime := atomic.LoadInt64(\u0026bp.stats.TotalProcessingTime)\r\n   585 | \t\r\n   586 | \tif completedBatches \u003e 0 {\r\n   587 | \t\tbp.stats.AvgProcessingTime = time.Duration(totalProcessingTime / completedBatches)\r\n   588 | \t}\r\n   589 | \r\n",
          "full_function": "func (bp *BatchProcessor) collectStats() {\r\n\tbp.stats.LastUpdated = time.Now()\r\n\r\n\t// Calculate queue utilization\r\n\tbp.stats.QueueUtilization = float64(len(bp.batchQueue)) / float64(cap(bp.batchQueue))\r\n\r\n\t// Calculate average batch size\r\n\ttotalBatches := atomic.LoadInt64(\u0026bp.stats.TotalBatches)\r\n\ttotalItems := atomic.LoadInt64(\u0026bp.stats.TotalItems)\r\n\t\r\n\tif totalBatches \u003e 0 {\r\n\t\tbp.stats.AvgBatchSize = float64(totalItems) / float64(totalBatches)\r\n\t}\r\n\r\n\t// Calculate average processing time\r\n\tcompletedBatches := atomic.LoadInt64(\u0026bp.stats.CompletedBatches)\r\n\ttotalProcessingTime := atomic.LoadInt64(\u0026bp.stats.TotalProcessingTime)\r\n\t\r\n\tif completedBatches \u003e 0 {\r\n\t\tbp.stats.AvgProcessingTime = time.Duration(totalProcessingTime / completedBatches)\r\n\t}\r\n\r\n\t// Calculate throughput\r\n\tif completedBatches \u003e 0 {\r\n\t\tbp.stats.Throughput = float64(totalItems) / time.Since(time.Now()).Seconds()\r\n\t}\r\n\r\n\tlogger.Debug(\"Batch processor stats\",\r\n\t\tzap.Float64(\"queue_utilization\", bp.stats.QueueUtilization),\r\n\t\tzap.Float64(\"avg_batch_size\", bp.stats.AvgBatchSize),\r\n\t\tzap.Duration(\"avg_processing_time\", bp.stats.AvgProcessingTime),\r\n\t\tzap.Float64(\"throughput\", bp.stats.Throughput),\r\n\t)\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 781,
          "code_snippet": "   776 | \r\n   777 | // NewAsyncBatchProcessor creates a new async batch processor\r\n   778 | func NewAsyncBatchProcessor(config AsyncProcessingConfig) *AsyncBatchProcessor {\r\n   779 | \treturn \u0026AsyncBatchProcessor{\r\n   780 | \t\tconfig:     config,\r\nâ†’  781 | \t\tworkerPool: NewWorkerPool(config.NumWorkers, config.QueueSize, config.WorkerTimeout),\r\n   782 | \t\tstats:      \u0026AsyncProcessingStats{},\r\n   783 | \t}\r\n   784 | }\r\n   785 | \r\n   786 | // Start starts async batch processor\r\n",
          "full_function": "func NewAsyncBatchProcessor(config AsyncProcessingConfig) *AsyncBatchProcessor {\r\n\treturn \u0026AsyncBatchProcessor{\r\n\t\tconfig:     config,\r\n\t\tworkerPool: NewWorkerPool(config.NumWorkers, config.QueueSize, config.WorkerTimeout),\r\n\t\tstats:      \u0026AsyncProcessingStats{},\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 792,
          "code_snippet": "   787 | func (abp *AsyncBatchProcessor) Start(ctx context.Context) {\r\n   788 | \tif !abp.config.Enabled {\r\n   789 | \t\treturn\r\n   790 | \t}\r\n   791 | \r\nâ†’  792 | \tabp.workerPool.Start(ctx)\r\n   793 | }\r\n   794 | \r\n   795 | // Additional helper functions\r\n   796 | func min(a, b int) int {\r\n   797 | \tif a \u003c b {\r\n",
          "full_function": "func (abp *AsyncBatchProcessor) Start(ctx context.Context) {\r\n\tif !abp.config.Enabled {\r\n\t\treturn\r\n\t}\r\n\r\n\tabp.workerPool.Start(ctx)\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\memory_optimizer.go",
          "line_number": 395,
          "code_snippet": "   390 | \t\t\tcontinue\r\n   391 | \t\t}\r\n   392 | \r\n   393 | \t\t// Check based on policy\r\n   394 | \t\tswitch mo.config.EvictionPolicy {\r\nâ†’  395 | \t\tcase PolicyLRU:\r\n   396 | \t\t\t// Will be sorted by LastUsed\r\n   397 | \t\tcase PolicyLFU:\r\n   398 | \t\t\t// Will be sorted by AccessCount\r\n   399 | \t\tcase PolicyTTL:\r\n   400 | \t\t\t// Already handled\r\n",
          "full_function": "\t\tcase PolicyLRU:\r\n\t\t\t// Will be sorted by LastUsed\r\n\t\tcase PolicyLFU:\r\n\t\t\t// Will be sorted by AccessCount\r\n\t\tcase PolicyTTL:\r\n\t\t\t// Already handled\r\n\t\t}\r\n\t}\r\n\r\n\t// Sort candidates based on eviction policy\r\n\tmo.sortEvictionCandidates(candidates)\r\n\r\n\t// Evict candidates (remove oldest 20%)\r\n\tevictCount := max(1, len(candidates)/5)\r\n\tfor i := 0; i \u003c evictCount \u0026\u0026 i \u003c len(candidates); i++ {\r\n\t\tsegment := candidates[i]\r\n\t\tdelete(mo.usedSegments, segment.ID)\r\n\t\t\r\n\t\t// Add to free pool\r\n\t\tselect {\r\n\t\tcase mo.freeSegments \u003c- segment:\r\n\t\tdefault:\r\n\t\t}\r\n\t\t\r\n\t\tatomic.AddInt64(\u0026mo.stats.Evictions, 1)\r\n\t\t\r\n\t\tlogger.Debug(\"Evicted memory segment\",\r\n\t\t\tzap.String(\"segment_id\", segment.ID),\r\n\t\t\tzap.Int(\"size\", segment.Size),\r\n\t\t)\r\n\t}\r\n}\r\n\r\n// sortEvictionCandidates sorts candidates based on eviction policy\r\nfunc (mo *MemoryPool) sortEvictionCandidates(candidates []*MemorySegment) {\r\n\tswitch mo.config.EvictionPolicy {\r\n\tcase PolicyLRU:\r\n\t\t// Sort by LastUsed (oldest first)\r\n\t\tfor i := 0; i \u003c len(candidates)-1; i++ {\r\n\t\t\tfor j := i + 1; j \u003c len(candidates); j++ {\r\n\t\t\t\tif candidates[i].LastUsed.After(candidates[j].LastUsed) {\r\n\t\t\t\t\tcandidates[i], candidates[j] = candidates[j], candidates[i]\r\n\t\t\t\t}\r\n\t\t\t}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\domain\\services\\ai_domain_service.go",
          "line_number": 33,
          "code_snippet": "    28 | \tcontext := mcp.Context()\r\n    29 | \tif context == nil {\r\n    30 | \t\treturn fmt.Errorf(\"knowledge context is nil\")\r\n    31 | \t}\r\n    32 | \r\nâ†’   33 | \tif len(context.documents) == 0 {\r\n    34 | \t\treturn fmt.Errorf(\"knowledge context must have at least one document\")\r\n    35 | \t}\r\n    36 | \r\n    37 | \treturn nil\r\n    38 | }\r\n",
          "full_function": "func (s *AIDomainService) ValidateKnowledgeContext(mcp *entities.MCP) error {\r\n\tif mcp == nil {\r\n\t\treturn fmt.Errorf(\"MCP cannot be nil\")\r\n\t}\r\n\r\n\tif !mcp.HasContext() {\r\n\t\treturn fmt.Errorf(\"MCP does not have knowledge context\")\r\n\t}\r\n\r\n\tcontext := mcp.Context()\r\n\tif context == nil {\r\n\t\treturn fmt.Errorf(\"knowledge context is nil\")\r\n\t}\r\n\r\n\tif len(context.documents) == 0 {\r\n\t\treturn fmt.Errorf(\"knowledge context must have at least one document\")\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "services",
          "dependencies": [
            "fmt",
            "github.com/vertikon/mcp-core-inventory/internal/domain/entities"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 543,
          "code_snippet": "   538 | \t}\r\n   539 | \r\n   540 | \tstart := time.Now()\r\n   541 | \tdefer func() {\r\n   542 | \t\tatomic.AddInt64(\u0026dss.stats.LockOperations, 1)\r\nâ†’  543 | \t\tatomic.StoreInt64(\u0026dss.stats.LockWaitTime.Nanoseconds(), time.Since(start).Nanoseconds())\r\n   544 | \t}()\r\n   545 | \r\n   546 | \t// Try remote store first\r\n   547 | \tlock, err := dss.remoteStore.Lock(ctx, key, ttl)\r\n   548 | \tif err == nil {\r\n",
          "full_function": "func (dss *DistributedStateStore) Lock(ctx context.Context, key string, ttl time.Duration) (*Lock, error) {\r\n\tif !dss.config.EnableLocking {\r\n\t\treturn nil, fmt.Errorf(\"locking is not enabled\")\r\n\t}\r\n\r\n\tstart := time.Now()\r\n\tdefer func() {\r\n\t\tatomic.AddInt64(\u0026dss.stats.LockOperations, 1)\r\n\t\tatomic.StoreInt64(\u0026dss.stats.LockWaitTime.Nanoseconds(), time.Since(start).Nanoseconds())\r\n\t}()\r\n\r\n\t// Try remote store first\r\n\tlock, err := dss.remoteStore.Lock(ctx, key, ttl)\r\n\tif err == nil {\r\n\t\treturn lock, nil\r\n\t}\r\n\r\n\t// Fallback to local store\r\n\treturn dss.localStore.Lock(ctx, key, ttl)\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 649,
          "code_snippet": "   644 | \treturn *dss.stats\r\n   645 | }\r\n   646 | \r\n   647 | // updateReadLatency updates read latency statistics\r\n   648 | func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\nâ†’  649 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n   650 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n   651 | \tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n   652 | }\r\n   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n",
          "full_function": "func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 651,
          "code_snippet": "   646 | \r\n   647 | // updateReadLatency updates read latency statistics\r\n   648 | func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\n   649 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n   650 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\nâ†’  651 | \tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n   652 | }\r\n   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n   655 | func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n   656 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n",
          "full_function": "func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 656,
          "code_snippet": "   651 | \tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n   652 | }\r\n   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n   655 | func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\nâ†’  656 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n   657 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n   658 | \tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n   659 | }\r\n   660 | \r\n   661 | // NewMemoryStateStore creates a new in-memory state store\r\n",
          "full_function": "func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 658,
          "code_snippet": "   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n   655 | func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n   656 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n   657 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\nâ†’  658 | \tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n   659 | }\r\n   660 | \r\n   661 | // NewMemoryStateStore creates a new in-memory state store\r\n   662 | func NewMemoryStateStore() *MemoryStateStore {\r\n   663 | \treturn \u0026MemoryStateStore{\r\n",
          "full_function": "func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\store.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"context\"\r\n     6 | \t\"encoding/json\"\r\n     7 | \t\"time\"\r\n     8 | \r\n     9 | \t\"github.com/dgraph-io/badger/v4\"\r\nâ†’   10 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n    11 | \t\"go.uber.org/zap\"\r\n    12 | )\r\n    13 | \r\n    14 | // Store provides persistent state storage using BadgerDB\r\n    15 | type Store struct {\r\n",
          "full_function": "\t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n\t\"go.uber.org/zap\"\r\n)\r\n\r\n// Store provides persistent state storage using BadgerDB\r\ntype Store struct {\r\n\tdb *badger.DB\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "time",
            "github.com/dgraph-io/badger/v4",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\store.go",
          "line_number": 11,
          "code_snippet": "     6 | \t\"encoding/json\"\r\n     7 | \t\"time\"\r\n     8 | \r\n     9 | \t\"github.com/dgraph-io/badger/v4\"\r\n    10 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\nâ†’   11 | \t\"go.uber.org/zap\"\r\n    12 | )\r\n    13 | \r\n    14 | // Store provides persistent state storage using BadgerDB\r\n    15 | type Store struct {\r\n    16 | \tdb *badger.DB\r\n",
          "full_function": "\t\"go.uber.org/zap\"\r\n)\r\n\r\n// Store provides persistent state storage using BadgerDB\r\ntype Store struct {\r\n\tdb *badger.DB\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "time",
            "github.com/dgraph-io/badger/v4",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\feedforward.go",
          "line_number": 194,
          "code_snippet": "   189 | }\r\n   190 | \r\n   191 | // forwardMoE performs mixture of experts computation\r\n   192 | func (ffn *FeedForwardNetwork) forwardMoE(ctx context.Context, input *Tensor) (*Tensor, error) {\r\n   193 | \t// Router determines which experts to use\r\nâ†’  194 | \trouter, err := ffn.router.Forward(input)\r\n   195 | \tif err != nil {\r\n   196 | \t\treturn nil, fmt.Errorf(\"routing error: %w\", err)\r\n   197 | \t}\r\n   198 | \r\n   199 | \t// Select top-k experts\r\n",
          "full_function": "func (ffn *FeedForwardNetwork) forwardMoE(ctx context.Context, input *Tensor) (*Tensor, error) {\r\n\t// Router determines which experts to use\r\n\trouter, err := ffn.router.Forward(input)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"routing error: %w\", err)\r\n\t}\r\n\r\n\t// Select top-k experts\r\n\tselectedExperts := ffn.selectTopKExperts(router)\r\n\r\n\t// Combine expert outputs\r\n\toutput := ffn.combineExperts(input, selectedExperts)\r\n\r\n\treturn output, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "math",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 152,
          "code_snippet": "   147 | \t\treturn nil, ctx.Err()\n   148 | \tdefault:\n   149 | \t}\n   150 | \n   151 | \t// Embedding layer\nâ†’  152 | \thidden, err := t.embeddings.Forward(input)\n   153 | \tif err != nil {\n   154 | \t\treturn nil, fmt.Errorf(\"embedding error: %w\", err)\n   155 | \t}\n   156 | \n   157 | \t// Add positional encoding\n",
          "full_function": "func (t *GLMTransformer) Forward(ctx context.Context, input *Tensor, attentionMask *Tensor) (*Tensor, error) {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\t// Embedding layer\n\thidden, err := t.embeddings.Forward(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"embedding error: %w\", err)\n\t}\n\n\t// Add positional encoding\n\tif t.posEncoding != nil {\n\t\tposEncoded, err := t.posEncoding.Forward(ctx, hidden, 0)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"positional encoding error: %w\", err)\n\t\t}\n\t\thidden = posEncoded\n\t}\n\n\t// Pass through transformer layers\n\tfor i, layer := range t.layers {\n\t\tselect {\n\t\tcase \u003c-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tlayerOutput, err := layer.Forward(ctx, hidden, attentionMask)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"layer %d error: %w\", i, err)\n\t\t}\n\t\thidden = layerOutput\n\n\t\tlogger.Debug(\"Transformer layer processed\",\n\t\t\tzap.Int(\"layer\", i),\n\t\t\tzap.Float64(\"mean_activation\", t.meanActivation(hidden)),\n\t\t)\n\t}\n\n\t// Final layer norm\n\toutput, err := t.layernorm.Forward(hidden)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"final layer norm error: %w\", err)\n\t}\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 209,
          "code_snippet": "   204 | \tnormInput, err := l.layernorm1.Forward(input)\n   205 | \tif err != nil {\n   206 | \t\treturn nil, fmt.Errorf(\"pre-norm error: %w\", err)\n   207 | \t}\n   208 | \nâ†’  209 | \tattnOutput, err := l.attention.Forward(ctx, normInput, normInput, normInput, attentionMask)\n   210 | \tif err != nil {\n   211 | \t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n   212 | \t}\n   213 | \n   214 | \t// Residual connection\n",
          "full_function": "func (l *TransformerLayer) Forward(ctx context.Context, input *Tensor, attentionMask *Tensor) (*Tensor, error) {\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\t// Pre-norm + attention\n\tnormInput, err := l.layernorm1.Forward(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"pre-norm error: %w\", err)\n\t}\n\n\tattnOutput, err := l.attention.Forward(ctx, normInput, normInput, normInput, attentionMask)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n\t}\n\n\t// Residual connection\n\tresidual1 := t.add(input, attnOutput)\n\n\t// Pre-norm + feed-forward\n\tnormResidual, err := l.layernorm2.Forward(residual1)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"post-norm error: %w\", err)\n\t}\n\n\tffOutput, err := l.feedForward.Forward(ctx, normResidual)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"feed-forward error: %w\", err)\n\t}\n\n\t// Residual connection\n\toutput := t.add(residual1, ffOutput)\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 215,
          "code_snippet": "   210 | \tif err != nil {\n   211 | \t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n   212 | \t}\n   213 | \n   214 | \t// Residual connection\nâ†’  215 | \tresidual1 := t.add(input, attnOutput)\n   216 | \n   217 | \t// Pre-norm + feed-forward\n   218 | \tnormResidual, err := l.layernorm2.Forward(residual1)\n   219 | \tif err != nil {\n   220 | \t\treturn nil, fmt.Errorf(\"post-norm error: %w\", err)\n",
          "full_function": "func (l *TransformerLayer) Forward(ctx context.Context, input *Tensor, attentionMask *Tensor) (*Tensor, error) {\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\t// Pre-norm + attention\n\tnormInput, err := l.layernorm1.Forward(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"pre-norm error: %w\", err)\n\t}\n\n\tattnOutput, err := l.attention.Forward(ctx, normInput, normInput, normInput, attentionMask)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n\t}\n\n\t// Residual connection\n\tresidual1 := t.add(input, attnOutput)\n\n\t// Pre-norm + feed-forward\n\tnormResidual, err := l.layernorm2.Forward(residual1)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"post-norm error: %w\", err)\n\t}\n\n\tffOutput, err := l.feedForward.Forward(ctx, normResidual)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"feed-forward error: %w\", err)\n\t}\n\n\t// Residual connection\n\toutput := t.add(residual1, ffOutput)\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 249,
          "code_snippet": "   244 | // Forward performs layer normalization\n   245 | func (ln *LayerNorm) Forward(input *Tensor) (*Tensor, error) {\n   246 | \t// Simplified layer norm implementation\n   247 | \tmean := t.mean(input, -1, true)\n   248 | \tvariance := t.variance(input, -1, true)\nâ†’  249 | \tnormalized := t.div(t.sub(input, mean), t.sqrt(t.add(variance, ln.eps)))\n   250 | \n   251 | \t// Scale and shift\n   252 | \toutput := t.mul(normalized, ln.weight)\n   253 | \toutput = t.add(output, ln.bias)\n   254 | \n",
          "full_function": "func (ln *LayerNorm) Forward(input *Tensor) (*Tensor, error) {\n\t// Simplified layer norm implementation\n\tmean := t.mean(input, -1, true)\n\tvariance := t.variance(input, -1, true)\n\tnormalized := t.div(t.sub(input, mean), t.sqrt(t.add(variance, ln.eps)))\n\n\t// Scale and shift\n\toutput := t.mul(normalized, ln.weight)\n\toutput = t.add(output, ln.bias)\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\positional_encoding.go",
          "line_number": 6,
          "code_snippet": "     1 | // Package transformer implements positional encoding for GLM-4.6\n     2 | package transformer\n     3 | \n     4 | import (\n     5 | \t\"context\"\nâ†’    6 | \t\"fmt\"\n     7 | \t\"math\"\n     8 | \t\"sync\"\n     9 | \t\"time\"\n    10 | \n    11 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\n",
          "full_function": "\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\n\t\"go.uber.org/zap\"\n)\n\n// PositionalEncodingType represents different positional encoding approaches\ntype PositionalEncodingType string\n\nconst (\n\tPosEncodingTypeSinusoidal PositionalEncodingType = \"sinusoidal\"\n\tPosEncodingTypeLearned    PositionalEncodingType = \"learned\"\n\tPosEncodingTypeRelative   PositionalEncodingType = \"relative\"\n\tPosEncodingTypeRotary     PositionalEncodingType = \"rotary\"\n\tPosEncodingTypeALiBi      PositionalEncodingType = \"alibi\"\n\tPosEncodingTypeXPos       PositionalEncodingType = \"xpos\"\n)\n\n// PositionalEncodingConfig represents positional encoding configuration\ntype PositionalEncodingConfig struct {\n\tType        PositionalEncodingType `json:\"type\"`\n\tMaxSeqLen   int                    `json:\"max_seq_len\"`\n\tHiddenSize  int                    `json:\"hidden_size\"`\n\tHeadDim     int                    `json:\"head_dim,omitempty\"`\n\tBase        float64                `json:\"base\"`\n\tScale       bool                   `json:\"scale\"`\n\tNormalize   bool                   `json:\"normalize\"`\n\tConcatenate bool                   `json:\"concatenate\"`\n\tRotateHalf  bool                   `json:\"rotate_half\"`\n\tUseRoPE     bool                   `json:\"use_rope\"`\n\tUseXPos     bool                   `json:\"use_xpos\"`\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "math",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\compute\\serverless\\cloud_functions.go",
          "line_number": 14,
          "code_snippet": "     9 | type CloudFunctions interface {\r\n    10 | \t// Invoke invokes a cloud function\r\n    11 | \tInvoke(ctx context.Context, functionName string, payload []byte) ([]byte, error)\r\n    12 | \r\n    13 | \t// CreateFunction creates a cloud function\r\nâ†’   14 | \tCreateFunction(ctx context.Context, config *FunctionConfig) error\r\n    15 | \r\n    16 | \t// DeleteFunction deletes a cloud function\r\n    17 | \tDeleteFunction(ctx context.Context, functionName string) error\r\n    18 | }\r\n    19 | \n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "serverless",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\messaging\\pubsub\\pubsub_client.go",
          "line_number": 9,
          "code_snippet": "     4 | import (\r\n     5 | \t\"context\"\r\n     6 | )\r\n     7 | \r\n     8 | // PubSubClient provides generic pub/sub interface\r\nâ†’    9 | type PubSubClient interface {\r\n    10 | \t// Publish publishes a message to a topic\r\n    11 | \tPublish(ctx context.Context, topic string, message []byte) error\r\n    12 | \r\n    13 | \t// Subscribe subscribes to a topic\r\n    14 | \tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n",
          "full_function": "type PubSubClient interface {\r\n\t// Publish publishes a message to a topic\r\n\tPublish(ctx context.Context, topic string, message []byte) error\r\n\r\n\t// Subscribe subscribes to a topic\r\n\tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n\r\n\t// Close closes the client connection\r\n\tClose() error\r\n}\r",
          "symbol_name": "",
          "package_name": "pubsub",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\infrastructure\\messaging\\pubsub\\nats_pubsub.go",
          "line_number": 9,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\messaging\\streaming\\nats_jetstream.go",
          "line_number": 178,
          "code_snippet": "   173 | \t\tRetention: config.Retention,\r\n   174 | \t}\r\n   175 | \r\n   176 | \t_, err := c.js.AddStream(streamConfig)\r\n   177 | \tif err != nil {\r\nâ†’  178 | \t\tif err == nats.ErrStreamNameExist {\r\n   179 | \t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", config.Name))\r\n   180 | \t\t\treturn nil\r\n   181 | \t\t}\r\n   182 | \t\treturn fmt.Errorf(\"failed to create stream %s: %w\", config.Name, err)\r\n   183 | \t}\r\n",
          "full_function": "func (c *natsJetStreamClient) CreateStream(ctx context.Context, config *StreamConfig) error {\r\n\tstreamConfig := \u0026nats.StreamConfig{\r\n\t\tName:      config.Name,\r\n\t\tSubjects:  config.Subjects,\r\n\t\tReplicas:  config.Replicas,\r\n\t\tMaxAge:    config.MaxAge,\r\n\t\tMaxBytes:  config.MaxBytes,\r\n\t\tMaxMsgs:   config.MaxMsgs,\r\n\t\tRetention: config.Retention,\r\n\t}\r\n\r\n\t_, err := c.js.AddStream(streamConfig)\r\n\tif err != nil {\r\n\t\tif err == nats.ErrStreamNameExist {\r\n\t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", config.Name))\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\treturn fmt.Errorf(\"failed to create stream %s: %w\", config.Name, err)\r\n\t}\r\n\r\n\tlogger.Info(\"Created stream\",\r\n\t\tzap.String(\"stream\", config.Name),\r\n\t\tzap.Strings(\"subjects\", config.Subjects),\r\n\t)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "streaming",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "time",
            "github.com/nats-io/nats.go",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go",
          "line_number": 87,
          "code_snippet": "    82 | \t\tSELECT id, name, description, documents, embeddings, version, created_at, updated_at\r\n    83 | \t\tFROM knowledge\r\n    84 | \t\tWHERE id = $1\r\n    85 | \t`\r\n    86 | \r\nâ†’   87 | \tvar knowledge entities.Knowledge\r\n    88 | \tvar documentsJSON, embeddingsJSON []byte\r\n    89 | \tvar name, description string\r\n    90 | \tvar version int\r\n    91 | \tvar createdAt, updatedAt time.Time\r\n    92 | \r\n",
          "full_function": "\tvar knowledge entities.Knowledge\r\n\tvar documentsJSON, embeddingsJSON []byte\r\n\tvar name, description string\r\n\tvar version int\r\n\tvar createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026id,\r\n\t\t\u0026name,\r\n\t\t\u0026description,\r\n\t\t\u0026documentsJSON,\r\n\t\t\u0026embeddingsJSON,\r\n\t\t\u0026version,\r\n\t\t\u0026createdAt,\r\n\t\t\u0026updatedAt,\r\n\t)\r\n\r\n\tif err == sql.ErrNoRows {\r\n\t\treturn nil, fmt.Errorf(\"Knowledge not found: %s\", id)\r\n\t}\r",
          "symbol_name": "",
          "package_name": "relational",
          "dependencies": [
            "context",
            "database/sql",
            "encoding/json",
            "fmt",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/entities",
            "github.com/vertikon/mcp-core-inventory/internal/domain/repositories",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go",
          "line_number": 204,
          "code_snippet": "   199 | \tknowledge, err := entities.NewKnowledge(name, description)\r\n   200 | \tif err != nil {\r\n   201 | \t\treturn nil, fmt.Errorf(\"failed to create Knowledge entity: %w\", err)\r\n   202 | \t}\r\n   203 | \r\nâ†’  204 | \treturn \u0026knowledge, nil\r\n   205 | }\r\n   206 | \r\n   207 | // List lists all Knowledge entities with optional filters\r\n   208 | func (r *PostgresKnowledgeRepository) List(ctx context.Context, filters *repositories.KnowledgeFilters) ([]*entities.Knowledge, error) {\r\n   209 | \tquery := \"SELECT id, name, description, documents, embeddings, version, created_at, updated_at FROM knowledge WHERE 1=1\"\r\n",
          "full_function": "\treturn \u0026knowledge, nil\r\n}\r\n\r\n// List lists all Knowledge entities with optional filters\r\nfunc (r *PostgresKnowledgeRepository) List(ctx context.Context, filters *repositories.KnowledgeFilters) ([]*entities.Knowledge, error) {\r\n\tquery := \"SELECT id, name, description, documents, embeddings, version, created_at, updated_at FROM knowledge WHERE 1=1\"\r\n\targs := []interface{}{}\r",
          "symbol_name": "",
          "package_name": "relational",
          "dependencies": [
            "context",
            "database/sql",
            "encoding/json",
            "fmt",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/entities",
            "github.com/vertikon/mcp-core-inventory/internal/domain/repositories",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\root.go",
          "line_number": 42,
          "code_snippet": "    37 | func init() {\r\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n    40 | \t\r\n    41 | \t// Add subcommand groups\r\nâ†’   42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n    43 | \trootCmd.AddCommand(ci.CICmd)\r\n    44 | }\r\n    45 | \r\n    46 | // GetRootCmd returns the root command (for testing)\r\n    47 | func GetRootCmd() *cobra.Command {\r\n",
          "full_function": "func init() {\r\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n\t\r\n\t// Add subcommand groups\r\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n\trootCmd.AddCommand(ci.CICmd)\r\n}\r",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\root.go",
          "line_number": 43,
          "code_snippet": "    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n    40 | \t\r\n    41 | \t// Add subcommand groups\r\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\r\nâ†’   43 | \trootCmd.AddCommand(ci.CICmd)\r\n    44 | }\r\n    45 | \r\n    46 | // GetRootCmd returns the root command (for testing)\r\n    47 | func GetRootCmd() *cobra.Command {\r\n    48 | \treturn rootCmd\r\n",
          "full_function": "func init() {\r\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n\t\r\n\t// Add subcommand groups\r\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n\trootCmd.AddCommand(ci.CICmd)\r\n}\r",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\tools\\deployers\\hybrid_deployer.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"fmt\"\r\n     6 | \t\"os\"\r\n     7 | \t\"path/filepath\"\r\n     8 | \t\"time\"\r\n     9 | \r\nâ†’   10 | \t\"github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes\"\r\n    11 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n    12 | \t\"go.uber.org/zap\"\r\n    13 | )\r\n    14 | \r\n    15 | // HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\r\n",
          "full_function": "\t\"github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes\"\r\n\t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n\t\"go.uber.org/zap\"\r\n)\r\n\r\n// HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\r\n// This deployer intelligently selects the best deployment strategy based on workload characteristics\r\ntype HybridDeployer struct {\r\n\tdockerDeployer     *DockerDeployer\r\n\tkubernetesDeployer *KubernetesDeployer\r\n\tserverlessDeployer *ServerlessDeployer\r\n\tlogger             *zap.Logger\r\n}\r",
          "symbol_name": "",
          "package_name": "deployers",
          "dependencies": [
            "context",
            "fmt",
            "os",
            "path/filepath",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 56,
          "code_snippet": "    51 | \t// Verify verifies a signature using RSA\r\n    52 | \tVerify(data, signature []byte, publicKey *rsa.PublicKey) bool\r\n    53 | }\r\n    54 | \r\n    55 | // Manager implements EncryptionManager\r\nâ†’   56 | type Manager struct {\r\n    57 | \tkeyManager KeyManager\r\n    58 | \tlogger     *zap.Logger\r\n    59 | }\r\n    60 | \r\n    61 | // NewEncryptionManager creates a new EncryptionManager\r\n",
          "full_function": "type Manager struct {\r\n\tkeyManager KeyManager\r\n\tlogger     *zap.Logger\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\security\\encryption\\certificate_manager.go",
          "line_number": 42,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 64,
          "code_snippet": "    59 | }\r\n    60 | \r\n    61 | // NewEncryptionManager creates a new EncryptionManager\r\n    62 | func NewEncryptionManager(keyManager KeyManager) EncryptionManager {\r\n    63 | \treturn \u0026Manager{\r\nâ†’   64 | \t\tkeyManager: keyManager,\r\n    65 | \t\tlogger:     logger.WithContext(nil),\r\n    66 | \t}\r\n    67 | }\r\n    68 | \r\n    69 | // Encrypt encrypts data using AES-256-GCM with default key\r\n",
          "full_function": "func NewEncryptionManager(keyManager KeyManager) EncryptionManager {\r\n\treturn \u0026Manager{\r\n\t\tkeyManager: keyManager,\r\n\t\tlogger:     logger.WithContext(nil),\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 71,
          "code_snippet": "    66 | \t}\r\n    67 | }\r\n    68 | \r\n    69 | // Encrypt encrypts data using AES-256-GCM with default key\r\n    70 | func (m *Manager) Encrypt(plaintext []byte) ([]byte, error) {\r\nâ†’   71 | \tkey, err := m.keyManager.GetEncryptionKey()\r\n    72 | \tif err != nil {\r\n    73 | \t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n    74 | \t\treturn nil, err\r\n    75 | \t}\r\n    76 | \treturn m.EncryptWithKey(plaintext, key)\r\n",
          "full_function": "func (m *Manager) Encrypt(plaintext []byte) ([]byte, error) {\r\n\tkey, err := m.keyManager.GetEncryptionKey()\r\n\tif err != nil {\r\n\t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n\t\treturn nil, err\r\n\t}\r\n\treturn m.EncryptWithKey(plaintext, key)\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 81,
          "code_snippet": "    76 | \treturn m.EncryptWithKey(plaintext, key)\r\n    77 | }\r\n    78 | \r\n    79 | // Decrypt decrypts data using AES-256-GCM with default key\r\n    80 | func (m *Manager) Decrypt(ciphertext []byte) ([]byte, error) {\r\nâ†’   81 | \tkey, err := m.keyManager.GetEncryptionKey()\r\n    82 | \tif err != nil {\r\n    83 | \t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n    84 | \t\treturn nil, err\r\n    85 | \t}\r\n    86 | \treturn m.DecryptWithKey(ciphertext, key)\r\n",
          "full_function": "func (m *Manager) Decrypt(ciphertext []byte) ([]byte, error) {\r\n\tkey, err := m.keyManager.GetEncryptionKey()\r\n\tif err != nil {\r\n\t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n\t\treturn nil, err\r\n\t}\r\n\treturn m.DecryptWithKey(ciphertext, key)\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 52,
          "code_snippet": "    47 | \t// LoadKeyFromFile loads key from file\r\n    48 | \tLoadKeyFromFile(filePath string) error\r\n    49 | }\r\n    50 | \r\n    51 | // Manager implements KeyManager\r\nâ†’   52 | type Manager struct {\r\n    53 | \tencryptionKey []byte\r\n    54 | \tkeyVersion    string\r\n    55 | \trsaPrivateKey *rsa.PrivateKey\r\n    56 | \trsaPublicKey  *rsa.PublicKey\r\n    57 | \trotationTTL  time.Duration\r\n",
          "full_function": "type Manager struct {\r\n\tencryptionKey []byte\r\n\tkeyVersion    string\r\n\trsaPrivateKey *rsa.PrivateKey\r\n\trsaPublicKey  *rsa.PublicKey\r\n\trotationTTL  time.Duration\r\n\tlastRotation  time.Time\r\n\tmu            sync.RWMutex\r\n\tlogger        *zap.Logger\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\security\\encryption\\certificate_manager.go",
          "line_number": 42,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 72,
          "code_snippet": "    67 | }\r\n    68 | \r\n    69 | // NewKeyManager creates a new KeyManager\r\n    70 | func NewKeyManager(config KeyManagerConfig) KeyManager {\r\n    71 | \tkm := \u0026Manager{\r\nâ†’   72 | \t\tkeyVersion:   \"v1\",\r\n    73 | \t\trotationTTL: config.RotationTTL,\r\n    74 | \t\tlogger:       logger.WithContext(nil),\r\n    75 | \t}\r\n    76 | \r\n    77 | \t// Generate initial encryption key\r\n",
          "full_function": "func NewKeyManager(config KeyManagerConfig) KeyManager {\r\n\tkm := \u0026Manager{\r\n\t\tkeyVersion:   \"v1\",\r\n\t\trotationTTL: config.RotationTTL,\r\n\t\tlogger:       logger.WithContext(nil),\r\n\t}\r\n\r\n\t// Generate initial encryption key\r\n\tkey := make([]byte, 32) // AES-256\r\n\tif _, err := rand.Read(key); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate encryption key\", zap.Error(err))\r\n\t} else {\r\n\t\tkm.encryptionKey = key\r\n\t}\r\n\r\n\t// Generate RSA key pair\r\n\tif err := km.generateRSAKeys(config.KeySize); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate RSA keys\", zap.Error(err))\r\n\t}\r\n\r\n\tkm.lastRotation = time.Now()\r\n\treturn km\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 82,
          "code_snippet": "    77 | \t// Generate initial encryption key\r\n    78 | \tkey := make([]byte, 32) // AES-256\r\n    79 | \tif _, err := rand.Read(key); err != nil {\r\n    80 | \t\tkm.logger.Error(\"Failed to generate encryption key\", zap.Error(err))\r\n    81 | \t} else {\r\nâ†’   82 | \t\tkm.encryptionKey = key\r\n    83 | \t}\r\n    84 | \r\n    85 | \t// Generate RSA key pair\r\n    86 | \tif err := km.generateRSAKeys(config.KeySize); err != nil {\r\n    87 | \t\tkm.logger.Error(\"Failed to generate RSA keys\", zap.Error(err))\r\n",
          "full_function": "func NewKeyManager(config KeyManagerConfig) KeyManager {\r\n\tkm := \u0026Manager{\r\n\t\tkeyVersion:   \"v1\",\r\n\t\trotationTTL: config.RotationTTL,\r\n\t\tlogger:       logger.WithContext(nil),\r\n\t}\r\n\r\n\t// Generate initial encryption key\r\n\tkey := make([]byte, 32) // AES-256\r\n\tif _, err := rand.Read(key); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate encryption key\", zap.Error(err))\r\n\t} else {\r\n\t\tkm.encryptionKey = key\r\n\t}\r\n\r\n\t// Generate RSA key pair\r\n\tif err := km.generateRSAKeys(config.KeySize); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate RSA keys\", zap.Error(err))\r\n\t}\r\n\r\n\tkm.lastRotation = time.Now()\r\n\treturn km\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 96,
          "code_snippet": "    91 | \treturn km\r\n    92 | }\r\n    93 | \r\n    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\nâ†’   96 | \tm.mu.RLock()\r\n    97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\n    99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 97,
          "code_snippet": "    92 | }\r\n    93 | \r\n    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n    96 | \tm.mu.RLock()\r\nâ†’   97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\n    99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n   102 | \r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 99,
          "code_snippet": "    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n    96 | \tm.mu.RLock()\r\n    97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\nâ†’   99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n   102 | \r\n   103 | \t// Check if rotation is needed\r\n   104 | \tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 99,
          "code_snippet": "    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n    96 | \tm.mu.RLock()\r\n    97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\nâ†’   99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n   102 | \r\n   103 | \t// Check if rotation is needed\r\n   104 | \tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 162,
          "code_snippet": "   157 | \tcm.stats.TotalInvalidations++\r\n   158 | \tcm.stats.InvalidationsByReason[reason]++\r\n   159 | \tcm.mu.Unlock()\r\n   160 | \r\n   161 | \t// Delete from cache\r\nâ†’  162 | \tcm.cache.Delete(key)\r\n   163 | \r\n   164 | \t// Create invalidation event\r\n   165 | \tevent := \u0026InvalidationEvent{\r\n   166 | \t\tKey:       key,\r\n   167 | \t\tReason:    reason,\r\n",
          "full_function": "func (cm *CoherencyManagerImpl) Invalidate(ctx context.Context, key string, reason string) error {\r\n\tstart := time.Now()\r\n\r\n\tcm.mu.Lock()\r\n\tcm.stats.TotalInvalidations++\r\n\tcm.stats.InvalidationsByReason[reason]++\r\n\tcm.mu.Unlock()\r\n\r\n\t// Delete from cache\r\n\tcm.cache.Delete(key)\r\n\r\n\t// Create invalidation event\r\n\tevent := \u0026InvalidationEvent{\r\n\t\tKey:       key,\r\n\t\tReason:    reason,\r\n\t\tTimestamp: time.Now(),\r\n\t\tSource:    \"coherency_manager\",\r\n\t}\r\n\r\n\t// Send to invalidation channel\r\n\tselect {\r\n\tcase cm.invalidationCh \u003c- event:\r\n\tdefault:\r\n\t\tcm.logger.Warn(\"Invalidation channel full, dropping event\",\r\n\t\t\tzap.String(\"key\", key))\r\n\t}\r\n\r\n\tcm.mu.Lock()\r\n\tcm.stats.AverageInvalidationTime = time.Since(start)\r\n\tlastTime := time.Now()\r\n\tcm.stats.LastInvalidation = \u0026lastTime\r\n\tcm.mu.Unlock()\r\n\r\n\tcm.logger.Debug(\"Cache key invalidated\",\r\n\t\tzap.String(\"key\", key),\r\n\t\tzap.String(\"reason\", reason))\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 217,
          "code_snippet": "   212 | }\r\n   213 | \r\n   214 | // Update updates a cache entry\r\n   215 | func (cm *CoherencyManagerImpl) Update(ctx context.Context, key string, value interface{}) error {\r\n   216 | \tcm.mu.Lock()\r\nâ†’  217 | \tcm.stats.TotalUpdates++\r\n   218 | \tcm.mu.Unlock()\r\n   219 | \r\n   220 | \t// Update cache based on strategy\r\n   221 | \tswitch cm.config.Strategy {\r\n   222 | \tcase CoherencyStrategyWriteThrough:\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 253,
          "code_snippet": "   248 | \t\tStrategy:             cm.config.Strategy,\r\n   249 | \t\tLevel:                cm.config.Level,\r\n   250 | \t\tIsCoherent:           true, // Simplified\r\n   251 | \t\tPendingInvalidations: len(cm.pendingInvalidations),\r\n   252 | \t\tTotalInvalidations:   cm.stats.TotalInvalidations,\r\nâ†’  253 | \t\tTotalUpdates:         cm.stats.TotalUpdates,\r\n   254 | \t}, nil\r\n   255 | }\r\n   256 | \r\n   257 | // GetInvalidationStats returns invalidation statistics\r\n   258 | func (cm *CoherencyManagerImpl) GetInvalidationStats(ctx context.Context) (*InvalidationStats, error) {\r\n",
          "full_function": "func (cm *CoherencyManagerImpl) GetCoherencyStatus(ctx context.Context) (*CoherencyStatus, error) {\r\n\tcm.mu.RLock()\r\n\tdefer cm.mu.RUnlock()\r\n\r\n\treturn \u0026CoherencyStatus{\r\n\t\tStrategy:             cm.config.Strategy,\r\n\t\tLevel:                cm.config.Level,\r\n\t\tIsCoherent:           true, // Simplified\r\n\t\tPendingInvalidations: len(cm.pendingInvalidations),\r\n\t\tTotalInvalidations:   cm.stats.TotalInvalidations,\r\n\t\tTotalUpdates:         cm.stats.TotalUpdates,\r\n\t}, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 342,
          "code_snippet": "   337 | \tcm.mu.Lock()\r\n   338 | \tcm.pendingInvalidations[event.Key] = event\r\n   339 | \tcm.mu.Unlock()\r\n   340 | \r\n   341 | \t// Process invalidation\r\nâ†’  342 | \tcm.cache.Delete(event.Key)\r\n   343 | \r\n   344 | \tcm.mu.Lock()\r\n   345 | \tdelete(cm.pendingInvalidations, event.Key)\r\n   346 | \tcm.mu.Unlock()\r\n   347 | \r\n",
          "full_function": "func (cm *CoherencyManagerImpl) processInvalidation(event *InvalidationEvent) {\r\n\tcm.mu.Lock()\r\n\tcm.pendingInvalidations[event.Key] = event\r\n\tcm.mu.Unlock()\r\n\r\n\t// Process invalidation\r\n\tcm.cache.Delete(event.Key)\r\n\r\n\tcm.mu.Lock()\r\n\tdelete(cm.pendingInvalidations, event.Key)\r\n\tcm.mu.Unlock()\r\n\r\n\tcm.logger.Debug(\"Invalidation processed\",\r\n\t\tzap.String(\"key\", event.Key),\r\n\t\tzap.String(\"reason\", event.Reason))\r\n}\r",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 236,
          "code_snippet": "   231 | \t// Compare vector clocks\r\n   232 | \tcomparison := r.compareVectorClocks(localVC, remoteVC)\r\n   233 | \t\r\n   234 | \tswitch comparison {\r\n   235 | \tcase \"local_greater\":\r\nâ†’  236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n   237 | \tcase \"remote_greater\":\r\n   238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n   239 | \tcase \"concurrent\":\r\n   240 | \t\t// Conflict detected, need merge\r\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\r\n\t// Extract vector clocks from metadata\r\n\tlocalVC := r.getVectorClock(conflict.LocalState)\r\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\r\n\t\r\n\t// Compare vector clocks\r\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\r\n\t\r\n\tswitch comparison {\r\n\tcase \"local_greater\":\r\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n\tcase \"remote_greater\":\r\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n\tcase \"concurrent\":\r\n\t\t// Conflict detected, need merge\r\n\t\treturn r.resolveCRDTMerge(conflict)\r\n\tdefault:\r\n\t\t// Same vector clock, use timestamp as tie-breaker\r\n\t\treturn r.resolveLastWriteWins(conflict)\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 238,
          "code_snippet": "   233 | \t\r\n   234 | \tswitch comparison {\r\n   235 | \tcase \"local_greater\":\r\n   236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n   237 | \tcase \"remote_greater\":\r\nâ†’  238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n   239 | \tcase \"concurrent\":\r\n   240 | \t\t// Conflict detected, need merge\r\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\r\n   242 | \tdefault:\r\n   243 | \t\t// Same vector clock, use timestamp as tie-breaker\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\r\n\t// Extract vector clocks from metadata\r\n\tlocalVC := r.getVectorClock(conflict.LocalState)\r\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\r\n\t\r\n\t// Compare vector clocks\r\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\r\n\t\r\n\tswitch comparison {\r\n\tcase \"local_greater\":\r\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n\tcase \"remote_greater\":\r\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n\tcase \"concurrent\":\r\n\t\t// Conflict detected, need merge\r\n\t\treturn r.resolveCRDTMerge(conflict)\r\n\tdefault:\r\n\t\t// Same vector clock, use timestamp as tie-breaker\r\n\t\treturn r.resolveLastWriteWins(conflict)\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 251,
          "code_snippet": "   246 | }\r\n   247 | \r\n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\r\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\r\nâ†’  251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\n   252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n   253 | \t\r\n   254 | \t// Ensure both states have timestamps\r\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n\t// CRDT LWW uses timestamps for conflict resolution\r\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n\t\r\n\t// Ensure both states have timestamps\r\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n\t\r\n\tif localTS.After(remoteTS) {\r\n\t\treturn \u0026VersionedState{\r\n\t\t\tKey:     conflict.Key,\r\n\t\t\tValue:   conflict.LocalState.Value,\r\n\t\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\t\tTTL:     conflict.LocalState.TTL,\r\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t\t}, nil\r\n\t}\r\n\t\r\n\treturn \u0026VersionedState{\r\n\t\tKey:     conflict.Key,\r\n\t\tValue:   conflict.RemoteState.Value,\r\n\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\tTTL:     conflict.RemoteState.TTL,\r\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t}, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 252,
          "code_snippet": "   247 | \r\n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\r\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\r\n   251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\nâ†’  252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n   253 | \t\r\n   254 | \t// Ensure both states have timestamps\r\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n   257 | \t\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n\t// CRDT LWW uses timestamps for conflict resolution\r\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n\t\r\n\t// Ensure both states have timestamps\r\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n\t\r\n\tif localTS.After(remoteTS) {\r\n\t\treturn \u0026VersionedState{\r\n\t\t\tKey:     conflict.Key,\r\n\t\t\tValue:   conflict.LocalState.Value,\r\n\t\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\t\tTTL:     conflict.LocalState.TTL,\r\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t\t}, nil\r\n\t}\r\n\t\r\n\treturn \u0026VersionedState{\r\n\t\tKey:     conflict.Key,\r\n\t\tValue:   conflict.RemoteState.Value,\r\n\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\tTTL:     conflict.RemoteState.TTL,\r\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t}, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 283,
          "code_snippet": "   278 | func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\r\n   279 | \t// For simple values, use last-write-wins\r\n   280 | \t// For complex values (maps, sets, counters), perform actual CRDT merge\r\n   281 | \t\r\n   282 | \t// Check if values are mergeable\r\nâ†’  283 | \tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\r\n   284 | \t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\r\n   285 | \t\tif err != nil {\r\n   286 | \t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\r\n   287 | \t\t\t\tzap.String(\"key\", conflict.Key),\r\n   288 | \t\t\t\tzap.Error(err))\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\r\n\t// For simple values, use last-write-wins\r\n\t// For complex values (maps, sets, counters), perform actual CRDT merge\r\n\t\r\n\t// Check if values are mergeable\r\n\tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\r\n\t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\r\n\t\tif err != nil {\r\n\t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\r\n\t\t\t\tzap.String(\"key\", conflict.Key),\r\n\t\t\t\tzap.Error(err))\r\n\t\t\treturn r.resolveCRDTLastWriterWins(conflict)\r\n\t\t}\r\n\t\t\r\n\t\treturn \u0026VersionedState{\r\n\t\t\tKey:     conflict.Key,\r\n\t\t\tValue:   mergedValue,\r\n\t\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\t\tTTL:     r.mergeTTL(conflict.LocalState.TTL, conflict.RemoteState.TTL),\r\n\t\t\tMeta:    r.createCRDTMergeMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta),\r\n\t\t}, nil\r\n\t}\r\n\t\r\n\t// Non-mergeable, fall back to LWW\r\n\treturn r.resolveCRDTLastWriterWins(conflict)\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 396,
          "code_snippet": "   391 | \treturn ts\r\n   392 | }\r\n   393 | \r\n   394 | func (r *ConflictResolverImpl) isMergeableValue(value interface{}) bool {\r\n   395 | \t// Check if value is a type that can be merged\r\nâ†’  396 | \tswitch v := value.(type) {\r\n   397 | \tcase map[string]interface{}:\r\n   398 | \t\treturn true\r\n   399 | \tcase []interface{}:\r\n   400 | \t\treturn true\r\n   401 | \tcase map[string]string:\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 415,
          "code_snippet": "   410 | func (r *ConflictResolverImpl) mergeValues(local, remote interface{}) (interface{}, error) {\r\n   411 | \t// Implement actual CRDT merge logic based on value type\r\n   412 | \tswitch l := local.(type) {\r\n   413 | \tcase map[string]interface{}:\r\n   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\r\nâ†’  415 | \t\t\treturn r.mergeMaps(l, r), nil\r\n   416 | \t\t}\r\n   417 | \tcase []interface{}:\r\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\r\n   419 | \t\t\treturn r.mergeArrays(l, r), nil\r\n   420 | \t\t}\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 419,
          "code_snippet": "   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\r\n   415 | \t\t\treturn r.mergeMaps(l, r), nil\r\n   416 | \t\t}\r\n   417 | \tcase []interface{}:\r\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\r\nâ†’  419 | \t\t\treturn r.mergeArrays(l, r), nil\r\n   420 | \t\t}\r\n   421 | \t}\r\n   422 | \t\r\n   423 | \t// Cannot merge, return error\r\n   424 | \treturn nil, fmt.Errorf(\"values are not mergeable\")\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 516,
          "code_snippet": "   511 | \t\r\n   512 | \t// Add CRDT-specific metadata\r\n   513 | \tmerged[\"crdt_strategy\"] = \"last-writer-wins\"\r\n   514 | \tmerged[\"local_timestamp\"] = localTS\r\n   515 | \tmerged[\"remote_timestamp\"] = remoteTS\r\nâ†’  516 | \tmerged[\"winner_timestamp\"] = max(localTS, remoteTS)\r\n   517 | \t\r\n   518 | \treturn merged\r\n   519 | }\r\n   520 | \r\n   521 | func (r *ConflictResolverImpl) createCRDTMergeMeta(local, remote map[string]interface{}) map[string]interface{} {\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 622,
          "code_snippet": "   617 | \t\treturn a\r\n   618 | \t}\r\n   619 | \treturn b\r\n   620 | }\r\n   621 | \r\nâ†’  622 | func max(a, b time.Time) time.Time {\r\n   623 | \tif a.After(b) {\r\n   624 | \t\treturn a\r\n   625 | \t}\r\n   626 | \treturn b\r\n   627 | }\n",
          "full_function": "func max(a, b time.Time) time.Time {\r\n\tif a.After(b) {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\state\\store\\conflict_resolver.go",
          "line_number": 615,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 516,
          "code_snippet": "   511 | \t\r\n   512 | \t// Add CRDT-specific metadata\r\n   513 | \tmerged[\"crdt_strategy\"] = \"last-writer-wins\"\r\n   514 | \tmerged[\"local_timestamp\"] = localTS\r\n   515 | \tmerged[\"remote_timestamp\"] = remoteTS\r\nâ†’  516 | \tmerged[\"winner_timestamp\"] = max(localTS, remoteTS)\r\n   517 | \t\r\n   518 | \treturn merged\r\n   519 | }\r\n   520 | \r\n   521 | func (r *ConflictResolverImpl) createCRDTMergeMeta(local, remote map[string]interface{}) map[string]interface{} {\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_replay.go",
          "line_number": 249,
          "code_snippet": "   244 | }\r\n   245 | \r\n   246 | // ReplayFromSnapshot replays events from a snapshot version\r\n   247 | func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\r\n   248 | \t// Get snapshot\r\nâ†’  249 | \tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\r\n   250 | \tif err != nil {\r\n   251 | \t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\r\n   252 | \t}\r\n   253 | \r\n   254 | \t// Get events after snapshot version\r\n",
          "full_function": "func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\r\n\t// Get snapshot\r\n\tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\r\n\t}\r\n\r\n\t// Get events after snapshot version\r\n\tevents, err := er.store.GetEvents(ctx, aggregateID, snapshotVersion+1, 0)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to get events after snapshot: %w\", err)\r\n\t}\r\n\r\n\tif len(events) == 0 {\r\n\t\treturn \u0026ReplayProgress{\r\n\t\t\tTotalEvents:     0,\r\n\t\t\tProcessedEvents: 0,\r\n\t\t\tIsComplete:      true,\r\n\t\t}, nil\r\n\t}\r\n\r\n\tstartTime := time.Now()\r\n\tprogress := \u0026ReplayProgress{\r\n\t\tTotalEvents:    int64(len(events)),\r\n\t\tStartTime:      startTime,\r\n\t\tCurrentVersion: snapshotVersion + 1,\r\n\t}\r\n\r\n\terr = er.replaySequential(ctx, events, handler, progress)\r\n\tprogress.ElapsedTime = time.Since(startTime)\r\n\tprogress.IsComplete = true\r\n\r\n\tif err != nil {\r\n\t\tprogress.LastError = err.Error()\r\n\t\treturn progress, err\r\n\t}\r\n\r\n\treturn progress, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_replay.go",
          "line_number": 290,
          "code_snippet": "   285 | }\r\n   286 | \r\n   287 | // ReplayToState replays events to rebuild state at a specific version\r\n   288 | func (er *EventReplayImpl) ReplayToState(ctx context.Context, aggregateID string, targetVersion int64, handler ReplayHandler) (interface{}, error) {\r\n   289 | \t// Get all events up to target version\r\nâ†’  290 | \tevents, err := er.store.GetEvents(ctx, aggregateID, 1, targetVersion)\r\n   291 | \tif err != nil {\r\n   292 | \t\treturn nil, fmt.Errorf(\"failed to get events: %w\", err)\r\n   293 | \t}\r\n   294 | \r\n   295 | \t// Replay events\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_versioning.go",
          "line_number": 140,
          "code_snippet": "   135 | \tif exists {\r\n   136 | \t\t// Return copy\r\n   137 | \t\tcopy := *versionInfo\r\n   138 | \t\tif versionInfo.VersionHistory != nil {\r\n   139 | \t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\r\nâ†’  140 | \t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\r\n   141 | \t\t}\r\n   142 | \t\treturn \u0026copy, nil\r\n   143 | \t}\r\n   144 | \t\r\n   145 | \t// Load from event store\r\n",
          "full_function": "func (ev *EventVersioningImpl) GetVersion(ctx context.Context, aggregateID string) (*VersionInfo, error) {\r\n\tev.mu.RLock()\r\n\tversionInfo, exists := ev.versions[aggregateID]\r\n\tev.mu.RUnlock()\r\n\t\r\n\tif exists {\r\n\t\t// Return copy\r\n\t\tcopy := *versionInfo\r\n\t\tif versionInfo.VersionHistory != nil {\r\n\t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\r\n\t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\r\n\t\t}\r\n\t\treturn \u0026copy, nil\r\n\t}\r\n\t\r\n\t// Load from event store\r\n\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to get aggregate info: %w\", err)\r\n\t}\r\n\t\r\n\tversionInfo = \u0026VersionInfo{\r\n\t\tAggregateID:    aggregateID,\r\n\t\tAggregateType:  aggregateInfo.AggregateType,\r\n\t\tCurrentVersion: aggregateInfo.Version,\r\n\t\tMetadata:       make(map[string]interface{}),\r\n\t}\r\n\t\r\n\tif ev.config.EnableHistory {\r\n\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\r\n\t}\r\n\t\r\n\tev.mu.Lock()\r\n\tev.versions[aggregateID] = versionInfo\r\n\tev.mu.Unlock()\r\n\t\r\n\treturn versionInfo, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_versioning.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\tif ev.config.ConflictResolution == \"reject\" {\r\n   212 | \t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\r\n   213 | \t\t}\r\n   214 | \t\t\r\n   215 | \t\t// Resolve conflict\r\nâ†’  216 | \t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\r\n   217 | \t\tif err != nil {\r\n   218 | \t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\r\n   219 | \t\t}\r\n   220 | \t\t\r\n   221 | \t\tnewVersion = resolvedVersion\r\n",
          "full_function": "func (ev *EventVersioningImpl) IncrementVersion(ctx context.Context, aggregateID string, event *Event) (int64, error) {\r\n\tev.mu.Lock()\r\n\tdefer ev.mu.Unlock()\r\n\t\r\n\tversionInfo, exists := ev.versions[aggregateID]\r\n\tif !exists {\r\n\t\t// Load from store\r\n\t\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\r\n\t\tif err != nil {\r\n\t\t\treturn 0, fmt.Errorf(\"failed to get aggregate info: %w\", err)\r\n\t\t}\r\n\t\t\r\n\t\tversionInfo = \u0026VersionInfo{\r\n\t\t\tAggregateID:    aggregateID,\r\n\t\t\tAggregateType:  aggregateInfo.AggregateType,\r\n\t\t\tCurrentVersion: aggregateInfo.Version,\r\n\t\t\tMetadata:       make(map[string]interface{}),\r\n\t\t}\r\n\t\t\r\n\t\tif ev.config.EnableHistory {\r\n\t\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\r\n\t\t}\r\n\t\t\r\n\t\tev.versions[aggregateID] = versionInfo\r\n\t}\r\n\t\r\n\t// Increment version\r\n\tnewVersion := versionInfo.CurrentVersion + 1\r\n\t\r\n\t// Validate version continuity\r\n\tif event.Version != 0 \u0026\u0026 event.Version != newVersion {\r\n\t\tconflict := \u0026VersionConflict{\r\n\t\t\tAggregateID:     aggregateID,\r\n\t\t\tExpectedVersion: newVersion,\r\n\t\t\tActualVersion:   event.Version,\r\n\t\t\tConflictTime:    time.Now(),\r\n\t\t}\r\n\t\t\r\n\t\tev.stats.TotalConflicts++\r\n\t\tev.conflicts[aggregateID] = append(ev.conflicts[aggregateID], conflict)\r\n\t\t\r\n\t\tif ev.config.ConflictResolution == \"reject\" {\r\n\t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\r\n\t\t}\r\n\t\t\r\n\t\t// Resolve conflict\r\n\t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\r\n\t\tif err != nil {\r\n\t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\r\n\t\t}\r\n\t\t\r\n\t\tnewVersion = resolvedVersion\r\n\t\tconflict.Resolution = fmt.Sprintf(\"resolved to %d\", resolvedVersion)\r\n\t\tev.stats.ResolvedConflicts++\r\n\t}\r\n\t\r\n\t// Update version info\r\n\tversionInfo.CurrentVersion = newVersion\r\n\tversionInfo.LastEventID = event.ID\r\n\tversionInfo.LastEventTime = event.Timestamp\r\n\t\r\n\t// Add to history\r\n\tif ev.config.EnableHistory {\r\n\t\tentry := VersionHistoryEntry{\r\n\t\t\tVersion:   newVersion,\r\n\t\t\tEventID:   event.ID,\r\n\t\t\tTimestamp: event.Timestamp,\r\n\t\t\tEventType: event.Type,\r\n\t\t}\r\n\t\t\r\n\t\tversionInfo.VersionHistory = append(versionInfo.VersionHistory, entry)\r\n\t\t\r\n\t\t// Trim history if needed\r\n\t\tif len(versionInfo.VersionHistory) \u003e ev.config.HistoryRetention {\r\n\t\t\tversionInfo.VersionHistory = versionInfo.VersionHistory[len(versionInfo.VersionHistory)-ev.config.HistoryRetention:]\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Update statistics\r\n\tev.stats.TotalVersions++\r\n\tev.stats.VersionDistribution[newVersion]++\r\n\t\r\n\tev.logger.Debug(\"Version incremented\",\r\n\t\tzap.String(\"aggregate_id\", aggregateID),\r\n\t\tzap.Int64(\"version\", newVersion))\r\n\t\r\n\treturn newVersion, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 36,
        "affected_lines": 108,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "1-2 horas",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    }
  ],
  "quick_wins": null,
  "blockers": [
    {
      "type": "No Code Conflicts",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Conflitos de declaracao detectados",
      "suggestion": "Remova ou renomeie as declaracoes duplicadas",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": true,
        "requires_review": true,
        "manual_steps": "1. Identifique qual declaracao manter\n2. Remova ou renomeie as duplicatas\n3. Atualize referencias",
        "non_fixable_reason": "ARCHITECTURAL",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "15-30 minutos",
        "confidence": 0
      },
      "examples": [
        "registry: 'TemplateInfo' declarado em mcp_registry.go, template_registry.go",
        "cli: 'init' declarado em ai.go, generate.go, monitor.go, root.go, state.go, template.go, version.go",
        "pubsub: 'PubSubClient' declarado em nats_pubsub.go, pubsub_client.go",
        "encryption: 'Manager' declarado em certificate_manager.go, encryption_manager.go, key_manager.go",
        "crush: 'min' declarado em batch_processor.go, parallel_processor.go",
        "crush: 'max' declarado em batch_processor.go, parallel_processor.go",
        "protocol: 'parseParams' declarado em handlers.go, router.go",
        "analytics: 'init' declarado em metrics.go, performance.go"
      ],
      "non_fixable_reason": "ARCHITECTURAL",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 17,
          "code_snippet": "    12 | \t\"go.uber.org/zap\"\r\n    13 | \t\"gopkg.in/yaml.v3\"\r\n    14 | )\r\n    15 | \r\n    16 | // TemplateInfo holds information about a registered template\r\nâ†’   17 | type TemplateInfo struct {\r\n    18 | \tName         string            `json:\"name\"`\r\n    19 | \tStack        string            `json:\"stack\"`\r\n    20 | \tVersion      string            `json:\"version\"`\r\n    21 | \tSummary      string            `json:\"summary\"`\r\n    22 | \tPlaceholders []string          `json:\"placeholders\"`\r\n",
          "full_function": "type TemplateInfo struct {\r\n\tName         string            `json:\"name\"`\r\n\tStack        string            `json:\"stack\"`\r\n\tVersion      string            `json:\"version\"`\r\n\tSummary      string            `json:\"summary\"`\r\n\tPlaceholders []string          `json:\"placeholders\"`\r\n\tFiles        []string          `json:\"files\"`\r\n\tPath         string            `json:\"path\"`\r\n\tMetadata     map[string]string `json:\"metadata\"`\r\n\tLastModified string            `json:\"last_modified\"`\r\n}\r",
          "symbol_name": "TemplateInfo",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\generate.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"MCP project generation initiated\")\r\n    40 | \t\treturn nil\r\n    41 | \t},\r\n    42 | }\r\n    43 | \r\nâ†’   44 | func init() {\r\n    45 | \trootCmd.AddCommand(generateCmd)\r\n    46 | \tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\r\n    47 | \tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\r\n    48 | \tgenerateCmd.MarkFlagRequired(\"template\")\r\n    49 | }\r\n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(generateCmd)\r\n\tgenerateCmd.Flags().StringP(\"template\", \"t\", \"\", \"Template ID to use\")\r\n\tgenerateCmd.Flags().StringP(\"output\", \"o\", \".\", \"Output directory\")\r\n\tgenerateCmd.MarkFlagRequired(\"template\")\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/internal/services",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\monitor.go",
          "line_number": 24,
          "code_snippet": "    19 | \t\tcmd.Println(\"System status: Operational\")\r\n    20 | \t\treturn nil\r\n    21 | \t},\r\n    22 | }\r\n    23 | \r\nâ†’   24 | func init() {\r\n    25 | \trootCmd.AddCommand(monitorCmd)\r\n    26 | }\r\n    27 | \r\n    28 | // SetMonitoringService sets the monitoring service\r\n    29 | func SetMonitoringService(service *services.MonitoringAppService) {\r\n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(monitorCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/internal/services",
            "github.com/vertikon/mcp-core-inventory/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\root.go",
          "line_number": 37,
          "code_snippet": "    32 | \t\tos.Exit(1)\r\n    33 | \t}\r\n    34 | }\r\n    35 | \r\n    36 | // init initializes the CLI\r\nâ†’   37 | func init() {\r\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n    40 | \t\r\n    41 | \t// Add subcommand groups\r\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n",
          "full_function": "func init() {\r\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n\t\r\n\t// Add subcommand groups\r\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n\trootCmd.AddCommand(ci.CICmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\state.go",
          "line_number": 20,
          "code_snippet": "    15 | \t\tcmd.Println(\"State management - service implementation pending\")\r\n    16 | \t\treturn nil\r\n    17 | \t},\r\n    18 | }\r\n    19 | \r\nâ†’   20 | func init() {\r\n    21 | \trootCmd.AddCommand(stateCmd)\r\n    22 | }\r\n    23 | \n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(stateCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\template.go",
          "line_number": 44,
          "code_snippet": "    39 | \t\tcmd.Println(\"Template created\")\r\n    40 | \t\treturn nil\r\n    41 | \t},\r\n    42 | }\r\n    43 | \r\nâ†’   44 | func init() {\r\n    45 | \trootCmd.AddCommand(templateCmd)\r\n    46 | \ttemplateCmd.AddCommand(templateListCmd)\r\n    47 | \ttemplateCmd.AddCommand(templateCreateCmd)\r\n    48 | \ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\r\n    49 | \ttemplateCreateCmd.MarkFlagRequired(\"name\")\r\n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(templateCmd)\r\n\ttemplateCmd.AddCommand(templateListCmd)\r\n\ttemplateCmd.AddCommand(templateCreateCmd)\r\n\ttemplateCreateCmd.Flags().StringP(\"name\", \"n\", \"\", \"Template name\")\r\n\ttemplateCreateCmd.MarkFlagRequired(\"name\")\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/internal/services",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\version.go",
          "line_number": 21,
          "code_snippet": "    16 | \t\tfmt.Printf(\"Version: %s\\n\", Version)\r\n    17 | \t\tfmt.Printf(\"Build Date: %s\\n\", BuildDate)\r\n    18 | \t},\r\n    19 | }\r\n    20 | \r\nâ†’   21 | func init() {\r\n    22 | \trootCmd.AddCommand(versionCmd)\r\n    23 | }\r\n    24 | \n",
          "full_function": "func init() {\r\n\trootCmd.AddCommand(versionCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "github.com/spf13/cobra"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\messaging\\pubsub\\pubsub_client.go",
          "line_number": 9,
          "code_snippet": "     4 | import (\r\n     5 | \t\"context\"\r\n     6 | )\r\n     7 | \r\n     8 | // PubSubClient provides generic pub/sub interface\r\nâ†’    9 | type PubSubClient interface {\r\n    10 | \t// Publish publishes a message to a topic\r\n    11 | \tPublish(ctx context.Context, topic string, message []byte) error\r\n    12 | \r\n    13 | \t// Subscribe subscribes to a topic\r\n    14 | \tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n",
          "full_function": "type PubSubClient interface {\r\n\t// Publish publishes a message to a topic\r\n\tPublish(ctx context.Context, topic string, message []byte) error\r\n\r\n\t// Subscribe subscribes to a topic\r\n\tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n\r\n\t// Close closes the client connection\r\n\tClose() error\r\n}\r",
          "symbol_name": "PubSubClient",
          "package_name": "pubsub",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 622,
          "code_snippet": "   617 | \t\treturn a\r\n   618 | \t}\r\n   619 | \treturn b\r\n   620 | }\r\n   621 | \r\nâ†’  622 | func max(a, b time.Time) time.Time {\r\n   623 | \tif a.After(b) {\r\n   624 | \t\treturn a\r\n   625 | \t}\r\n   626 | \treturn b\r\n   627 | }\n",
          "full_function": "func max(a, b time.Time) time.Time {\r\n\tif a.After(b) {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "max",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 56,
          "code_snippet": "    51 | \t// Verify verifies a signature using RSA\r\n    52 | \tVerify(data, signature []byte, publicKey *rsa.PublicKey) bool\r\n    53 | }\r\n    54 | \r\n    55 | // Manager implements EncryptionManager\r\nâ†’   56 | type Manager struct {\r\n    57 | \tkeyManager KeyManager\r\n    58 | \tlogger     *zap.Logger\r\n    59 | }\r\n    60 | \r\n    61 | // NewEncryptionManager creates a new EncryptionManager\r\n",
          "full_function": "type Manager struct {\r\n\tkeyManager KeyManager\r\n\tlogger     *zap.Logger\r\n}\r",
          "symbol_name": "Manager",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 52,
          "code_snippet": "    47 | \t// LoadKeyFromFile loads key from file\r\n    48 | \tLoadKeyFromFile(filePath string) error\r\n    49 | }\r\n    50 | \r\n    51 | // Manager implements KeyManager\r\nâ†’   52 | type Manager struct {\r\n    53 | \tencryptionKey []byte\r\n    54 | \tkeyVersion    string\r\n    55 | \trsaPrivateKey *rsa.PrivateKey\r\n    56 | \trsaPublicKey  *rsa.PublicKey\r\n    57 | \trotationTTL  time.Duration\r\n",
          "full_function": "type Manager struct {\r\n\tencryptionKey []byte\r\n\tkeyVersion    string\r\n\trsaPrivateKey *rsa.PrivateKey\r\n\trsaPublicKey  *rsa.PublicKey\r\n\trotationTTL  time.Duration\r\n\tlastRotation  time.Time\r\n\tmu            sync.RWMutex\r\n\tlogger        *zap.Logger\r\n}\r",
          "symbol_name": "Manager",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 625,
          "code_snippet": "   620 | \tas.stats.ScaleDownEvents++\r\n   621 | \tnow := time.Now()\r\n   622 | \tas.stats.LastScalingTime = \u0026now\r\n   623 | }\r\n   624 | \r\nâ†’  625 | func min(a, b int) int {\r\n   626 | \tif a \u003c b {\r\n   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n",
          "full_function": "func min(a, b int) int {\r\n\tif a \u003c b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r",
          "symbol_name": "min",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 632,
          "code_snippet": "   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n   631 | \r\nâ†’  632 | func max(a, b int) int {\r\n   633 | \tif a \u003e b {\r\n   634 | \t\treturn a\r\n   635 | \t}\r\n   636 | \treturn b\r\n   637 | }\n",
          "full_function": "func max(a, b int) int {\r\n\tif a \u003e b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "max",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\protocol\\router.go",
          "line_number": 215,
          "code_snippet": "   210 | \r\n   211 | \treturn nil\r\n   212 | }\r\n   213 | \r\n   214 | // parseParams parses parameters from a JSON-RPC request\r\nâ†’  215 | func parseParams(params interface{}, target interface{}) error {\r\n   216 | \tif params == nil {\r\n   217 | \t\treturn nil\r\n   218 | \t}\r\n   219 | \r\n   220 | \t// This is a simplified parameter parsing\r\n",
          "full_function": "",
          "symbol_name": "parseParams",
          "package_name": "protocol",
          "dependencies": [
            "context",
            "fmt",
            "strings",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\analytics\\performance.go",
          "line_number": 23,
          "code_snippet": "    18 | \t\tcmd.Println(\"  P95 Latency: 0ms\")\r\n    19 | \t\treturn nil\r\n    20 | \t},\r\n    21 | }\r\n    22 | \r\nâ†’   23 | func init() {\r\n    24 | \tAnalyticsCmd.AddCommand(performanceCmd)\r\n    25 | }\r\n    26 | \n",
          "full_function": "func init() {\r\n\tAnalyticsCmd.AddCommand(performanceCmd)\r\n}\r",
          "symbol_name": "init",
          "package_name": "analytics",
          "dependencies": [
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 0,
        "affected_lines": 0,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "10-30 minutos",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    },
    {
      "type": "Codigo compila",
      "severity": "critical",
      "location": "multiplos arquivos",
      "description": "Nao compila: # github.com/vertikon/mcp-core-inventory/internal/core/scheduler\ninternal\\core\\scheduler\\scheduler.go:62:19: undefined: nats.ErrStreamNameExist\n# github.com/vertikon/mcp-core-inventory/internal/adapte...",
      "suggestion": "Corrija os erros de compilacao listados",
      "fixability": {
        "safe": false,
        "rollback_easy": false,
        "affects_behavior": false,
        "requires_review": false,
        "non_fixable_reason": "BUSINESS_LOGIC",
        "tools": null,
        "executable_steps": null,
        "estimated_time": "Variavel - depende dos erros",
        "confidence": 0
      },
      "examples": [
        "ðŸ“„ Log completo: E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\docs\\validation\\raw\\2025-11-21-20-35-21-compilation.log",
        "",
        "# github.com/vertikon/mcp-core-inventory/internal/core/scheduler",
        "internal\\core\\scheduler\\scheduler.go:62:19: undefined: nats.ErrStreamNameExist",
        "# github.com/vertikon/mcp-core-inventory/internal/adapters/postgres",
        "internal\\adapters\\postgres\\ledger_repository.go:103:8: res.id undefined (type ledger.Reservation has no field or method id)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:17: res.ledgerID undefined (type ledger.Reservation has no field or method ledgerID, but does have method LedgerID)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:32: res.sku undefined (type ledger.Reservation has no field or method sku)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:42: res.location undefined (type ledger.Reservation has no field or method location, but does have method Location)",
        "internal\\adapters\\postgres\\ledger_repository.go:103:57: res.quantity undefined (type ledger.Reservation has no field or method quantity, but does have method Quantity)",
        "internal\\adapters\\postgres\\ledger_repository.go:104:8: res.idempotencyKey undefined (type ledger.Reservation has no field or method idempotencyKey, but does have method IdempotencyKey)",
        "internal\\adapters\\postgres\\ledger_repository.go:114:6: res.status undefined (type ledger.Reservation has no field or method status, but does have method Status)",
        "internal\\adapters\\postgres\\ledger_repository.go:115:6: res.expiresAt undefined (type ledger.Reservation has no field or method expiresAt, but does have method ExpiresAt)",
        "internal\\adapters\\postgres\\ledger_repository.go:116:6: res.createdAt undefined (type ledger.Reservation has no field or method createdAt, but does have method CreatedAt)",
        "internal\\adapters\\postgres\\ledger_repository.go:117:6: res.updatedAt undefined (type ledger.Reservation has no field or method updatedAt, but does have method UpdatedAt)",
        "internal\\adapters\\postgres\\ledger_repository.go:117:6: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/app",
        "internal\\app\\query_available.go:7:2: \"github.com/vertikon/mcp-core-inventory/internal/domain/ledger\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/mcp/generators",
        "internal\\mcp\\generators\\generator_factory.go:317:32: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:319:50: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:323:54: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:334:75: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\generator_factory.go:350:39: req.Stack undefined (type GenerateRequest has no field or method Stack)",
        "internal\\mcp\\generators\\tinygo_generator.go:324:3: cannot use \"project\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:324:14: cannot use req.Name (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:3: cannot use \"language\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:325:15: cannot use g.language (variable of type string) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: cannot use \"features\" (untyped string constant) as zap.Field value in argument to g.logger.Info",
        "internal\\mcp\\generators\\tinygo_generator.go:326:3: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/mcp/registry",
        "internal\\mcp\\registry\\template_registry.go:17:6: TemplateInfo redeclared in this block",
        "\tinternal\\mcp\\registry\\mcp_registry.go:301:6: other declaration of TemplateInfo",
        "internal\\mcp\\registry\\template_registry.go:75:17: templateInfo.Path undefined (type *TemplateInfo has no field or method Path)",
        "internal\\mcp\\registry\\template_registry.go:124:3: unknown field Summary in struct literal of type TemplateInfo",
        "internal\\mcp\\registry\\template_registry.go:125:3: unknown field Placeholders in struct literal of type TemplateInfo",
        "internal\\mcp\\registry\\discovery.go:21:13: undefined: logger",
        "internal\\mcp\\registry\\discovery.go:27:5: sd.mu undefined (type *ServiceDiscovery has no field or method mu)",
        "internal\\mcp\\registry\\discovery.go:28:11: sd.mu undefined (type *ServiceDiscovery has no field or method mu)",
        "internal\\mcp\\registry\\discovery.go:51:11: service.Description undefined (type *ServiceInfo has no field or method Description)",
        "internal\\mcp\\registry\\service_registry.go:33:10: service.LastChecked undefined (type *ServiceInfo has no field or method LastChecked)",
        "internal\\mcp\\registry\\service_registry.go:96:10: service.LastChecked undefined (type *ServiceInfo has no field or method LastChecked)",
        "internal\\mcp\\registry\\template_registry.go:125:3: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/adapters/redis",
        "internal\\adapters\\redis\\reservation_lock.go:55:2: declared and not used: script",
        "# github.com/vertikon/mcp-core-inventory/cmd/tools-validator",
        "cmd\\tools-validator\\main.go:60:4: unknown field StrictMode in struct literal of type \"github.com/vertikon/mcp-core-inventory/tools/validators\".ConfigValidateRequest",
        "# github.com/vertikon/mcp-core-inventory/internal/core/crush",
        "internal\\core\\crush\\memory_optimizer.go:31:2: PolicyLRU redeclared in this block",
        "\tinternal\\core\\crush\\batch_processor.go:155:2: other declaration of PolicyLRU",
        "internal\\core\\crush\\memory_optimizer.go:395:8: invalid case PolicyLRU in switch on mo.config.EvictionPolicy (mismatched types PrefetchPolicy and EvictionPolicy)",
        "internal\\core\\crush\\parallel_processor.go:625:6: min redeclared in this block",
        "\tinternal\\core\\crush\\batch_processor.go:796:6: other declaration of min",
        "internal\\core\\crush\\parallel_processor.go:632:6: max redeclared in this block",
        "\tinternal\\core\\crush\\batch_processor.go:803:6: other declaration of max",
        "internal\\core\\crush\\batch_processor.go:269:19: undefined: runtime",
        "internal\\core\\crush\\batch_processor.go:427:6: declared and not used: id",
        "internal\\core\\crush\\batch_processor.go:560:18: cannot use \u0026bp.stats.TotalProcessingTime (value of type *time.Duration) as *int64 value in argument to atomic.AddInt64",
        "internal\\core\\crush\\batch_processor.go:584:42: cannot use \u0026bp.stats.TotalProcessingTime (value of type *time.Duration) as *int64 value in argument to atomic.LoadInt64",
        "internal\\core\\crush\\batch_processor.go:781:15: undefined: NewWorkerPool",
        "internal\\core\\crush\\batch_processor.go:792:23: too many arguments in call to abp.workerPool.Start",
        "\thave (context.Context)",
        "\twant ()",
        "internal\\core\\crush\\memory_optimizer.go:395:8: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/domain/services",
        "internal\\domain\\services\\ai_domain_service.go:33:17: context.documents undefined (type *entities.KnowledgeContext has no field or method documents, but does have method Documents)",
        "# github.com/vertikon/mcp-core-inventory/internal/core/state",
        "internal\\core\\state\\distributed_store.go:543:22: invalid operation: cannot take address of dss.stats.LockWaitTime.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:649:31: invalid operation: cannot take address of dss.stats.AvgReadLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:651:21: invalid operation: cannot take address of dss.stats.AvgReadLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:656:31: invalid operation: cannot take address of dss.stats.AvgWriteLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\distributed_store.go:658:21: invalid operation: cannot take address of dss.stats.AvgWriteLatency.Nanoseconds() (value of type int64)",
        "internal\\core\\state\\store.go:10:2: \"github.com/vertikon/mcp-core-inventory/pkg/logger\" imported and not used",
        "internal\\core\\state\\store.go:11:2: \"go.uber.org/zap\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/core/transformer",
        "internal\\core\\transformer\\feedforward.go:194:21: ffn.router undefined (type *FeedForwardNetwork has no field or method router)",
        "internal\\core\\transformer\\transformer.go:152:38: not enough arguments in call to t.embeddings.Forward",
        "\thave (*Tensor)",
        "\twant (context.Context, *Tensor)",
        "internal\\core\\transformer\\transformer.go:209:79: cannot use attentionMask (variable of type *Tensor) as *AttentionMask value in argument to l.attention.Forward",
        "internal\\core\\transformer\\transformer.go:215:28: cannot use attnOutput (variable of type *AttentionResult) as *Tensor value in argument to t.add",
        "internal\\core\\transformer\\transformer.go:249:65: cannot use ln.eps (variable of type float64) as *Tensor value in argument to t.add",
        "internal\\core\\transformer\\positional_encoding.go:6:2: \"fmt\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/compute/serverless",
        "internal\\infrastructure\\compute\\serverless\\cloud_functions.go:14:46: undefined: FunctionConfig",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/messaging/pubsub",
        "internal\\infrastructure\\messaging\\pubsub\\pubsub_client.go:9:6: PubSubClient redeclared in this block",
        "\tinternal\\infrastructure\\messaging\\pubsub\\nats_pubsub.go:9:6: other declaration of PubSubClient",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/messaging/streaming",
        "internal\\infrastructure\\messaging\\streaming\\nats_jetstream.go:178:18: undefined: nats.ErrStreamNameExist",
        "# github.com/vertikon/mcp-core-inventory/internal/infrastructure/persistence/relational",
        "internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go:87:6: declared and not used: knowledge",
        "internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go:204:9: cannot use \u0026knowledge (value of type **entities.Knowledge) as *entities.Knowledge value in return statement",
        "# github.com/vertikon/mcp-core-inventory/internal/interfaces/cli",
        "internal\\interfaces\\cli\\root.go:42:21: undefined: analytics",
        "internal\\interfaces\\cli\\root.go:43:21: undefined: ci",
        "# github.com/vertikon/mcp-core-inventory/tools/deployers",
        "tools\\deployers\\hybrid_deployer.go:10:2: \"github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes\" imported and not used",
        "# github.com/vertikon/mcp-core-inventory/internal/security/encryption",
        "internal\\security\\encryption\\encryption_manager.go:56:6: Manager redeclared in this block",
        "\tinternal\\security\\encryption\\certificate_manager.go:42:6: other declaration of Manager",
        "internal\\security\\encryption\\encryption_manager.go:64:3: unknown field keyManager in struct literal of type Manager",
        "internal\\security\\encryption\\encryption_manager.go:71:16: m.keyManager undefined (type *Manager has no field or method keyManager)",
        "internal\\security\\encryption\\encryption_manager.go:81:16: m.keyManager undefined (type *Manager has no field or method keyManager)",
        "internal\\security\\encryption\\key_manager.go:52:6: Manager redeclared in this block",
        "\tinternal\\security\\encryption\\certificate_manager.go:42:6: other declaration of Manager",
        "internal\\security\\encryption\\key_manager.go:72:3: unknown field keyVersion in struct literal of type Manager",
        "internal\\security\\encryption\\key_manager.go:82:6: km.encryptionKey undefined (type *Manager has no field or method encryptionKey)",
        "internal\\security\\encryption\\key_manager.go:96:4: m.mu undefined (type *Manager has no field or method mu)",
        "internal\\security\\encryption\\key_manager.go:97:10: m.mu undefined (type *Manager has no field or method mu)",
        "internal\\security\\encryption\\key_manager.go:99:7: m.encryptionKey undefined (type *Manager has no field or method encryptionKey)",
        "internal\\security\\encryption\\key_manager.go:99:7: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/state/cache",
        "internal\\state\\cache\\cache_coherency.go:162:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "internal\\state\\cache\\cache_coherency.go:217:11: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:253:34: cm.stats.TotalUpdates undefined (type *InvalidationStats has no field or method TotalUpdates)",
        "internal\\state\\cache\\cache_coherency.go:342:11: cm.cache.Delete undefined (type *StateCache is pointer to interface, not interface)",
        "# github.com/vertikon/mcp-core-inventory/internal/state/store",
        "internal\\state\\store\\conflict_resolver.go:236:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:238:10: not enough return values",
        "\thave (*VersionedState)",
        "\twant (*VersionedState, error)",
        "internal\\state\\store\\conflict_resolver.go:251:2: declared and not used: localTime",
        "internal\\state\\store\\conflict_resolver.go:252:2: declared and not used: remoteTime",
        "internal\\state\\store\\conflict_resolver.go:283:51: too many arguments in call to r.isMergeableValue",
        "\thave (interface{}, interface{})",
        "\twant (interface{})",
        "internal\\state\\store\\conflict_resolver.go:396:9: v declared and not used",
        "internal\\state\\store\\conflict_resolver.go:415:13: r.mergeMaps undefined (type map[string]interface{} has no field or method mergeMaps)",
        "internal\\state\\store\\conflict_resolver.go:419:13: r.mergeArrays undefined (type []interface{} has no field or method mergeArrays)",
        "internal\\state\\store\\conflict_resolver.go:516:35: cannot use localTS (variable of struct type time.Time) as uint64 value in argument to max",
        "internal\\state\\store\\conflict_resolver.go:622:6: max redeclared in this block",
        "\tinternal\\state\\store\\conflict_resolver.go:615:6: other declaration of max",
        "internal\\state\\store\\conflict_resolver.go:516:35: too many errors",
        "# github.com/vertikon/mcp-core-inventory/internal/state/events",
        "internal\\state\\events\\event_replay.go:249:2: declared and not used: snapshot",
        "internal\\state\\events\\event_replay.go:290:2: declared and not used: events",
        "internal\\state\\events\\event_versioning.go:140:4: invalid operation: cannot call copy (variable of struct type VersionInfo): VersionInfo is not a function",
        "internal\\state\\events\\event_versioning.go:216:30: ev.resolveVersionConflict undefined (type *EventVersioningImpl has no field or method resolveVersionConflict, but does have method ResolveVersionConflict)",
        ""
      ],
      "non_fixable_reason": "BUSINESS_LOGIC",
      "code_contexts": [
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\scheduler\\scheduler.go",
          "line_number": 62,
          "code_snippet": "    57 | \t\t\tMaxAge:    24 * time.Hour,\r\n    58 | \t\t}\r\n    59 | \r\n    60 | \t\t_, err := s.js.AddStream(cfg)\r\n    61 | \t\tif err != nil {\r\nâ†’   62 | \t\t\tif err == nats.ErrStreamNameExist {\r\n    63 | \t\t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", stream.name))\r\n    64 | \t\t\t\tcontinue\r\n    65 | \t\t\t}\r\n    66 | \t\t\treturn err\r\n    67 | \t\t}\r\n",
          "full_function": "func (s *Scheduler) InitializeStreams(ctx context.Context) error {\r\n\tstreams := []struct {\r\n\t\tname    string\r\n\t\tsubjects []string\r\n\t}{\r\n\t\t{\r\n\t\t\tname:     \"hulk.engine.tasks\",\r\n\t\t\tsubjects: []string{\"hulk.task.created\", \"hulk.task.completed\", \"hulk.task.failed\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"hulk.engine.events\",\r\n\t\t\tsubjects: []string{\"hulk.engine.*\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"hulk.scheduler.queue\",\r\n\t\t\tsubjects: []string{\"hulk.scheduler.tick\"},\r\n\t\t},\r\n\t\t{\r\n\t\t\tname:     \"hulk.errors\",\r\n\t\t\tsubjects: []string{\"hulk.error.*\"},\r\n\t\t},\r\n\t}\r\n\r\n\tfor _, stream := range streams {\r\n\t\tcfg := \u0026nats.StreamConfig{\r\n\t\t\tName:      stream.name,\r\n\t\t\tSubjects: stream.subjects,\r\n\t\t\tReplicas:  1,\r\n\t\t\tMaxAge:    24 * time.Hour,\r\n\t\t}\r\n\r\n\t\t_, err := s.js.AddStream(cfg)\r\n\t\tif err != nil {\r\n\t\t\tif err == nats.ErrStreamNameExist {\r\n\t\t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", stream.name))\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\ts.streams[stream.name] = cfg\r\n\t\tlogger.Info(\"Stream created\", zap.String(\"stream\", stream.name))\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "scheduler",
          "dependencies": [
            "context",
            "encoding/json",
            "time",
            "github.com/nats-io/nats.go",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 103,
          "code_snippet": "    98 | \tvar res ledger.Reservation\r\n    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\nâ†’  103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n   104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n",
          "full_function": "\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 104,
          "code_snippet": "    99 | \tvar status string\r\n   100 | \tvar expiresAt, createdAt, updatedAt time.Time\r\n   101 | \r\n   102 | \terr := r.db.QueryRowContext(ctx, query, idempotencyKey).Scan(\r\n   103 | \t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\nâ†’  104 | \t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n   105 | \t)\r\n   106 | \tif err != nil {\r\n   107 | \t\tif errors.Is(err, sql.ErrNoRows) {\r\n   108 | \t\t\treturn nil, errors.New(\"reservation not found\")\r\n   109 | \t\t}\r\n",
          "full_function": "\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 114,
          "code_snippet": "   109 | \t\t}\r\n   110 | \t\treturn nil, err\r\n   111 | \t}\r\n   112 | \r\n   113 | \t// Reconstruct reservation\r\nâ†’  114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\n   117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n",
          "full_function": "\tres.status = ledger.ReservationStatus(status)\r\n\tres.expiresAt = expiresAt\r\n\tres.createdAt = createdAt\r\n\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 115,
          "code_snippet": "   110 | \t\treturn nil, err\r\n   111 | \t}\r\n   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\nâ†’  115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\n   117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n",
          "full_function": "\tres.expiresAt = expiresAt\r\n\tres.createdAt = createdAt\r\n\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 116,
          "code_snippet": "   111 | \t}\r\n   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\nâ†’  116 | \tres.createdAt = createdAt\r\n   117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n   121 | \r\n",
          "full_function": "\tres.createdAt = createdAt\r\n\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 117,
          "code_snippet": "   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\nâ†’  117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n   121 | \r\n   122 | // FindByID finds a reservation by ID\r\n",
          "full_function": "\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\postgres\\ledger_repository.go",
          "line_number": 117,
          "code_snippet": "   112 | \r\n   113 | \t// Reconstruct reservation\r\n   114 | \tres.status = ledger.ReservationStatus(status)\r\n   115 | \tres.expiresAt = expiresAt\r\n   116 | \tres.createdAt = createdAt\r\nâ†’  117 | \tres.updatedAt = updatedAt\r\n   118 | \r\n   119 | \treturn \u0026res, nil\r\n   120 | }\r\n   121 | \r\n   122 | // FindByID finds a reservation by ID\r\n",
          "full_function": "\tres.updatedAt = updatedAt\r\n\r\n\treturn \u0026res, nil\r\n}\r\n\r\n// FindByID finds a reservation by ID\r\nfunc (r *LedgerRepository) FindByID(ctx context.Context, id string) (*ledger.Reservation, error) {\r\n\tquery := `\r\n\t\tSELECT id, ledger_id, sku, location, quantity, idempotency_key, status, expires_at, created_at, updated_at\r\n\t\tFROM reservations\r\n\t\tWHERE id = $1\r\n\t`\r\n\r\n\tvar res ledger.Reservation\r\n\tvar status string\r\n\tvar expiresAt, createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026res.id, \u0026res.ledgerID, \u0026res.sku, \u0026res.location, \u0026res.quantity,\r\n\t\t\u0026res.idempotencyKey, \u0026status, \u0026expiresAt, \u0026createdAt, \u0026updatedAt,\r\n\t)\r\n\tif err != nil {\r\n\t\tif errors.Is(err, sql.ErrNoRows) {\r\n\t\t\treturn nil, errors.New(\"reservation not found\")\r\n\t\t}\r\n\t\treturn nil, err\r\n\t}\r",
          "symbol_name": "",
          "package_name": "postgres",
          "dependencies": [
            "context",
            "database/sql",
            "errors",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\app\\query_available.go",
          "line_number": 7,
          "code_snippet": "     2 | \r\n     3 | import (\r\n     4 | \t\"context\"\r\n     5 | \t\"fmt\"\r\n     6 | \r\nâ†’    7 | \t\"github.com/vertikon/mcp-core-inventory/internal/domain/ledger\"\r\n     8 | )\r\n     9 | \r\n    10 | // QueryAvailableRequest represents a request to query available stock\r\n    11 | type QueryAvailableRequest struct {\r\n    12 | \tSKU      string\r\n",
          "full_function": "\t\"github.com/vertikon/mcp-core-inventory/internal/domain/ledger\"\r\n)\r\n\r\n// QueryAvailableRequest represents a request to query available stock\r\ntype QueryAvailableRequest struct {\r\n\tSKU      string\r\n\tLocation string\r\n}\r",
          "symbol_name": "",
          "package_name": "app",
          "dependencies": [
            "context",
            "fmt",
            "github.com/vertikon/mcp-core-inventory/internal/domain/ledger"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 317,
          "code_snippet": "   312 | \tif req.Path == \"\" {\r\n   313 | \t\treturn fmt.Errorf(\"output path is required\")\r\n   314 | \t}\r\n   315 | \r\n   316 | \t// Check if stack is supported\r\nâ†’  317 | \t_, exists := f.generators[req.Stack]\r\n   318 | \tif !exists {\r\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n   320 | \t}\r\n   321 | \r\n   322 | \t// Validate stack configuration\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 319,
          "code_snippet": "   314 | \t}\r\n   315 | \r\n   316 | \t// Check if stack is supported\r\n   317 | \t_, exists := f.generators[req.Stack]\r\n   318 | \tif !exists {\r\nâ†’  319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n   320 | \t}\r\n   321 | \r\n   322 | \t// Validate stack configuration\r\n   323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n   324 | \t\t// Validate features\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 323,
          "code_snippet": "   318 | \tif !exists {\r\n   319 | \t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n   320 | \t}\r\n   321 | \r\n   322 | \t// Validate stack configuration\r\nâ†’  323 | \tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n   324 | \t\t// Validate features\r\n   325 | \t\tfor _, feature := range req.Features {\r\n   326 | \t\t\tvalidFeature := false\r\n   327 | \t\t\tfor _, validFeat := range stackConfig.Features {\r\n   328 | \t\t\t\tif feature == validFeat {\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 334,
          "code_snippet": "   329 | \t\t\t\t\tvalidFeature = true\r\n   330 | \t\t\t\t\tbreak\r\n   331 | \t\t\t\t}\r\n   332 | \t\t\t}\r\n   333 | \t\t\tif !validFeature {\r\nâ†’  334 | \t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n   335 | \t\t\t}\r\n   336 | \t\t}\r\n   337 | \t}\r\n   338 | \r\n   339 | \treturn nil\r\n",
          "full_function": "func (f *GeneratorFactory) ValidateRequest(req GenerateRequest) error {\r\n\tif req.Name == \"\" {\r\n\t\treturn fmt.Errorf(\"project name is required\")\r\n\t}\r\n\r\n\tif req.Path == \"\" {\r\n\t\treturn fmt.Errorf(\"output path is required\")\r\n\t}\r\n\r\n\t// Check if stack is supported\r\n\t_, exists := f.generators[req.Stack]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"unsupported stack: %s\", req.Stack)\r\n\t}\r\n\r\n\t// Validate stack configuration\r\n\tif stackConfig, exists := f.config.StackConfigs[req.Stack]; exists {\r\n\t\t// Validate features\r\n\t\tfor _, feature := range req.Features {\r\n\t\t\tvalidFeature := false\r\n\t\t\tfor _, validFeat := range stackConfig.Features {\r\n\t\t\t\tif feature == validFeat {\r\n\t\t\t\t\tvalidFeature = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif !validFeature {\r\n\t\t\t\treturn fmt.Errorf(\"invalid feature '%s' for stack '%s'\", feature, req.Stack)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\generator_factory.go",
          "line_number": 350,
          "code_snippet": "   345 | \tif err := f.ValidateRequest(req); err != nil {\r\n   346 | \t\treturn nil, err\r\n   347 | \t}\r\n   348 | \r\n   349 | \t// Get generator\r\nâ†’  350 | \tgenerator, err := f.GetGenerator(req.Stack)\r\n   351 | \tif err != nil {\r\n   352 | \t\treturn nil, err\r\n   353 | \t}\r\n   354 | \r\n   355 | \t// Generate project\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "path/filepath",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\r\n   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\nâ†’  324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 324,
          "code_snippet": "   319 | \t// Generate bindings\r\n   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\nâ†’  324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\nâ†’  325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 325,
          "code_snippet": "   320 | \t// This would involve executing shell commands\r\n   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\nâ†’  325 | \t\t\"language\", g.language,\r\n   326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\nâ†’  326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n   331 | // Validate validates wasm generator\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\generators\\tinygo_generator.go",
          "line_number": 326,
          "code_snippet": "   321 | \t// For now, just return nil as placeholder\r\n   322 | \t\r\n   323 | \tg.logger.Info(\"WASM project post-processing completed\",\r\n   324 | \t\t\"project\", req.Name,\r\n   325 | \t\t\"language\", g.language,\r\nâ†’  326 | \t\t\"features\", req.Features)\r\n   327 | \r\n   328 | \treturn nil\r\n   329 | }\r\n   330 | \r\n   331 | // Validate validates wasm generator\r\n",
          "full_function": "func (g *WasmGenerator) postProcessWasmProject(projectPath string, req GenerateRequest) error {\r\n\t// Build WASM project\r\n\t// Compile to WebAssembly\r\n\t// Generate bindings\r\n\t// This would involve executing shell commands\r\n\t// For now, just return nil as placeholder\r\n\t\r\n\tg.logger.Info(\"WASM project post-processing completed\",\r\n\t\t\"project\", req.Name,\r\n\t\t\"language\", g.language,\r\n\t\t\"features\", req.Features)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "generators",
          "dependencies": [
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 17,
          "code_snippet": "    12 | \t\"go.uber.org/zap\"\r\n    13 | \t\"gopkg.in/yaml.v3\"\r\n    14 | )\r\n    15 | \r\n    16 | // TemplateInfo holds information about a registered template\r\nâ†’   17 | type TemplateInfo struct {\r\n    18 | \tName         string            `json:\"name\"`\r\n    19 | \tStack        string            `json:\"stack\"`\r\n    20 | \tVersion      string            `json:\"version\"`\r\n    21 | \tSummary      string            `json:\"summary\"`\r\n    22 | \tPlaceholders []string          `json:\"placeholders\"`\r\n",
          "full_function": "type TemplateInfo struct {\r\n\tName         string            `json:\"name\"`\r\n\tStack        string            `json:\"stack\"`\r\n\tVersion      string            `json:\"version\"`\r\n\tSummary      string            `json:\"summary\"`\r\n\tPlaceholders []string          `json:\"placeholders\"`\r\n\tFiles        []string          `json:\"files\"`\r\n\tPath         string            `json:\"path\"`\r\n\tMetadata     map[string]string `json:\"metadata\"`\r\n\tLastModified string            `json:\"last_modified\"`\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\mcp\\registry\\mcp_registry.go",
          "line_number": 301,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 75,
          "code_snippet": "    70 | \t\t\t\t\tzap.String(\"path\", path), \r\n    71 | \t\t\t\t\tzap.Error(err))\r\n    72 | \t\t\t\treturn nil // Continue loading other templates\r\n    73 | \t\t\t}\r\n    74 | \r\nâ†’   75 | \t\t\ttemplateInfo.Path = relPath\r\n    76 | \t\t\ttr.templates[templateInfo.Name] = templateInfo\r\n    77 | \t\t\ttr.logger.Info(\"Loaded template\", \r\n    78 | \t\t\t\tzap.String(\"name\", templateInfo.Name),\r\n    79 | \t\t\t\tzap.String(\"stack\", templateInfo.Stack))\r\n    80 | \t\t}\r\n",
          "full_function": "func (tr *TemplateRegistry) LoadTemplates(ctx context.Context) error {\r\n\ttr.mu.Lock()\r\n\tdefer tr.mu.Unlock()\r\n\r\n\ttr.logger.Info(\"Loading templates from\", zap.String(\"path\", tr.basePath))\r\n\r\n\t// Walk through the templates directory\r\n\terr := filepath.WalkDir(tr.basePath, func(path string, d fs.DirEntry, err error) error {\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\r\n\t\t// Look for manifest.yaml files\r\n\t\tif d.Name() == \"manifest.yaml\" {\r\n\t\t\ttemplateDir := filepath.Dir(path)\r\n\t\t\trelPath, err := filepath.Rel(tr.basePath, templateDir)\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn err\r\n\t\t\t}\r\n\r\n\t\t\ttemplateInfo, err := tr.loadTemplateFromManifest(path)\r\n\t\t\tif err != nil {\r\n\t\t\t\ttr.logger.Error(\"Failed to load template\", \r\n\t\t\t\t\tzap.String(\"path\", path), \r\n\t\t\t\t\tzap.Error(err))\r\n\t\t\t\treturn nil // Continue loading other templates\r\n\t\t\t}\r\n\r\n\t\t\ttemplateInfo.Path = relPath\r\n\t\t\ttr.templates[templateInfo.Name] = templateInfo\r\n\t\t\ttr.logger.Info(\"Loaded template\", \r\n\t\t\t\tzap.String(\"name\", templateInfo.Name),\r\n\t\t\t\tzap.String(\"stack\", templateInfo.Stack))\r\n\t\t}\r\n\r\n\t\treturn nil\r\n\t})\r\n\r\n\tif err != nil {\r\n\t\treturn fmt.Errorf(\"failed to walk templates directory: %w\", err)\r\n\t}\r\n\r\n\ttr.logger.Info(\"Templates loaded successfully\", zap.Int(\"count\", len(tr.templates)))\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 124,
          "code_snippet": "   119 | \r\n   120 | \ttemplateInfo := \u0026TemplateInfo{\r\n   121 | \t\tName:         manifest.Name,\r\n   122 | \t\tStack:        manifest.Stack,\r\n   123 | \t\tVersion:      manifest.Version,\r\nâ†’  124 | \t\tSummary:      manifest.Summary,\r\n   125 | \t\tPlaceholders: manifest.Placeholders,\r\n   126 | \t\tFiles:        manifest.Files,\r\n   127 | \t\tMetadata:     make(map[string]string),\r\n   128 | \t}\r\n   129 | \r\n",
          "full_function": "\t\tSummary:      manifest.Summary,\r\n\t\tPlaceholders: manifest.Placeholders,\r\n\t\tFiles:        manifest.Files,\r\n\t\tMetadata:     make(map[string]string),\r\n\t}\r\n\r\n\treturn templateInfo, nil\r\n}\r\n\r\n// GetTemplate returns a template by name\r\nfunc (tr *TemplateRegistry) GetTemplate(name string) (*TemplateInfo, error) {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplate, exists := tr.templates[name]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"template '%s' not found\", name)\r\n\t}\r\n\r\n\treturn template, nil\r\n}\r\n\r\n// ListTemplates returns all registered templates\r\nfunc (tr *TemplateRegistry) ListTemplates() []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplates := make([]*TemplateInfo, 0, len(tr.templates))\r\n\tfor _, template := range tr.templates {\r\n\t\ttemplates = append(templates, template)\r\n\t}\r\n\r\n\treturn templates\r\n}\r\n\r\n// ListTemplatesByStack returns templates filtered by stack\r\nfunc (tr *TemplateRegistry) ListTemplatesByStack(stack string) []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\tvar templates []*TemplateInfo\r\n\tfor _, template := range tr.templates {\r\n\t\tif template.Stack == stack {\r\n\t\t\ttemplates = append(templates, template)\r\n\t\t}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 125,
          "code_snippet": "   120 | \ttemplateInfo := \u0026TemplateInfo{\r\n   121 | \t\tName:         manifest.Name,\r\n   122 | \t\tStack:        manifest.Stack,\r\n   123 | \t\tVersion:      manifest.Version,\r\n   124 | \t\tSummary:      manifest.Summary,\r\nâ†’  125 | \t\tPlaceholders: manifest.Placeholders,\r\n   126 | \t\tFiles:        manifest.Files,\r\n   127 | \t\tMetadata:     make(map[string]string),\r\n   128 | \t}\r\n   129 | \r\n   130 | \treturn templateInfo, nil\r\n",
          "full_function": "\t\tPlaceholders: manifest.Placeholders,\r\n\t\tFiles:        manifest.Files,\r\n\t\tMetadata:     make(map[string]string),\r\n\t}\r\n\r\n\treturn templateInfo, nil\r\n}\r\n\r\n// GetTemplate returns a template by name\r\nfunc (tr *TemplateRegistry) GetTemplate(name string) (*TemplateInfo, error) {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplate, exists := tr.templates[name]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"template '%s' not found\", name)\r\n\t}\r\n\r\n\treturn template, nil\r\n}\r\n\r\n// ListTemplates returns all registered templates\r\nfunc (tr *TemplateRegistry) ListTemplates() []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplates := make([]*TemplateInfo, 0, len(tr.templates))\r\n\tfor _, template := range tr.templates {\r\n\t\ttemplates = append(templates, template)\r\n\t}\r\n\r\n\treturn templates\r\n}\r\n\r\n// ListTemplatesByStack returns templates filtered by stack\r\nfunc (tr *TemplateRegistry) ListTemplatesByStack(stack string) []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\tvar templates []*TemplateInfo\r\n\tfor _, template := range tr.templates {\r\n\t\tif template.Stack == stack {\r\n\t\t\ttemplates = append(templates, template)\r\n\t\t}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 21,
          "code_snippet": "    16 | \r\n    17 | // NewServiceDiscovery creates a new service discovery instance\r\n    18 | func NewServiceDiscovery(registry *MCPRegistry) *ServiceDiscovery {\r\n    19 | \treturn \u0026ServiceDiscovery{\r\n    20 | \t\tregistry: registry,\r\nâ†’   21 | \t\tlogger:   logger.GetLogger(),\r\n    22 | \t}\r\n    23 | }\r\n    24 | \r\n    25 | // DiscoverServices discovers services in the registry\r\n    26 | func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n",
          "full_function": "func NewServiceDiscovery(registry *MCPRegistry) *ServiceDiscovery {\r\n\treturn \u0026ServiceDiscovery{\r\n\t\tregistry: registry,\r\n\t\tlogger:   logger.GetLogger(),\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 27,
          "code_snippet": "    22 | \t}\r\n    23 | }\r\n    24 | \r\n    25 | // DiscoverServices discovers services in the registry\r\n    26 | func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\nâ†’   27 | \tsd.mu.RLock()\r\n    28 | \tdefer sd.mu.RUnlock()\r\n    29 | \r\n    30 | \tvar results []*ServiceInfo\r\n    31 | \t\r\n    32 | \tfor _, service := range sd.registry.services {\r\n",
          "full_function": "func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n\tsd.mu.RLock()\r\n\tdefer sd.mu.RUnlock()\r\n\r\n\tvar results []*ServiceInfo\r\n\t\r\n\tfor _, service := range sd.registry.services {\r\n\t\tif matchesQuery(service, query) {\r\n\t\t\tresults = append(results, service)\r\n\t\t}\r\n\t}\r\n\r\n\treturn results, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 28,
          "code_snippet": "    23 | }\r\n    24 | \r\n    25 | // DiscoverServices discovers services in the registry\r\n    26 | func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n    27 | \tsd.mu.RLock()\r\nâ†’   28 | \tdefer sd.mu.RUnlock()\r\n    29 | \r\n    30 | \tvar results []*ServiceInfo\r\n    31 | \t\r\n    32 | \tfor _, service := range sd.registry.services {\r\n    33 | \t\tif matchesQuery(service, query) {\r\n",
          "full_function": "func (sd *ServiceDiscovery) DiscoverServices(ctx context.Context, query string) ([]*ServiceInfo, error) {\r\n\tsd.mu.RLock()\r\n\tdefer sd.mu.RUnlock()\r\n\r\n\tvar results []*ServiceInfo\r\n\t\r\n\tfor _, service := range sd.registry.services {\r\n\t\tif matchesQuery(service, query) {\r\n\t\t\tresults = append(results, service)\r\n\t\t}\r\n\t}\r\n\r\n\treturn results, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\discovery.go",
          "line_number": 51,
          "code_snippet": "    46 | \t\r\n    47 | \t// Simple string matching - could be enhanced with regex or fuzzy matching\r\n    48 | \treturn fmt.Sprintf(\"%s %s %s\", \r\n    49 | \t\tservice.Name, \r\n    50 | \t\tservice.Type, \r\nâ†’   51 | \t\tservice.Description) == query\r\n    52 | }\r\n    53 | \r\n    54 | // WatchServices watches for changes in services\r\n    55 | func (sd *ServiceDiscovery) WatchServices(ctx context.Context) (\u003c-chan *ServiceEvent, error) {\r\n    56 | \teventChan := make(chan *ServiceEvent, 100)\r\n",
          "full_function": "func matchesQuery(service *ServiceInfo, query string) bool {\r\n\tif query == \"\" {\r\n\t\treturn true\r\n\t}\r\n\t\r\n\t// Simple string matching - could be enhanced with regex or fuzzy matching\r\n\treturn fmt.Sprintf(\"%s %s %s\", \r\n\t\tservice.Name, \r\n\t\tservice.Type, \r\n\t\tservice.Description) == query\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\service_registry.go",
          "line_number": 33,
          "code_snippet": "    28 | // RegisterService registers a new service\r\n    29 | func (sr *ServiceRegistry) RegisterService(ctx context.Context, service *ServiceInfo) error {\r\n    30 | \tsr.mu.Lock()\r\n    31 | \tdefer sr.mu.Unlock()\r\n    32 | \r\nâ†’   33 | \tservice.LastChecked = time.Now()\r\n    34 | \tsr.services[service.ID] = service\r\n    35 | \t\r\n    36 | \tsr.logger.Info(\"Service registered\",\r\n    37 | \t\tzap.String(\"id\", service.ID),\r\n    38 | \t\tzap.String(\"name\", service.Name),\r\n",
          "full_function": "func (sr *ServiceRegistry) RegisterService(ctx context.Context, service *ServiceInfo) error {\r\n\tsr.mu.Lock()\r\n\tdefer sr.mu.Unlock()\r\n\r\n\tservice.LastChecked = time.Now()\r\n\tsr.services[service.ID] = service\r\n\t\r\n\tsr.logger.Info(\"Service registered\",\r\n\t\tzap.String(\"id\", service.ID),\r\n\t\tzap.String(\"name\", service.Name),\r\n\t\tzap.String(\"type\", service.Type))\r\n\t\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\service_registry.go",
          "line_number": 96,
          "code_snippet": "    91 | \tif !exists {\r\n    92 | \t\treturn fmt.Errorf(\"service %s not found\", serviceID)\r\n    93 | \t}\r\n    94 | \r\n    95 | \tservice.Status = status\r\nâ†’   96 | \tservice.LastChecked = time.Now()\r\n    97 | \t\r\n    98 | \tsr.logger.Info(\"Service status updated\",\r\n    99 | \t\tzap.String(\"id\", serviceID),\r\n   100 | \t\tzap.String(\"status\", status))\r\n   101 | \t\r\n",
          "full_function": "func (sr *ServiceRegistry) UpdateServiceStatus(ctx context.Context, serviceID, status string) error {\r\n\tsr.mu.Lock()\r\n\tdefer sr.mu.Unlock()\r\n\r\n\tservice, exists := sr.services[serviceID]\r\n\tif !exists {\r\n\t\treturn fmt.Errorf(\"service %s not found\", serviceID)\r\n\t}\r\n\r\n\tservice.Status = status\r\n\tservice.LastChecked = time.Now()\r\n\t\r\n\tsr.logger.Info(\"Service status updated\",\r\n\t\tzap.String(\"id\", serviceID),\r\n\t\tzap.String(\"status\", status))\r\n\t\r\n\treturn nil\r\n}",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\mcp\\registry\\template_registry.go",
          "line_number": 125,
          "code_snippet": "   120 | \ttemplateInfo := \u0026TemplateInfo{\r\n   121 | \t\tName:         manifest.Name,\r\n   122 | \t\tStack:        manifest.Stack,\r\n   123 | \t\tVersion:      manifest.Version,\r\n   124 | \t\tSummary:      manifest.Summary,\r\nâ†’  125 | \t\tPlaceholders: manifest.Placeholders,\r\n   126 | \t\tFiles:        manifest.Files,\r\n   127 | \t\tMetadata:     make(map[string]string),\r\n   128 | \t}\r\n   129 | \r\n   130 | \treturn templateInfo, nil\r\n",
          "full_function": "\t\tPlaceholders: manifest.Placeholders,\r\n\t\tFiles:        manifest.Files,\r\n\t\tMetadata:     make(map[string]string),\r\n\t}\r\n\r\n\treturn templateInfo, nil\r\n}\r\n\r\n// GetTemplate returns a template by name\r\nfunc (tr *TemplateRegistry) GetTemplate(name string) (*TemplateInfo, error) {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplate, exists := tr.templates[name]\r\n\tif !exists {\r\n\t\treturn nil, fmt.Errorf(\"template '%s' not found\", name)\r\n\t}\r\n\r\n\treturn template, nil\r\n}\r\n\r\n// ListTemplates returns all registered templates\r\nfunc (tr *TemplateRegistry) ListTemplates() []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\ttemplates := make([]*TemplateInfo, 0, len(tr.templates))\r\n\tfor _, template := range tr.templates {\r\n\t\ttemplates = append(templates, template)\r\n\t}\r\n\r\n\treturn templates\r\n}\r\n\r\n// ListTemplatesByStack returns templates filtered by stack\r\nfunc (tr *TemplateRegistry) ListTemplatesByStack(stack string) []*TemplateInfo {\r\n\ttr.mu.RLock()\r\n\tdefer tr.mu.RUnlock()\r\n\r\n\tvar templates []*TemplateInfo\r\n\tfor _, template := range tr.templates {\r\n\t\tif template.Stack == stack {\r\n\t\t\ttemplates = append(templates, template)\r\n\t\t}\r",
          "symbol_name": "",
          "package_name": "registry",
          "dependencies": [
            "context",
            "fmt",
            "io/fs",
            "path/filepath",
            "strings",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "gopkg.in/yaml.v3"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\adapters\\redis\\reservation_lock.go",
          "line_number": 55,
          "code_snippet": "    50 | // ReleaseLock releases a distributed lock\r\n    51 | func (l *ReservationLock) ReleaseLock(ctx context.Context, key string) error {\r\n    52 | \tlockKey := lockKey(key)\r\n    53 | \r\n    54 | \t// Lua script for atomic lock release (only if we own it)\r\nâ†’   55 | \tscript := `\r\n    56 | \t\tif redis.call(\"get\", KEYS[1]) == ARGV[1] then\r\n    57 | \t\t\treturn redis.call(\"del\", KEYS[1])\r\n    58 | \t\telse\r\n    59 | \t\t\treturn 0\r\n    60 | \t\tend\r\n",
          "full_function": "func (l *ReservationLock) ReleaseLock(ctx context.Context, key string) error {\r\n\tlockKey := lockKey(key)\r\n\r\n\t// Lua script for atomic lock release (only if we own it)\r\n\tscript := `\r\n\t\tif redis.call(\"get\", KEYS[1]) == ARGV[1] then\r\n\t\t\treturn redis.call(\"del\", KEYS[1])\r\n\t\telse\r\n\t\t\treturn 0\r\n\t\tend\r\n\t`\r\n\r\n\t// Note: In a real implementation, we'd need to store the lock value\r\n\t// to properly release it. For simplicity, we'll use a simpler approach.\r\n\t_, err := l.client.Del(ctx, lockKey).Result()\r\n\treturn err\r\n}\r",
          "symbol_name": "",
          "package_name": "redis",
          "dependencies": [
            "context",
            "fmt",
            "time",
            "github.com/go-redis/redis/v8"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\cmd\\tools-validator\\main.go",
          "line_number": 60,
          "code_snippet": "    55 | \t\tresult, err = validator.ValidateTemplate(ctx, req)\r\n    56 | \r\n    57 | \tcase \"config\":\r\n    58 | \t\treq := validators.ConfigValidateRequest{\r\n    59 | \t\t\tPath:       path,\r\nâ†’   60 | \t\t\tStrictMode: strictMode,\r\n    61 | \t\t}\r\n    62 | \t\tvalidator := validators.NewConfigValidator()\r\n    63 | \t\tresult, err = validator.ValidateConfig(ctx, req)\r\n    64 | \r\n    65 | \tcase \"code\":\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "main",
          "dependencies": [
            "context",
            "encoding/json",
            "flag",
            "fmt",
            "os",
            "github.com/vertikon/mcp-core-inventory/tools/validators"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\memory_optimizer.go",
          "line_number": 31,
          "code_snippet": "    26 | \r\n    27 | // EvictionPolicy represents different eviction strategies\r\n    28 | type EvictionPolicy string\r\n    29 | \r\n    30 | const (\r\nâ†’   31 | \tPolicyLRU      EvictionPolicy = \"lru\"\r\n    32 | \tPolicyLFU      EvictionPolicy = \"lfu\"\r\n    33 | \tPolicyFIFO     EvictionPolicy = \"fifo\"\r\n    34 | \tPolicyRandom   EvictionPolicy = \"random\"\r\n    35 | \tPolicyTTL      EvictionPolicy = \"ttl\"\r\n    36 | )\r\n",
          "full_function": "\tPolicyLRU      EvictionPolicy = \"lru\"\r\n\tPolicyLFU      EvictionPolicy = \"lfu\"\r\n\tPolicyFIFO     EvictionPolicy = \"fifo\"\r\n\tPolicyRandom   EvictionPolicy = \"random\"\r\n\tPolicyTTL      EvictionPolicy = \"ttl\"\r\n)\r\n\r\n// MemoryPool represents a pooled memory allocator\r\ntype MemoryPool struct {\r\n\tconfig         MemoryOptimizerConfig\r\n\tpools          map[int]*MemorySegment\r\n\tfreeSegments   chan *MemorySegment\r\n\tusedSegments   map[string]*MemorySegment\r\n\tsegmentsMu     sync.RWMutex\r\n\tstats          *MemoryPoolStats\r\n\tcompactor      *MemoryCompactor\r\n\tgarbageCollector *GarbageCollector\r\n\tctx            context.Context\r\n\tcancel         context.CancelFunc\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\core\\crush\\batch_processor.go",
          "line_number": 155,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\memory_optimizer.go",
          "line_number": 395,
          "code_snippet": "   390 | \t\t\tcontinue\r\n   391 | \t\t}\r\n   392 | \r\n   393 | \t\t// Check based on policy\r\n   394 | \t\tswitch mo.config.EvictionPolicy {\r\nâ†’  395 | \t\tcase PolicyLRU:\r\n   396 | \t\t\t// Will be sorted by LastUsed\r\n   397 | \t\tcase PolicyLFU:\r\n   398 | \t\t\t// Will be sorted by AccessCount\r\n   399 | \t\tcase PolicyTTL:\r\n   400 | \t\t\t// Already handled\r\n",
          "full_function": "\t\tcase PolicyLRU:\r\n\t\t\t// Will be sorted by LastUsed\r\n\t\tcase PolicyLFU:\r\n\t\t\t// Will be sorted by AccessCount\r\n\t\tcase PolicyTTL:\r\n\t\t\t// Already handled\r\n\t\t}\r\n\t}\r\n\r\n\t// Sort candidates based on eviction policy\r\n\tmo.sortEvictionCandidates(candidates)\r\n\r\n\t// Evict candidates (remove oldest 20%)\r\n\tevictCount := max(1, len(candidates)/5)\r\n\tfor i := 0; i \u003c evictCount \u0026\u0026 i \u003c len(candidates); i++ {\r\n\t\tsegment := candidates[i]\r\n\t\tdelete(mo.usedSegments, segment.ID)\r\n\t\t\r\n\t\t// Add to free pool\r\n\t\tselect {\r\n\t\tcase mo.freeSegments \u003c- segment:\r\n\t\tdefault:\r\n\t\t}\r\n\t\t\r\n\t\tatomic.AddInt64(\u0026mo.stats.Evictions, 1)\r\n\t\t\r\n\t\tlogger.Debug(\"Evicted memory segment\",\r\n\t\t\tzap.String(\"segment_id\", segment.ID),\r\n\t\t\tzap.Int(\"size\", segment.Size),\r\n\t\t)\r\n\t}\r\n}\r\n\r\n// sortEvictionCandidates sorts candidates based on eviction policy\r\nfunc (mo *MemoryPool) sortEvictionCandidates(candidates []*MemorySegment) {\r\n\tswitch mo.config.EvictionPolicy {\r\n\tcase PolicyLRU:\r\n\t\t// Sort by LastUsed (oldest first)\r\n\t\tfor i := 0; i \u003c len(candidates)-1; i++ {\r\n\t\t\tfor j := i + 1; j \u003c len(candidates); j++ {\r\n\t\t\t\tif candidates[i].LastUsed.After(candidates[j].LastUsed) {\r\n\t\t\t\t\tcandidates[i], candidates[j] = candidates[j], candidates[i]\r\n\t\t\t\t}\r\n\t\t\t}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 625,
          "code_snippet": "   620 | \tas.stats.ScaleDownEvents++\r\n   621 | \tnow := time.Now()\r\n   622 | \tas.stats.LastScalingTime = \u0026now\r\n   623 | }\r\n   624 | \r\nâ†’  625 | func min(a, b int) int {\r\n   626 | \tif a \u003c b {\r\n   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n",
          "full_function": "func min(a, b int) int {\r\n\tif a \u003c b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\core\\crush\\batch_processor.go",
          "line_number": 796,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\parallel_processor.go",
          "line_number": 632,
          "code_snippet": "   627 | \t\treturn a\r\n   628 | \t}\r\n   629 | \treturn b\r\n   630 | }\r\n   631 | \r\nâ†’  632 | func max(a, b int) int {\r\n   633 | \tif a \u003e b {\r\n   634 | \t\treturn a\r\n   635 | \t}\r\n   636 | \treturn b\r\n   637 | }\n",
          "full_function": "func max(a, b int) int {\r\n\tif a \u003e b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\core\\crush\\batch_processor.go",
          "line_number": 803,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 269,
          "code_snippet": "   264 | \r\n   265 | \t// Initialize async processor\r\n   266 | \tif config.EnableAsync {\r\n   267 | \t\tprocessor.asyncProcessor = NewAsyncBatchProcessor(AsyncProcessingConfig{\r\n   268 | \t\t\tEnabled:       true,\r\nâ†’  269 | \t\t\tNumWorkers:    runtime.NumCPU(),\r\n   270 | \t\t\tQueueSize:     100,\r\n   271 | \t\t\tWorkerTimeout: config.Timeout,\r\n   272 | \t\t\tRetryAttempts: 3,\r\n   273 | \t\t})\r\n   274 | \t}\r\n",
          "full_function": "func NewBatchProcessor(config BatchProcessorConfig) *BatchProcessor {\r\n\tif config.MaxBatchSize == 0 {\r\n\t\tconfig.MaxBatchSize = 32\r\n\t}\r\n\tif config.MinBatchSize == 0 {\r\n\t\tconfig.MinBatchSize = 1\r\n\t}\r\n\tif config.Timeout == 0 {\r\n\t\tconfig.Timeout = 5 * time.Second\r\n\t}\r\n\r\n\tlogger.Info(\"Creating batch processor\",\r\n\t\tzap.Int(\"max_batch_size\", config.MaxBatchSize),\r\n\t\tzap.Int(\"min_batch_size\", config.MinBatchSize),\r\n\t\tzap.Duration(\"timeout\", config.Timeout),\r\n\t\tzap.Bool(\"dynamic_batching\", config.EnableDynamicBatching),\r\n\t\tzap.Bool(\"prefetch\", config.EnablePrefetch),\r\n\t\tzap.Bool(\"async\", config.EnableAsync),\r\n\t)\r\n\r\n\tctx, cancel := context.WithCancel(context.Background())\r\n\t\r\n\tprocessor := \u0026BatchProcessor{\r\n\t\tconfig:      config,\r\n\t\tbatches:     make(map[string]*Batch),\r\n\t\tbatchQueue:  make(chan *Batch, 100),\r\n\t\tresultQueue: make(chan *BatchResult, 100),\r\n\t\tctx:         ctx,\r\n\t\tcancel:      cancel,\r\n\t\tstats:       \u0026BatchProcessorStats{},\r\n\t}\r\n\r\n\t// Initialize dynamic sizing\r\n\tif config.EnableDynamicBatching {\r\n\t\tprocessor.dynamicSizing = NewDynamicBatchSizer(DynamicSizingConfig{\r\n\t\t\tEnabled:   true,\r\n\t\t\tStrategy:  StrategyAdaptive,\r\n\t\t\tMinSize:   config.MinBatchSize,\r\n\t\t\tMaxSize:   config.MaxBatchSize,\r\n\t\t\tTargetLatency: config.MaxLatency,\r\n\t\t})\r\n\t}\r\n\r\n\t// Initialize prefetcher\r\n\tif config.EnablePrefetch {\r\n\t\tprocessor.prefetcher = NewBatchPrefetcher(PrefetchConfig{\r\n\t\t\tEnabled:      true,\r\n\t\t\tPrefetchSize: config.MaxBatchSize,\r\n\t\t\tCacheSize:    100,\r\n\t\t\tPrefetchPolicy: PolicyPredictive,\r\n\t\t})\r\n\t}\r\n\r\n\t// Initialize async processor\r\n\tif config.EnableAsync {\r\n\t\tprocessor.asyncProcessor = NewAsyncBatchProcessor(AsyncProcessingConfig{\r\n\t\t\tEnabled:       true,\r\n\t\t\tNumWorkers:    runtime.NumCPU(),\r\n\t\t\tQueueSize:     100,\r\n\t\t\tWorkerTimeout: config.Timeout,\r\n\t\t\tRetryAttempts: 3,\r\n\t\t})\r\n\t}\r\n\r\n\treturn processor\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 427,
          "code_snippet": "   422 | func (bp *BatchProcessor) checkBatchTimeouts() {\r\n   423 | \tbp.mu.Lock()\r\n   424 | \tdefer bp.mu.Unlock()\r\n   425 | \r\n   426 | \tnow := time.Now()\r\nâ†’  427 | \tfor id, batch := range bp.batches {\r\n   428 | \t\tif now.Sub(batch.CreatedAt) \u003e= batch.Timeout \u0026\u0026 len(batch.Items) \u003e 0 {\r\n   429 | \t\t\tbp.submitBatch(batch)\r\n   430 | \t\t}\r\n   431 | \t}\r\n   432 | }\r\n",
          "full_function": "func (bp *BatchProcessor) checkBatchTimeouts() {\r\n\tbp.mu.Lock()\r\n\tdefer bp.mu.Unlock()\r\n\r\n\tnow := time.Now()\r\n\tfor id, batch := range bp.batches {\r\n\t\tif now.Sub(batch.CreatedAt) \u003e= batch.Timeout \u0026\u0026 len(batch.Items) \u003e 0 {\r\n\t\t\tbp.submitBatch(batch)\r\n\t\t}\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 560,
          "code_snippet": "   555 | // updateStats updates batch processing statistics\r\n   556 | func (bp *BatchProcessor) updateStats(batch *Batch, result *BatchResult) {\r\n   557 | \tatomic.AddInt64(\u0026bp.stats.TotalBatches, 1)\r\n   558 | \tatomic.AddInt64(\u0026bp.stats.TotalItems, int64(batch.Size))\r\n   559 | \tatomic.AddInt64(\u0026bp.stats.CompletedBatches, 1)\r\nâ†’  560 | \tatomic.AddInt64(\u0026bp.stats.TotalProcessingTime, int64(result.Duration))\r\n   561 | \r\n   562 | \tif len(result.Errors) \u003e 0 {\r\n   563 | \t\tatomic.AddInt64(\u0026bp.stats.FailedBatches, 1)\r\n   564 | \t}\r\n   565 | }\r\n",
          "full_function": "func (bp *BatchProcessor) updateStats(batch *Batch, result *BatchResult) {\r\n\tatomic.AddInt64(\u0026bp.stats.TotalBatches, 1)\r\n\tatomic.AddInt64(\u0026bp.stats.TotalItems, int64(batch.Size))\r\n\tatomic.AddInt64(\u0026bp.stats.CompletedBatches, 1)\r\n\tatomic.AddInt64(\u0026bp.stats.TotalProcessingTime, int64(result.Duration))\r\n\r\n\tif len(result.Errors) \u003e 0 {\r\n\t\tatomic.AddInt64(\u0026bp.stats.FailedBatches, 1)\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 584,
          "code_snippet": "   579 | \t\tbp.stats.AvgBatchSize = float64(totalItems) / float64(totalBatches)\r\n   580 | \t}\r\n   581 | \r\n   582 | \t// Calculate average processing time\r\n   583 | \tcompletedBatches := atomic.LoadInt64(\u0026bp.stats.CompletedBatches)\r\nâ†’  584 | \ttotalProcessingTime := atomic.LoadInt64(\u0026bp.stats.TotalProcessingTime)\r\n   585 | \t\r\n   586 | \tif completedBatches \u003e 0 {\r\n   587 | \t\tbp.stats.AvgProcessingTime = time.Duration(totalProcessingTime / completedBatches)\r\n   588 | \t}\r\n   589 | \r\n",
          "full_function": "func (bp *BatchProcessor) collectStats() {\r\n\tbp.stats.LastUpdated = time.Now()\r\n\r\n\t// Calculate queue utilization\r\n\tbp.stats.QueueUtilization = float64(len(bp.batchQueue)) / float64(cap(bp.batchQueue))\r\n\r\n\t// Calculate average batch size\r\n\ttotalBatches := atomic.LoadInt64(\u0026bp.stats.TotalBatches)\r\n\ttotalItems := atomic.LoadInt64(\u0026bp.stats.TotalItems)\r\n\t\r\n\tif totalBatches \u003e 0 {\r\n\t\tbp.stats.AvgBatchSize = float64(totalItems) / float64(totalBatches)\r\n\t}\r\n\r\n\t// Calculate average processing time\r\n\tcompletedBatches := atomic.LoadInt64(\u0026bp.stats.CompletedBatches)\r\n\ttotalProcessingTime := atomic.LoadInt64(\u0026bp.stats.TotalProcessingTime)\r\n\t\r\n\tif completedBatches \u003e 0 {\r\n\t\tbp.stats.AvgProcessingTime = time.Duration(totalProcessingTime / completedBatches)\r\n\t}\r\n\r\n\t// Calculate throughput\r\n\tif completedBatches \u003e 0 {\r\n\t\tbp.stats.Throughput = float64(totalItems) / time.Since(time.Now()).Seconds()\r\n\t}\r\n\r\n\tlogger.Debug(\"Batch processor stats\",\r\n\t\tzap.Float64(\"queue_utilization\", bp.stats.QueueUtilization),\r\n\t\tzap.Float64(\"avg_batch_size\", bp.stats.AvgBatchSize),\r\n\t\tzap.Duration(\"avg_processing_time\", bp.stats.AvgProcessingTime),\r\n\t\tzap.Float64(\"throughput\", bp.stats.Throughput),\r\n\t)\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 781,
          "code_snippet": "   776 | \r\n   777 | // NewAsyncBatchProcessor creates a new async batch processor\r\n   778 | func NewAsyncBatchProcessor(config AsyncProcessingConfig) *AsyncBatchProcessor {\r\n   779 | \treturn \u0026AsyncBatchProcessor{\r\n   780 | \t\tconfig:     config,\r\nâ†’  781 | \t\tworkerPool: NewWorkerPool(config.NumWorkers, config.QueueSize, config.WorkerTimeout),\r\n   782 | \t\tstats:      \u0026AsyncProcessingStats{},\r\n   783 | \t}\r\n   784 | }\r\n   785 | \r\n   786 | // Start starts async batch processor\r\n",
          "full_function": "func NewAsyncBatchProcessor(config AsyncProcessingConfig) *AsyncBatchProcessor {\r\n\treturn \u0026AsyncBatchProcessor{\r\n\t\tconfig:     config,\r\n\t\tworkerPool: NewWorkerPool(config.NumWorkers, config.QueueSize, config.WorkerTimeout),\r\n\t\tstats:      \u0026AsyncProcessingStats{},\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\batch_processor.go",
          "line_number": 792,
          "code_snippet": "   787 | func (abp *AsyncBatchProcessor) Start(ctx context.Context) {\r\n   788 | \tif !abp.config.Enabled {\r\n   789 | \t\treturn\r\n   790 | \t}\r\n   791 | \r\nâ†’  792 | \tabp.workerPool.Start(ctx)\r\n   793 | }\r\n   794 | \r\n   795 | // Additional helper functions\r\n   796 | func min(a, b int) int {\r\n   797 | \tif a \u003c b {\r\n",
          "full_function": "func (abp *AsyncBatchProcessor) Start(ctx context.Context) {\r\n\tif !abp.config.Enabled {\r\n\t\treturn\r\n\t}\r\n\r\n\tabp.workerPool.Start(ctx)\r\n}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\crush\\memory_optimizer.go",
          "line_number": 395,
          "code_snippet": "   390 | \t\t\tcontinue\r\n   391 | \t\t}\r\n   392 | \r\n   393 | \t\t// Check based on policy\r\n   394 | \t\tswitch mo.config.EvictionPolicy {\r\nâ†’  395 | \t\tcase PolicyLRU:\r\n   396 | \t\t\t// Will be sorted by LastUsed\r\n   397 | \t\tcase PolicyLFU:\r\n   398 | \t\t\t// Will be sorted by AccessCount\r\n   399 | \t\tcase PolicyTTL:\r\n   400 | \t\t\t// Already handled\r\n",
          "full_function": "\t\tcase PolicyLRU:\r\n\t\t\t// Will be sorted by LastUsed\r\n\t\tcase PolicyLFU:\r\n\t\t\t// Will be sorted by AccessCount\r\n\t\tcase PolicyTTL:\r\n\t\t\t// Already handled\r\n\t\t}\r\n\t}\r\n\r\n\t// Sort candidates based on eviction policy\r\n\tmo.sortEvictionCandidates(candidates)\r\n\r\n\t// Evict candidates (remove oldest 20%)\r\n\tevictCount := max(1, len(candidates)/5)\r\n\tfor i := 0; i \u003c evictCount \u0026\u0026 i \u003c len(candidates); i++ {\r\n\t\tsegment := candidates[i]\r\n\t\tdelete(mo.usedSegments, segment.ID)\r\n\t\t\r\n\t\t// Add to free pool\r\n\t\tselect {\r\n\t\tcase mo.freeSegments \u003c- segment:\r\n\t\tdefault:\r\n\t\t}\r\n\t\t\r\n\t\tatomic.AddInt64(\u0026mo.stats.Evictions, 1)\r\n\t\t\r\n\t\tlogger.Debug(\"Evicted memory segment\",\r\n\t\t\tzap.String(\"segment_id\", segment.ID),\r\n\t\t\tzap.Int(\"size\", segment.Size),\r\n\t\t)\r\n\t}\r\n}\r\n\r\n// sortEvictionCandidates sorts candidates based on eviction policy\r\nfunc (mo *MemoryPool) sortEvictionCandidates(candidates []*MemorySegment) {\r\n\tswitch mo.config.EvictionPolicy {\r\n\tcase PolicyLRU:\r\n\t\t// Sort by LastUsed (oldest first)\r\n\t\tfor i := 0; i \u003c len(candidates)-1; i++ {\r\n\t\t\tfor j := i + 1; j \u003c len(candidates); j++ {\r\n\t\t\t\tif candidates[i].LastUsed.After(candidates[j].LastUsed) {\r\n\t\t\t\t\tcandidates[i], candidates[j] = candidates[j], candidates[i]\r\n\t\t\t\t}\r\n\t\t\t}\r",
          "symbol_name": "",
          "package_name": "crush",
          "dependencies": [
            "context",
            "fmt",
            "runtime",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\domain\\services\\ai_domain_service.go",
          "line_number": 33,
          "code_snippet": "    28 | \tcontext := mcp.Context()\r\n    29 | \tif context == nil {\r\n    30 | \t\treturn fmt.Errorf(\"knowledge context is nil\")\r\n    31 | \t}\r\n    32 | \r\nâ†’   33 | \tif len(context.documents) == 0 {\r\n    34 | \t\treturn fmt.Errorf(\"knowledge context must have at least one document\")\r\n    35 | \t}\r\n    36 | \r\n    37 | \treturn nil\r\n    38 | }\r\n",
          "full_function": "func (s *AIDomainService) ValidateKnowledgeContext(mcp *entities.MCP) error {\r\n\tif mcp == nil {\r\n\t\treturn fmt.Errorf(\"MCP cannot be nil\")\r\n\t}\r\n\r\n\tif !mcp.HasContext() {\r\n\t\treturn fmt.Errorf(\"MCP does not have knowledge context\")\r\n\t}\r\n\r\n\tcontext := mcp.Context()\r\n\tif context == nil {\r\n\t\treturn fmt.Errorf(\"knowledge context is nil\")\r\n\t}\r\n\r\n\tif len(context.documents) == 0 {\r\n\t\treturn fmt.Errorf(\"knowledge context must have at least one document\")\r\n\t}\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "services",
          "dependencies": [
            "fmt",
            "github.com/vertikon/mcp-core-inventory/internal/domain/entities"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 543,
          "code_snippet": "   538 | \t}\r\n   539 | \r\n   540 | \tstart := time.Now()\r\n   541 | \tdefer func() {\r\n   542 | \t\tatomic.AddInt64(\u0026dss.stats.LockOperations, 1)\r\nâ†’  543 | \t\tatomic.StoreInt64(\u0026dss.stats.LockWaitTime.Nanoseconds(), time.Since(start).Nanoseconds())\r\n   544 | \t}()\r\n   545 | \r\n   546 | \t// Try remote store first\r\n   547 | \tlock, err := dss.remoteStore.Lock(ctx, key, ttl)\r\n   548 | \tif err == nil {\r\n",
          "full_function": "func (dss *DistributedStateStore) Lock(ctx context.Context, key string, ttl time.Duration) (*Lock, error) {\r\n\tif !dss.config.EnableLocking {\r\n\t\treturn nil, fmt.Errorf(\"locking is not enabled\")\r\n\t}\r\n\r\n\tstart := time.Now()\r\n\tdefer func() {\r\n\t\tatomic.AddInt64(\u0026dss.stats.LockOperations, 1)\r\n\t\tatomic.StoreInt64(\u0026dss.stats.LockWaitTime.Nanoseconds(), time.Since(start).Nanoseconds())\r\n\t}()\r\n\r\n\t// Try remote store first\r\n\tlock, err := dss.remoteStore.Lock(ctx, key, ttl)\r\n\tif err == nil {\r\n\t\treturn lock, nil\r\n\t}\r\n\r\n\t// Fallback to local store\r\n\treturn dss.localStore.Lock(ctx, key, ttl)\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 649,
          "code_snippet": "   644 | \treturn *dss.stats\r\n   645 | }\r\n   646 | \r\n   647 | // updateReadLatency updates read latency statistics\r\n   648 | func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\nâ†’  649 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n   650 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n   651 | \tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n   652 | }\r\n   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n",
          "full_function": "func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 651,
          "code_snippet": "   646 | \r\n   647 | // updateReadLatency updates read latency statistics\r\n   648 | func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\n   649 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n   650 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\nâ†’  651 | \tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n   652 | }\r\n   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n   655 | func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n   656 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n",
          "full_function": "func (dss *DistributedStateStore) updateReadLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 656,
          "code_snippet": "   651 | \tatomic.StoreInt64(\u0026dss.stats.AvgReadLatency.Nanoseconds(), int64(newAvg))\r\n   652 | }\r\n   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n   655 | func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\nâ†’  656 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n   657 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n   658 | \tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n   659 | }\r\n   660 | \r\n   661 | // NewMemoryStateStore creates a new in-memory state store\r\n",
          "full_function": "func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\distributed_store.go",
          "line_number": 658,
          "code_snippet": "   653 | \r\n   654 | // updateWriteLatency updates write latency statistics\r\n   655 | func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n   656 | \tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n   657 | \tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\nâ†’  658 | \tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n   659 | }\r\n   660 | \r\n   661 | // NewMemoryStateStore creates a new in-memory state store\r\n   662 | func NewMemoryStateStore() *MemoryStateStore {\r\n   663 | \treturn \u0026MemoryStateStore{\r\n",
          "full_function": "func (dss *DistributedStateStore) updateWriteLatency(latency time.Duration) {\r\n\tcurrent := atomic.LoadInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds())\r\n\tnewAvg := time.Duration((int64(current) + int64(latency.Nanoseconds())) / 2)\r\n\tatomic.StoreInt64(\u0026dss.stats.AvgWriteLatency.Nanoseconds(), int64(newAvg))\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "sync",
            "sync/atomic",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\store.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"context\"\r\n     6 | \t\"encoding/json\"\r\n     7 | \t\"time\"\r\n     8 | \r\n     9 | \t\"github.com/dgraph-io/badger/v4\"\r\nâ†’   10 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n    11 | \t\"go.uber.org/zap\"\r\n    12 | )\r\n    13 | \r\n    14 | // Store provides persistent state storage using BadgerDB\r\n    15 | type Store struct {\r\n",
          "full_function": "\t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n\t\"go.uber.org/zap\"\r\n)\r\n\r\n// Store provides persistent state storage using BadgerDB\r\ntype Store struct {\r\n\tdb *badger.DB\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "time",
            "github.com/dgraph-io/badger/v4",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\state\\store.go",
          "line_number": 11,
          "code_snippet": "     6 | \t\"encoding/json\"\r\n     7 | \t\"time\"\r\n     8 | \r\n     9 | \t\"github.com/dgraph-io/badger/v4\"\r\n    10 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\nâ†’   11 | \t\"go.uber.org/zap\"\r\n    12 | )\r\n    13 | \r\n    14 | // Store provides persistent state storage using BadgerDB\r\n    15 | type Store struct {\r\n    16 | \tdb *badger.DB\r\n",
          "full_function": "\t\"go.uber.org/zap\"\r\n)\r\n\r\n// Store provides persistent state storage using BadgerDB\r\ntype Store struct {\r\n\tdb *badger.DB\r\n}\r",
          "symbol_name": "",
          "package_name": "state",
          "dependencies": [
            "context",
            "encoding/json",
            "time",
            "github.com/dgraph-io/badger/v4",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\feedforward.go",
          "line_number": 194,
          "code_snippet": "   189 | }\r\n   190 | \r\n   191 | // forwardMoE performs mixture of experts computation\r\n   192 | func (ffn *FeedForwardNetwork) forwardMoE(ctx context.Context, input *Tensor) (*Tensor, error) {\r\n   193 | \t// Router determines which experts to use\r\nâ†’  194 | \trouter, err := ffn.router.Forward(input)\r\n   195 | \tif err != nil {\r\n   196 | \t\treturn nil, fmt.Errorf(\"routing error: %w\", err)\r\n   197 | \t}\r\n   198 | \r\n   199 | \t// Select top-k experts\r\n",
          "full_function": "func (ffn *FeedForwardNetwork) forwardMoE(ctx context.Context, input *Tensor) (*Tensor, error) {\r\n\t// Router determines which experts to use\r\n\trouter, err := ffn.router.Forward(input)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"routing error: %w\", err)\r\n\t}\r\n\r\n\t// Select top-k experts\r\n\tselectedExperts := ffn.selectTopKExperts(router)\r\n\r\n\t// Combine expert outputs\r\n\toutput := ffn.combineExperts(input, selectedExperts)\r\n\r\n\treturn output, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "math",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 152,
          "code_snippet": "   147 | \t\treturn nil, ctx.Err()\n   148 | \tdefault:\n   149 | \t}\n   150 | \n   151 | \t// Embedding layer\nâ†’  152 | \thidden, err := t.embeddings.Forward(input)\n   153 | \tif err != nil {\n   154 | \t\treturn nil, fmt.Errorf(\"embedding error: %w\", err)\n   155 | \t}\n   156 | \n   157 | \t// Add positional encoding\n",
          "full_function": "func (t *GLMTransformer) Forward(ctx context.Context, input *Tensor, attentionMask *Tensor) (*Tensor, error) {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\t// Embedding layer\n\thidden, err := t.embeddings.Forward(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"embedding error: %w\", err)\n\t}\n\n\t// Add positional encoding\n\tif t.posEncoding != nil {\n\t\tposEncoded, err := t.posEncoding.Forward(ctx, hidden, 0)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"positional encoding error: %w\", err)\n\t\t}\n\t\thidden = posEncoded\n\t}\n\n\t// Pass through transformer layers\n\tfor i, layer := range t.layers {\n\t\tselect {\n\t\tcase \u003c-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tlayerOutput, err := layer.Forward(ctx, hidden, attentionMask)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"layer %d error: %w\", i, err)\n\t\t}\n\t\thidden = layerOutput\n\n\t\tlogger.Debug(\"Transformer layer processed\",\n\t\t\tzap.Int(\"layer\", i),\n\t\t\tzap.Float64(\"mean_activation\", t.meanActivation(hidden)),\n\t\t)\n\t}\n\n\t// Final layer norm\n\toutput, err := t.layernorm.Forward(hidden)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"final layer norm error: %w\", err)\n\t}\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 209,
          "code_snippet": "   204 | \tnormInput, err := l.layernorm1.Forward(input)\n   205 | \tif err != nil {\n   206 | \t\treturn nil, fmt.Errorf(\"pre-norm error: %w\", err)\n   207 | \t}\n   208 | \nâ†’  209 | \tattnOutput, err := l.attention.Forward(ctx, normInput, normInput, normInput, attentionMask)\n   210 | \tif err != nil {\n   211 | \t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n   212 | \t}\n   213 | \n   214 | \t// Residual connection\n",
          "full_function": "func (l *TransformerLayer) Forward(ctx context.Context, input *Tensor, attentionMask *Tensor) (*Tensor, error) {\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\t// Pre-norm + attention\n\tnormInput, err := l.layernorm1.Forward(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"pre-norm error: %w\", err)\n\t}\n\n\tattnOutput, err := l.attention.Forward(ctx, normInput, normInput, normInput, attentionMask)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n\t}\n\n\t// Residual connection\n\tresidual1 := t.add(input, attnOutput)\n\n\t// Pre-norm + feed-forward\n\tnormResidual, err := l.layernorm2.Forward(residual1)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"post-norm error: %w\", err)\n\t}\n\n\tffOutput, err := l.feedForward.Forward(ctx, normResidual)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"feed-forward error: %w\", err)\n\t}\n\n\t// Residual connection\n\toutput := t.add(residual1, ffOutput)\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 215,
          "code_snippet": "   210 | \tif err != nil {\n   211 | \t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n   212 | \t}\n   213 | \n   214 | \t// Residual connection\nâ†’  215 | \tresidual1 := t.add(input, attnOutput)\n   216 | \n   217 | \t// Pre-norm + feed-forward\n   218 | \tnormResidual, err := l.layernorm2.Forward(residual1)\n   219 | \tif err != nil {\n   220 | \t\treturn nil, fmt.Errorf(\"post-norm error: %w\", err)\n",
          "full_function": "func (l *TransformerLayer) Forward(ctx context.Context, input *Tensor, attentionMask *Tensor) (*Tensor, error) {\n\tselect {\n\tcase \u003c-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tdefault:\n\t}\n\n\t// Pre-norm + attention\n\tnormInput, err := l.layernorm1.Forward(input)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"pre-norm error: %w\", err)\n\t}\n\n\tattnOutput, err := l.attention.Forward(ctx, normInput, normInput, normInput, attentionMask)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"attention error: %w\", err)\n\t}\n\n\t// Residual connection\n\tresidual1 := t.add(input, attnOutput)\n\n\t// Pre-norm + feed-forward\n\tnormResidual, err := l.layernorm2.Forward(residual1)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"post-norm error: %w\", err)\n\t}\n\n\tffOutput, err := l.feedForward.Forward(ctx, normResidual)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"feed-forward error: %w\", err)\n\t}\n\n\t// Residual connection\n\toutput := t.add(residual1, ffOutput)\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\transformer.go",
          "line_number": 249,
          "code_snippet": "   244 | // Forward performs layer normalization\n   245 | func (ln *LayerNorm) Forward(input *Tensor) (*Tensor, error) {\n   246 | \t// Simplified layer norm implementation\n   247 | \tmean := t.mean(input, -1, true)\n   248 | \tvariance := t.variance(input, -1, true)\nâ†’  249 | \tnormalized := t.div(t.sub(input, mean), t.sqrt(t.add(variance, ln.eps)))\n   250 | \n   251 | \t// Scale and shift\n   252 | \toutput := t.mul(normalized, ln.weight)\n   253 | \toutput = t.add(output, ln.bias)\n   254 | \n",
          "full_function": "func (ln *LayerNorm) Forward(input *Tensor) (*Tensor, error) {\n\t// Simplified layer norm implementation\n\tmean := t.mean(input, -1, true)\n\tvariance := t.variance(input, -1, true)\n\tnormalized := t.div(t.sub(input, mean), t.sqrt(t.add(variance, ln.eps)))\n\n\t// Scale and shift\n\toutput := t.mul(normalized, ln.weight)\n\toutput = t.add(output, ln.bias)\n\n\treturn output, nil\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\core\\transformer\\positional_encoding.go",
          "line_number": 6,
          "code_snippet": "     1 | // Package transformer implements positional encoding for GLM-4.6\n     2 | package transformer\n     3 | \n     4 | import (\n     5 | \t\"context\"\nâ†’    6 | \t\"fmt\"\n     7 | \t\"math\"\n     8 | \t\"sync\"\n     9 | \t\"time\"\n    10 | \n    11 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\n",
          "full_function": "\t\"fmt\"\n\t\"math\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\n\t\"go.uber.org/zap\"\n)\n\n// PositionalEncodingType represents different positional encoding approaches\ntype PositionalEncodingType string\n\nconst (\n\tPosEncodingTypeSinusoidal PositionalEncodingType = \"sinusoidal\"\n\tPosEncodingTypeLearned    PositionalEncodingType = \"learned\"\n\tPosEncodingTypeRelative   PositionalEncodingType = \"relative\"\n\tPosEncodingTypeRotary     PositionalEncodingType = \"rotary\"\n\tPosEncodingTypeALiBi      PositionalEncodingType = \"alibi\"\n\tPosEncodingTypeXPos       PositionalEncodingType = \"xpos\"\n)\n\n// PositionalEncodingConfig represents positional encoding configuration\ntype PositionalEncodingConfig struct {\n\tType        PositionalEncodingType `json:\"type\"`\n\tMaxSeqLen   int                    `json:\"max_seq_len\"`\n\tHiddenSize  int                    `json:\"hidden_size\"`\n\tHeadDim     int                    `json:\"head_dim,omitempty\"`\n\tBase        float64                `json:\"base\"`\n\tScale       bool                   `json:\"scale\"`\n\tNormalize   bool                   `json:\"normalize\"`\n\tConcatenate bool                   `json:\"concatenate\"`\n\tRotateHalf  bool                   `json:\"rotate_half\"`\n\tUseRoPE     bool                   `json:\"use_rope\"`\n\tUseXPos     bool                   `json:\"use_xpos\"`\n}",
          "symbol_name": "",
          "package_name": "transformer",
          "dependencies": [
            "context",
            "fmt",
            "math",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\compute\\serverless\\cloud_functions.go",
          "line_number": 14,
          "code_snippet": "     9 | type CloudFunctions interface {\r\n    10 | \t// Invoke invokes a cloud function\r\n    11 | \tInvoke(ctx context.Context, functionName string, payload []byte) ([]byte, error)\r\n    12 | \r\n    13 | \t// CreateFunction creates a cloud function\r\nâ†’   14 | \tCreateFunction(ctx context.Context, config *FunctionConfig) error\r\n    15 | \r\n    16 | \t// DeleteFunction deletes a cloud function\r\n    17 | \tDeleteFunction(ctx context.Context, functionName string) error\r\n    18 | }\r\n    19 | \n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "serverless",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\messaging\\pubsub\\pubsub_client.go",
          "line_number": 9,
          "code_snippet": "     4 | import (\r\n     5 | \t\"context\"\r\n     6 | )\r\n     7 | \r\n     8 | // PubSubClient provides generic pub/sub interface\r\nâ†’    9 | type PubSubClient interface {\r\n    10 | \t// Publish publishes a message to a topic\r\n    11 | \tPublish(ctx context.Context, topic string, message []byte) error\r\n    12 | \r\n    13 | \t// Subscribe subscribes to a topic\r\n    14 | \tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n",
          "full_function": "type PubSubClient interface {\r\n\t// Publish publishes a message to a topic\r\n\tPublish(ctx context.Context, topic string, message []byte) error\r\n\r\n\t// Subscribe subscribes to a topic\r\n\tSubscribe(ctx context.Context, topic string, handler func([]byte) error) error\r\n\r\n\t// Close closes the client connection\r\n\tClose() error\r\n}\r",
          "symbol_name": "",
          "package_name": "pubsub",
          "dependencies": [
            "context"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\infrastructure\\messaging\\pubsub\\nats_pubsub.go",
          "line_number": 9,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\messaging\\streaming\\nats_jetstream.go",
          "line_number": 178,
          "code_snippet": "   173 | \t\tRetention: config.Retention,\r\n   174 | \t}\r\n   175 | \r\n   176 | \t_, err := c.js.AddStream(streamConfig)\r\n   177 | \tif err != nil {\r\nâ†’  178 | \t\tif err == nats.ErrStreamNameExist {\r\n   179 | \t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", config.Name))\r\n   180 | \t\t\treturn nil\r\n   181 | \t\t}\r\n   182 | \t\treturn fmt.Errorf(\"failed to create stream %s: %w\", config.Name, err)\r\n   183 | \t}\r\n",
          "full_function": "func (c *natsJetStreamClient) CreateStream(ctx context.Context, config *StreamConfig) error {\r\n\tstreamConfig := \u0026nats.StreamConfig{\r\n\t\tName:      config.Name,\r\n\t\tSubjects:  config.Subjects,\r\n\t\tReplicas:  config.Replicas,\r\n\t\tMaxAge:    config.MaxAge,\r\n\t\tMaxBytes:  config.MaxBytes,\r\n\t\tMaxMsgs:   config.MaxMsgs,\r\n\t\tRetention: config.Retention,\r\n\t}\r\n\r\n\t_, err := c.js.AddStream(streamConfig)\r\n\tif err != nil {\r\n\t\tif err == nats.ErrStreamNameExist {\r\n\t\t\tlogger.Debug(\"Stream already exists\", zap.String(\"stream\", config.Name))\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\treturn fmt.Errorf(\"failed to create stream %s: %w\", config.Name, err)\r\n\t}\r\n\r\n\tlogger.Info(\"Created stream\",\r\n\t\tzap.String(\"stream\", config.Name),\r\n\t\tzap.Strings(\"subjects\", config.Subjects),\r\n\t)\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "streaming",
          "dependencies": [
            "context",
            "encoding/json",
            "fmt",
            "time",
            "github.com/nats-io/nats.go",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go",
          "line_number": 87,
          "code_snippet": "    82 | \t\tSELECT id, name, description, documents, embeddings, version, created_at, updated_at\r\n    83 | \t\tFROM knowledge\r\n    84 | \t\tWHERE id = $1\r\n    85 | \t`\r\n    86 | \r\nâ†’   87 | \tvar knowledge entities.Knowledge\r\n    88 | \tvar documentsJSON, embeddingsJSON []byte\r\n    89 | \tvar name, description string\r\n    90 | \tvar version int\r\n    91 | \tvar createdAt, updatedAt time.Time\r\n    92 | \r\n",
          "full_function": "\tvar knowledge entities.Knowledge\r\n\tvar documentsJSON, embeddingsJSON []byte\r\n\tvar name, description string\r\n\tvar version int\r\n\tvar createdAt, updatedAt time.Time\r\n\r\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(\r\n\t\t\u0026id,\r\n\t\t\u0026name,\r\n\t\t\u0026description,\r\n\t\t\u0026documentsJSON,\r\n\t\t\u0026embeddingsJSON,\r\n\t\t\u0026version,\r\n\t\t\u0026createdAt,\r\n\t\t\u0026updatedAt,\r\n\t)\r\n\r\n\tif err == sql.ErrNoRows {\r\n\t\treturn nil, fmt.Errorf(\"Knowledge not found: %s\", id)\r\n\t}\r",
          "symbol_name": "",
          "package_name": "relational",
          "dependencies": [
            "context",
            "database/sql",
            "encoding/json",
            "fmt",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/entities",
            "github.com/vertikon/mcp-core-inventory/internal/domain/repositories",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\infrastructure\\persistence\\relational\\postgres_knowledge_repository.go",
          "line_number": 204,
          "code_snippet": "   199 | \tknowledge, err := entities.NewKnowledge(name, description)\r\n   200 | \tif err != nil {\r\n   201 | \t\treturn nil, fmt.Errorf(\"failed to create Knowledge entity: %w\", err)\r\n   202 | \t}\r\n   203 | \r\nâ†’  204 | \treturn \u0026knowledge, nil\r\n   205 | }\r\n   206 | \r\n   207 | // List lists all Knowledge entities with optional filters\r\n   208 | func (r *PostgresKnowledgeRepository) List(ctx context.Context, filters *repositories.KnowledgeFilters) ([]*entities.Knowledge, error) {\r\n   209 | \tquery := \"SELECT id, name, description, documents, embeddings, version, created_at, updated_at FROM knowledge WHERE 1=1\"\r\n",
          "full_function": "\treturn \u0026knowledge, nil\r\n}\r\n\r\n// List lists all Knowledge entities with optional filters\r\nfunc (r *PostgresKnowledgeRepository) List(ctx context.Context, filters *repositories.KnowledgeFilters) ([]*entities.Knowledge, error) {\r\n\tquery := \"SELECT id, name, description, documents, embeddings, version, created_at, updated_at FROM knowledge WHERE 1=1\"\r\n\targs := []interface{}{}\r",
          "symbol_name": "",
          "package_name": "relational",
          "dependencies": [
            "context",
            "database/sql",
            "encoding/json",
            "fmt",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/domain/entities",
            "github.com/vertikon/mcp-core-inventory/internal/domain/repositories",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\root.go",
          "line_number": 42,
          "code_snippet": "    37 | func init() {\r\n    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n    40 | \t\r\n    41 | \t// Add subcommand groups\r\nâ†’   42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n    43 | \trootCmd.AddCommand(ci.CICmd)\r\n    44 | }\r\n    45 | \r\n    46 | // GetRootCmd returns the root command (for testing)\r\n    47 | func GetRootCmd() *cobra.Command {\r\n",
          "full_function": "func init() {\r\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n\t\r\n\t// Add subcommand groups\r\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n\trootCmd.AddCommand(ci.CICmd)\r\n}\r",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\interfaces\\cli\\root.go",
          "line_number": 43,
          "code_snippet": "    38 | \trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n    39 | \trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n    40 | \t\r\n    41 | \t// Add subcommand groups\r\n    42 | \trootCmd.AddCommand(analytics.AnalyticsCmd)\r\nâ†’   43 | \trootCmd.AddCommand(ci.CICmd)\r\n    44 | }\r\n    45 | \r\n    46 | // GetRootCmd returns the root command (for testing)\r\n    47 | func GetRootCmd() *cobra.Command {\r\n    48 | \treturn rootCmd\r\n",
          "full_function": "func init() {\r\n\trootCmd.PersistentFlags().BoolP(\"verbose\", \"v\", false, \"verbose output\")\r\n\trootCmd.PersistentFlags().String(\"config\", \"\", \"config file (default is $HOME/.hulk/config.yaml)\")\r\n\t\r\n\t// Add subcommand groups\r\n\trootCmd.AddCommand(analytics.AnalyticsCmd)\r\n\trootCmd.AddCommand(ci.CICmd)\r\n}\r",
          "symbol_name": "",
          "package_name": "cli",
          "dependencies": [
            "fmt",
            "os",
            "github.com/spf13/cobra",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\tools\\deployers\\hybrid_deployer.go",
          "line_number": 10,
          "code_snippet": "     5 | \t\"fmt\"\r\n     6 | \t\"os\"\r\n     7 | \t\"path/filepath\"\r\n     8 | \t\"time\"\r\n     9 | \r\nâ†’   10 | \t\"github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes\"\r\n    11 | \t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n    12 | \t\"go.uber.org/zap\"\r\n    13 | )\r\n    14 | \r\n    15 | // HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\r\n",
          "full_function": "\t\"github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes\"\r\n\t\"github.com/vertikon/mcp-core-inventory/pkg/logger\"\r\n\t\"go.uber.org/zap\"\r\n)\r\n\r\n// HybridDeployer handles hybrid deployment combining K8s + Serverless + Docker\r\n// This deployer intelligently selects the best deployment strategy based on workload characteristics\r\ntype HybridDeployer struct {\r\n\tdockerDeployer     *DockerDeployer\r\n\tkubernetesDeployer *KubernetesDeployer\r\n\tserverlessDeployer *ServerlessDeployer\r\n\tlogger             *zap.Logger\r\n}\r",
          "symbol_name": "",
          "package_name": "deployers",
          "dependencies": [
            "context",
            "fmt",
            "os",
            "path/filepath",
            "time",
            "github.com/vertikon/mcp-core-inventory/internal/infrastructure/cloud/kubernetes",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 56,
          "code_snippet": "    51 | \t// Verify verifies a signature using RSA\r\n    52 | \tVerify(data, signature []byte, publicKey *rsa.PublicKey) bool\r\n    53 | }\r\n    54 | \r\n    55 | // Manager implements EncryptionManager\r\nâ†’   56 | type Manager struct {\r\n    57 | \tkeyManager KeyManager\r\n    58 | \tlogger     *zap.Logger\r\n    59 | }\r\n    60 | \r\n    61 | // NewEncryptionManager creates a new EncryptionManager\r\n",
          "full_function": "type Manager struct {\r\n\tkeyManager KeyManager\r\n\tlogger     *zap.Logger\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\security\\encryption\\certificate_manager.go",
          "line_number": 42,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 64,
          "code_snippet": "    59 | }\r\n    60 | \r\n    61 | // NewEncryptionManager creates a new EncryptionManager\r\n    62 | func NewEncryptionManager(keyManager KeyManager) EncryptionManager {\r\n    63 | \treturn \u0026Manager{\r\nâ†’   64 | \t\tkeyManager: keyManager,\r\n    65 | \t\tlogger:     logger.WithContext(nil),\r\n    66 | \t}\r\n    67 | }\r\n    68 | \r\n    69 | // Encrypt encrypts data using AES-256-GCM with default key\r\n",
          "full_function": "func NewEncryptionManager(keyManager KeyManager) EncryptionManager {\r\n\treturn \u0026Manager{\r\n\t\tkeyManager: keyManager,\r\n\t\tlogger:     logger.WithContext(nil),\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 71,
          "code_snippet": "    66 | \t}\r\n    67 | }\r\n    68 | \r\n    69 | // Encrypt encrypts data using AES-256-GCM with default key\r\n    70 | func (m *Manager) Encrypt(plaintext []byte) ([]byte, error) {\r\nâ†’   71 | \tkey, err := m.keyManager.GetEncryptionKey()\r\n    72 | \tif err != nil {\r\n    73 | \t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n    74 | \t\treturn nil, err\r\n    75 | \t}\r\n    76 | \treturn m.EncryptWithKey(plaintext, key)\r\n",
          "full_function": "func (m *Manager) Encrypt(plaintext []byte) ([]byte, error) {\r\n\tkey, err := m.keyManager.GetEncryptionKey()\r\n\tif err != nil {\r\n\t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n\t\treturn nil, err\r\n\t}\r\n\treturn m.EncryptWithKey(plaintext, key)\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\encryption_manager.go",
          "line_number": 81,
          "code_snippet": "    76 | \treturn m.EncryptWithKey(plaintext, key)\r\n    77 | }\r\n    78 | \r\n    79 | // Decrypt decrypts data using AES-256-GCM with default key\r\n    80 | func (m *Manager) Decrypt(ciphertext []byte) ([]byte, error) {\r\nâ†’   81 | \tkey, err := m.keyManager.GetEncryptionKey()\r\n    82 | \tif err != nil {\r\n    83 | \t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n    84 | \t\treturn nil, err\r\n    85 | \t}\r\n    86 | \treturn m.DecryptWithKey(ciphertext, key)\r\n",
          "full_function": "func (m *Manager) Decrypt(ciphertext []byte) ([]byte, error) {\r\n\tkey, err := m.keyManager.GetEncryptionKey()\r\n\tif err != nil {\r\n\t\tm.logger.Error(\"Failed to get encryption key\", zap.Error(err))\r\n\t\treturn nil, err\r\n\t}\r\n\treturn m.DecryptWithKey(ciphertext, key)\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto",
            "crypto/aes",
            "crypto/cipher",
            "crypto/rand",
            "crypto/rsa",
            "crypto/sha256",
            "errors",
            "io",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap",
            "golang.org/x/crypto/argon2",
            "golang.org/x/crypto/bcrypt"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 52,
          "code_snippet": "    47 | \t// LoadKeyFromFile loads key from file\r\n    48 | \tLoadKeyFromFile(filePath string) error\r\n    49 | }\r\n    50 | \r\n    51 | // Manager implements KeyManager\r\nâ†’   52 | type Manager struct {\r\n    53 | \tencryptionKey []byte\r\n    54 | \tkeyVersion    string\r\n    55 | \trsaPrivateKey *rsa.PrivateKey\r\n    56 | \trsaPublicKey  *rsa.PublicKey\r\n    57 | \trotationTTL  time.Duration\r\n",
          "full_function": "type Manager struct {\r\n\tencryptionKey []byte\r\n\tkeyVersion    string\r\n\trsaPrivateKey *rsa.PrivateKey\r\n\trsaPublicKey  *rsa.PublicKey\r\n\trotationTTL  time.Duration\r\n\tlastRotation  time.Time\r\n\tmu            sync.RWMutex\r\n\tlogger        *zap.Logger\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\security\\encryption\\certificate_manager.go",
          "line_number": 42,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 72,
          "code_snippet": "    67 | }\r\n    68 | \r\n    69 | // NewKeyManager creates a new KeyManager\r\n    70 | func NewKeyManager(config KeyManagerConfig) KeyManager {\r\n    71 | \tkm := \u0026Manager{\r\nâ†’   72 | \t\tkeyVersion:   \"v1\",\r\n    73 | \t\trotationTTL: config.RotationTTL,\r\n    74 | \t\tlogger:       logger.WithContext(nil),\r\n    75 | \t}\r\n    76 | \r\n    77 | \t// Generate initial encryption key\r\n",
          "full_function": "func NewKeyManager(config KeyManagerConfig) KeyManager {\r\n\tkm := \u0026Manager{\r\n\t\tkeyVersion:   \"v1\",\r\n\t\trotationTTL: config.RotationTTL,\r\n\t\tlogger:       logger.WithContext(nil),\r\n\t}\r\n\r\n\t// Generate initial encryption key\r\n\tkey := make([]byte, 32) // AES-256\r\n\tif _, err := rand.Read(key); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate encryption key\", zap.Error(err))\r\n\t} else {\r\n\t\tkm.encryptionKey = key\r\n\t}\r\n\r\n\t// Generate RSA key pair\r\n\tif err := km.generateRSAKeys(config.KeySize); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate RSA keys\", zap.Error(err))\r\n\t}\r\n\r\n\tkm.lastRotation = time.Now()\r\n\treturn km\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 82,
          "code_snippet": "    77 | \t// Generate initial encryption key\r\n    78 | \tkey := make([]byte, 32) // AES-256\r\n    79 | \tif _, err := rand.Read(key); err != nil {\r\n    80 | \t\tkm.logger.Error(\"Failed to generate encryption key\", zap.Error(err))\r\n    81 | \t} else {\r\nâ†’   82 | \t\tkm.encryptionKey = key\r\n    83 | \t}\r\n    84 | \r\n    85 | \t// Generate RSA key pair\r\n    86 | \tif err := km.generateRSAKeys(config.KeySize); err != nil {\r\n    87 | \t\tkm.logger.Error(\"Failed to generate RSA keys\", zap.Error(err))\r\n",
          "full_function": "func NewKeyManager(config KeyManagerConfig) KeyManager {\r\n\tkm := \u0026Manager{\r\n\t\tkeyVersion:   \"v1\",\r\n\t\trotationTTL: config.RotationTTL,\r\n\t\tlogger:       logger.WithContext(nil),\r\n\t}\r\n\r\n\t// Generate initial encryption key\r\n\tkey := make([]byte, 32) // AES-256\r\n\tif _, err := rand.Read(key); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate encryption key\", zap.Error(err))\r\n\t} else {\r\n\t\tkm.encryptionKey = key\r\n\t}\r\n\r\n\t// Generate RSA key pair\r\n\tif err := km.generateRSAKeys(config.KeySize); err != nil {\r\n\t\tkm.logger.Error(\"Failed to generate RSA keys\", zap.Error(err))\r\n\t}\r\n\r\n\tkm.lastRotation = time.Now()\r\n\treturn km\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 96,
          "code_snippet": "    91 | \treturn km\r\n    92 | }\r\n    93 | \r\n    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\nâ†’   96 | \tm.mu.RLock()\r\n    97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\n    99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 97,
          "code_snippet": "    92 | }\r\n    93 | \r\n    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n    96 | \tm.mu.RLock()\r\nâ†’   97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\n    99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n   102 | \r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 99,
          "code_snippet": "    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n    96 | \tm.mu.RLock()\r\n    97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\nâ†’   99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n   102 | \r\n   103 | \t// Check if rotation is needed\r\n   104 | \tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\security\\encryption\\key_manager.go",
          "line_number": 99,
          "code_snippet": "    94 | // GetEncryptionKey returns the current encryption key\r\n    95 | func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n    96 | \tm.mu.RLock()\r\n    97 | \tdefer m.mu.RUnlock()\r\n    98 | \r\nâ†’   99 | \tif m.encryptionKey == nil {\r\n   100 | \t\treturn nil, ErrKeyNotFound\r\n   101 | \t}\r\n   102 | \r\n   103 | \t// Check if rotation is needed\r\n   104 | \tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n",
          "full_function": "func (m *Manager) GetEncryptionKey() ([]byte, error) {\r\n\tm.mu.RLock()\r\n\tdefer m.mu.RUnlock()\r\n\r\n\tif m.encryptionKey == nil {\r\n\t\treturn nil, ErrKeyNotFound\r\n\t}\r\n\r\n\t// Check if rotation is needed\r\n\tif time.Since(m.lastRotation) \u003e m.rotationTTL {\r\n\t\tgo m.RotateKey()\r\n\t}\r\n\r\n\t// Return a copy to prevent external modification\r\n\tkey := make([]byte, len(m.encryptionKey))\r\n\tcopy(key, m.encryptionKey)\r\n\treturn key, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "encryption",
          "dependencies": [
            "crypto/rand",
            "crypto/rsa",
            "crypto/x509",
            "encoding/base64",
            "encoding/hex",
            "encoding/pem",
            "errors",
            "fmt",
            "os",
            "path/filepath",
            "strings",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 162,
          "code_snippet": "   157 | \tcm.stats.TotalInvalidations++\r\n   158 | \tcm.stats.InvalidationsByReason[reason]++\r\n   159 | \tcm.mu.Unlock()\r\n   160 | \r\n   161 | \t// Delete from cache\r\nâ†’  162 | \tcm.cache.Delete(key)\r\n   163 | \r\n   164 | \t// Create invalidation event\r\n   165 | \tevent := \u0026InvalidationEvent{\r\n   166 | \t\tKey:       key,\r\n   167 | \t\tReason:    reason,\r\n",
          "full_function": "func (cm *CoherencyManagerImpl) Invalidate(ctx context.Context, key string, reason string) error {\r\n\tstart := time.Now()\r\n\r\n\tcm.mu.Lock()\r\n\tcm.stats.TotalInvalidations++\r\n\tcm.stats.InvalidationsByReason[reason]++\r\n\tcm.mu.Unlock()\r\n\r\n\t// Delete from cache\r\n\tcm.cache.Delete(key)\r\n\r\n\t// Create invalidation event\r\n\tevent := \u0026InvalidationEvent{\r\n\t\tKey:       key,\r\n\t\tReason:    reason,\r\n\t\tTimestamp: time.Now(),\r\n\t\tSource:    \"coherency_manager\",\r\n\t}\r\n\r\n\t// Send to invalidation channel\r\n\tselect {\r\n\tcase cm.invalidationCh \u003c- event:\r\n\tdefault:\r\n\t\tcm.logger.Warn(\"Invalidation channel full, dropping event\",\r\n\t\t\tzap.String(\"key\", key))\r\n\t}\r\n\r\n\tcm.mu.Lock()\r\n\tcm.stats.AverageInvalidationTime = time.Since(start)\r\n\tlastTime := time.Now()\r\n\tcm.stats.LastInvalidation = \u0026lastTime\r\n\tcm.mu.Unlock()\r\n\r\n\tcm.logger.Debug(\"Cache key invalidated\",\r\n\t\tzap.String(\"key\", key),\r\n\t\tzap.String(\"reason\", reason))\r\n\r\n\treturn nil\r\n}\r",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 217,
          "code_snippet": "   212 | }\r\n   213 | \r\n   214 | // Update updates a cache entry\r\n   215 | func (cm *CoherencyManagerImpl) Update(ctx context.Context, key string, value interface{}) error {\r\n   216 | \tcm.mu.Lock()\r\nâ†’  217 | \tcm.stats.TotalUpdates++\r\n   218 | \tcm.mu.Unlock()\r\n   219 | \r\n   220 | \t// Update cache based on strategy\r\n   221 | \tswitch cm.config.Strategy {\r\n   222 | \tcase CoherencyStrategyWriteThrough:\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 253,
          "code_snippet": "   248 | \t\tStrategy:             cm.config.Strategy,\r\n   249 | \t\tLevel:                cm.config.Level,\r\n   250 | \t\tIsCoherent:           true, // Simplified\r\n   251 | \t\tPendingInvalidations: len(cm.pendingInvalidations),\r\n   252 | \t\tTotalInvalidations:   cm.stats.TotalInvalidations,\r\nâ†’  253 | \t\tTotalUpdates:         cm.stats.TotalUpdates,\r\n   254 | \t}, nil\r\n   255 | }\r\n   256 | \r\n   257 | // GetInvalidationStats returns invalidation statistics\r\n   258 | func (cm *CoherencyManagerImpl) GetInvalidationStats(ctx context.Context) (*InvalidationStats, error) {\r\n",
          "full_function": "func (cm *CoherencyManagerImpl) GetCoherencyStatus(ctx context.Context) (*CoherencyStatus, error) {\r\n\tcm.mu.RLock()\r\n\tdefer cm.mu.RUnlock()\r\n\r\n\treturn \u0026CoherencyStatus{\r\n\t\tStrategy:             cm.config.Strategy,\r\n\t\tLevel:                cm.config.Level,\r\n\t\tIsCoherent:           true, // Simplified\r\n\t\tPendingInvalidations: len(cm.pendingInvalidations),\r\n\t\tTotalInvalidations:   cm.stats.TotalInvalidations,\r\n\t\tTotalUpdates:         cm.stats.TotalUpdates,\r\n\t}, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\cache\\cache_coherency.go",
          "line_number": 342,
          "code_snippet": "   337 | \tcm.mu.Lock()\r\n   338 | \tcm.pendingInvalidations[event.Key] = event\r\n   339 | \tcm.mu.Unlock()\r\n   340 | \r\n   341 | \t// Process invalidation\r\nâ†’  342 | \tcm.cache.Delete(event.Key)\r\n   343 | \r\n   344 | \tcm.mu.Lock()\r\n   345 | \tdelete(cm.pendingInvalidations, event.Key)\r\n   346 | \tcm.mu.Unlock()\r\n   347 | \r\n",
          "full_function": "func (cm *CoherencyManagerImpl) processInvalidation(event *InvalidationEvent) {\r\n\tcm.mu.Lock()\r\n\tcm.pendingInvalidations[event.Key] = event\r\n\tcm.mu.Unlock()\r\n\r\n\t// Process invalidation\r\n\tcm.cache.Delete(event.Key)\r\n\r\n\tcm.mu.Lock()\r\n\tdelete(cm.pendingInvalidations, event.Key)\r\n\tcm.mu.Unlock()\r\n\r\n\tcm.logger.Debug(\"Invalidation processed\",\r\n\t\tzap.String(\"key\", event.Key),\r\n\t\tzap.String(\"reason\", event.Reason))\r\n}\r",
          "symbol_name": "",
          "package_name": "cache",
          "dependencies": [
            "context",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 236,
          "code_snippet": "   231 | \t// Compare vector clocks\r\n   232 | \tcomparison := r.compareVectorClocks(localVC, remoteVC)\r\n   233 | \t\r\n   234 | \tswitch comparison {\r\n   235 | \tcase \"local_greater\":\r\nâ†’  236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n   237 | \tcase \"remote_greater\":\r\n   238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n   239 | \tcase \"concurrent\":\r\n   240 | \t\t// Conflict detected, need merge\r\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\r\n\t// Extract vector clocks from metadata\r\n\tlocalVC := r.getVectorClock(conflict.LocalState)\r\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\r\n\t\r\n\t// Compare vector clocks\r\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\r\n\t\r\n\tswitch comparison {\r\n\tcase \"local_greater\":\r\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n\tcase \"remote_greater\":\r\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n\tcase \"concurrent\":\r\n\t\t// Conflict detected, need merge\r\n\t\treturn r.resolveCRDTMerge(conflict)\r\n\tdefault:\r\n\t\t// Same vector clock, use timestamp as tie-breaker\r\n\t\treturn r.resolveLastWriteWins(conflict)\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 238,
          "code_snippet": "   233 | \t\r\n   234 | \tswitch comparison {\r\n   235 | \tcase \"local_greater\":\r\n   236 | \t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n   237 | \tcase \"remote_greater\":\r\nâ†’  238 | \t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n   239 | \tcase \"concurrent\":\r\n   240 | \t\t// Conflict detected, need merge\r\n   241 | \t\treturn r.resolveCRDTMerge(conflict)\r\n   242 | \tdefault:\r\n   243 | \t\t// Same vector clock, use timestamp as tie-breaker\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveVectorClock(conflict *Conflict) (*VersionedState, error) {\r\n\t// Extract vector clocks from metadata\r\n\tlocalVC := r.getVectorClock(conflict.LocalState)\r\n\tremoteVC := r.getVectorClock(conflict.RemoteState)\r\n\t\r\n\t// Compare vector clocks\r\n\tcomparison := r.compareVectorClocks(localVC, remoteVC)\r\n\t\r\n\tswitch comparison {\r\n\tcase \"local_greater\":\r\n\t\treturn r.createResolvedState(conflict.LocalState, conflict.RemoteState, \"vector-clock-local\")\r\n\tcase \"remote_greater\":\r\n\t\treturn r.createResolvedState(conflict.RemoteState, conflict.LocalState, \"vector-clock-remote\")\r\n\tcase \"concurrent\":\r\n\t\t// Conflict detected, need merge\r\n\t\treturn r.resolveCRDTMerge(conflict)\r\n\tdefault:\r\n\t\t// Same vector clock, use timestamp as tie-breaker\r\n\t\treturn r.resolveLastWriteWins(conflict)\r\n\t}\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 251,
          "code_snippet": "   246 | }\r\n   247 | \r\n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\r\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\r\nâ†’  251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\n   252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n   253 | \t\r\n   254 | \t// Ensure both states have timestamps\r\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n\t// CRDT LWW uses timestamps for conflict resolution\r\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n\t\r\n\t// Ensure both states have timestamps\r\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n\t\r\n\tif localTS.After(remoteTS) {\r\n\t\treturn \u0026VersionedState{\r\n\t\t\tKey:     conflict.Key,\r\n\t\t\tValue:   conflict.LocalState.Value,\r\n\t\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\t\tTTL:     conflict.LocalState.TTL,\r\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t\t}, nil\r\n\t}\r\n\t\r\n\treturn \u0026VersionedState{\r\n\t\tKey:     conflict.Key,\r\n\t\tValue:   conflict.RemoteState.Value,\r\n\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\tTTL:     conflict.RemoteState.TTL,\r\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t}, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 252,
          "code_snippet": "   247 | \r\n   248 | // resolveCRDTLastWriterWins resolves conflict using CRDT LWW strategy\r\n   249 | func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n   250 | \t// CRDT LWW uses timestamps for conflict resolution\r\n   251 | \tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\nâ†’  252 | \tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n   253 | \t\r\n   254 | \t// Ensure both states have timestamps\r\n   255 | \tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n   256 | \tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n   257 | \t\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTLastWriterWins(conflict *Conflict) (*VersionedState, error) {\r\n\t// CRDT LWW uses timestamps for conflict resolution\r\n\tlocalTime := r.getStateTimestamp(conflict.LocalState)\r\n\tremoteTime := r.getStateTimestamp(conflict.RemoteState)\r\n\t\r\n\t// Ensure both states have timestamps\r\n\tlocalTS := r.ensureTimestamp(conflict.LocalState)\r\n\tremoteTS := r.ensureTimestamp(conflict.RemoteState)\r\n\t\r\n\tif localTS.After(remoteTS) {\r\n\t\treturn \u0026VersionedState{\r\n\t\t\tKey:     conflict.Key,\r\n\t\t\tValue:   conflict.LocalState.Value,\r\n\t\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\t\tTTL:     conflict.LocalState.TTL,\r\n\t\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t\t}, nil\r\n\t}\r\n\t\r\n\treturn \u0026VersionedState{\r\n\t\tKey:     conflict.Key,\r\n\t\tValue:   conflict.RemoteState.Value,\r\n\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\tTTL:     conflict.RemoteState.TTL,\r\n\t\tMeta:    r.mergeCRDTMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta, localTS, remoteTS),\r\n\t}, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 283,
          "code_snippet": "   278 | func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\r\n   279 | \t// For simple values, use last-write-wins\r\n   280 | \t// For complex values (maps, sets, counters), perform actual CRDT merge\r\n   281 | \t\r\n   282 | \t// Check if values are mergeable\r\nâ†’  283 | \tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\r\n   284 | \t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\r\n   285 | \t\tif err != nil {\r\n   286 | \t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\r\n   287 | \t\t\t\tzap.String(\"key\", conflict.Key),\r\n   288 | \t\t\t\tzap.Error(err))\r\n",
          "full_function": "func (r *ConflictResolverImpl) resolveCRDTMerge(conflict *Conflict) (*VersionedState, error) {\r\n\t// For simple values, use last-write-wins\r\n\t// For complex values (maps, sets, counters), perform actual CRDT merge\r\n\t\r\n\t// Check if values are mergeable\r\n\tif r.isMergeableValue(conflict.LocalState.Value, conflict.RemoteState.Value) {\r\n\t\tmergedValue, err := r.mergeValues(conflict.LocalState.Value, conflict.RemoteState.Value)\r\n\t\tif err != nil {\r\n\t\t\tr.logger.Error(\"CRDT merge failed, falling back to LWW\",\r\n\t\t\t\tzap.String(\"key\", conflict.Key),\r\n\t\t\t\tzap.Error(err))\r\n\t\t\treturn r.resolveCRDTLastWriterWins(conflict)\r\n\t\t}\r\n\t\t\r\n\t\treturn \u0026VersionedState{\r\n\t\t\tKey:     conflict.Key,\r\n\t\t\tValue:   mergedValue,\r\n\t\t\tVersion:  max(conflict.LocalState.Version, conflict.RemoteState.Version) + 1,\r\n\t\t\tTTL:     r.mergeTTL(conflict.LocalState.TTL, conflict.RemoteState.TTL),\r\n\t\t\tMeta:    r.createCRDTMergeMeta(conflict.LocalState.Meta, conflict.RemoteState.Meta),\r\n\t\t}, nil\r\n\t}\r\n\t\r\n\t// Non-mergeable, fall back to LWW\r\n\treturn r.resolveCRDTLastWriterWins(conflict)\r\n}\r",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 396,
          "code_snippet": "   391 | \treturn ts\r\n   392 | }\r\n   393 | \r\n   394 | func (r *ConflictResolverImpl) isMergeableValue(value interface{}) bool {\r\n   395 | \t// Check if value is a type that can be merged\r\nâ†’  396 | \tswitch v := value.(type) {\r\n   397 | \tcase map[string]interface{}:\r\n   398 | \t\treturn true\r\n   399 | \tcase []interface{}:\r\n   400 | \t\treturn true\r\n   401 | \tcase map[string]string:\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 415,
          "code_snippet": "   410 | func (r *ConflictResolverImpl) mergeValues(local, remote interface{}) (interface{}, error) {\r\n   411 | \t// Implement actual CRDT merge logic based on value type\r\n   412 | \tswitch l := local.(type) {\r\n   413 | \tcase map[string]interface{}:\r\n   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\r\nâ†’  415 | \t\t\treturn r.mergeMaps(l, r), nil\r\n   416 | \t\t}\r\n   417 | \tcase []interface{}:\r\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\r\n   419 | \t\t\treturn r.mergeArrays(l, r), nil\r\n   420 | \t\t}\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 419,
          "code_snippet": "   414 | \t\tif r, ok := remote.(map[string]interface{}); ok {\r\n   415 | \t\t\treturn r.mergeMaps(l, r), nil\r\n   416 | \t\t}\r\n   417 | \tcase []interface{}:\r\n   418 | \t\tif r, ok := remote.([]interface{}); ok {\r\nâ†’  419 | \t\t\treturn r.mergeArrays(l, r), nil\r\n   420 | \t\t}\r\n   421 | \t}\r\n   422 | \t\r\n   423 | \t// Cannot merge, return error\r\n   424 | \treturn nil, fmt.Errorf(\"values are not mergeable\")\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 516,
          "code_snippet": "   511 | \t\r\n   512 | \t// Add CRDT-specific metadata\r\n   513 | \tmerged[\"crdt_strategy\"] = \"last-writer-wins\"\r\n   514 | \tmerged[\"local_timestamp\"] = localTS\r\n   515 | \tmerged[\"remote_timestamp\"] = remoteTS\r\nâ†’  516 | \tmerged[\"winner_timestamp\"] = max(localTS, remoteTS)\r\n   517 | \t\r\n   518 | \treturn merged\r\n   519 | }\r\n   520 | \r\n   521 | func (r *ConflictResolverImpl) createCRDTMergeMeta(local, remote map[string]interface{}) map[string]interface{} {\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 622,
          "code_snippet": "   617 | \t\treturn a\r\n   618 | \t}\r\n   619 | \treturn b\r\n   620 | }\r\n   621 | \r\nâ†’  622 | func max(a, b time.Time) time.Time {\r\n   623 | \tif a.After(b) {\r\n   624 | \t\treturn a\r\n   625 | \t}\r\n   626 | \treturn b\r\n   627 | }\n",
          "full_function": "func max(a, b time.Time) time.Time {\r\n\tif a.After(b) {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\\tinternal\\state\\store\\conflict_resolver.go",
          "line_number": 615,
          "code_snippet": "",
          "full_function": "",
          "symbol_name": "",
          "package_name": "",
          "dependencies": null,
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\store\\conflict_resolver.go",
          "line_number": 516,
          "code_snippet": "   511 | \t\r\n   512 | \t// Add CRDT-specific metadata\r\n   513 | \tmerged[\"crdt_strategy\"] = \"last-writer-wins\"\r\n   514 | \tmerged[\"local_timestamp\"] = localTS\r\n   515 | \tmerged[\"remote_timestamp\"] = remoteTS\r\nâ†’  516 | \tmerged[\"winner_timestamp\"] = max(localTS, remoteTS)\r\n   517 | \t\r\n   518 | \treturn merged\r\n   519 | }\r\n   520 | \r\n   521 | func (r *ConflictResolverImpl) createCRDTMergeMeta(local, remote map[string]interface{}) map[string]interface{} {\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "store",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_replay.go",
          "line_number": 249,
          "code_snippet": "   244 | }\r\n   245 | \r\n   246 | // ReplayFromSnapshot replays events from a snapshot version\r\n   247 | func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\r\n   248 | \t// Get snapshot\r\nâ†’  249 | \tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\r\n   250 | \tif err != nil {\r\n   251 | \t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\r\n   252 | \t}\r\n   253 | \r\n   254 | \t// Get events after snapshot version\r\n",
          "full_function": "func (er *EventReplayImpl) ReplayFromSnapshot(ctx context.Context, aggregateID string, snapshotVersion int64, handler ReplayHandler) (*ReplayProgress, error) {\r\n\t// Get snapshot\r\n\tsnapshot, err := er.store.GetSnapshot(ctx, aggregateID)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to get snapshot: %w\", err)\r\n\t}\r\n\r\n\t// Get events after snapshot version\r\n\tevents, err := er.store.GetEvents(ctx, aggregateID, snapshotVersion+1, 0)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to get events after snapshot: %w\", err)\r\n\t}\r\n\r\n\tif len(events) == 0 {\r\n\t\treturn \u0026ReplayProgress{\r\n\t\t\tTotalEvents:     0,\r\n\t\t\tProcessedEvents: 0,\r\n\t\t\tIsComplete:      true,\r\n\t\t}, nil\r\n\t}\r\n\r\n\tstartTime := time.Now()\r\n\tprogress := \u0026ReplayProgress{\r\n\t\tTotalEvents:    int64(len(events)),\r\n\t\tStartTime:      startTime,\r\n\t\tCurrentVersion: snapshotVersion + 1,\r\n\t}\r\n\r\n\terr = er.replaySequential(ctx, events, handler, progress)\r\n\tprogress.ElapsedTime = time.Since(startTime)\r\n\tprogress.IsComplete = true\r\n\r\n\tif err != nil {\r\n\t\tprogress.LastError = err.Error()\r\n\t\treturn progress, err\r\n\t}\r\n\r\n\treturn progress, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_replay.go",
          "line_number": 290,
          "code_snippet": "   285 | }\r\n   286 | \r\n   287 | // ReplayToState replays events to rebuild state at a specific version\r\n   288 | func (er *EventReplayImpl) ReplayToState(ctx context.Context, aggregateID string, targetVersion int64, handler ReplayHandler) (interface{}, error) {\r\n   289 | \t// Get all events up to target version\r\nâ†’  290 | \tevents, err := er.store.GetEvents(ctx, aggregateID, 1, targetVersion)\r\n   291 | \tif err != nil {\r\n   292 | \t\treturn nil, fmt.Errorf(\"failed to get events: %w\", err)\r\n   293 | \t}\r\n   294 | \r\n   295 | \t// Replay events\r\n",
          "full_function": "",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_versioning.go",
          "line_number": 140,
          "code_snippet": "   135 | \tif exists {\r\n   136 | \t\t// Return copy\r\n   137 | \t\tcopy := *versionInfo\r\n   138 | \t\tif versionInfo.VersionHistory != nil {\r\n   139 | \t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\r\nâ†’  140 | \t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\r\n   141 | \t\t}\r\n   142 | \t\treturn \u0026copy, nil\r\n   143 | \t}\r\n   144 | \t\r\n   145 | \t// Load from event store\r\n",
          "full_function": "func (ev *EventVersioningImpl) GetVersion(ctx context.Context, aggregateID string) (*VersionInfo, error) {\r\n\tev.mu.RLock()\r\n\tversionInfo, exists := ev.versions[aggregateID]\r\n\tev.mu.RUnlock()\r\n\t\r\n\tif exists {\r\n\t\t// Return copy\r\n\t\tcopy := *versionInfo\r\n\t\tif versionInfo.VersionHistory != nil {\r\n\t\t\tcopy.VersionHistory = make([]VersionHistoryEntry, len(versionInfo.VersionHistory))\r\n\t\t\tcopy(versionInfo.VersionHistory, copy.VersionHistory)\r\n\t\t}\r\n\t\treturn \u0026copy, nil\r\n\t}\r\n\t\r\n\t// Load from event store\r\n\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"failed to get aggregate info: %w\", err)\r\n\t}\r\n\t\r\n\tversionInfo = \u0026VersionInfo{\r\n\t\tAggregateID:    aggregateID,\r\n\t\tAggregateType:  aggregateInfo.AggregateType,\r\n\t\tCurrentVersion: aggregateInfo.Version,\r\n\t\tMetadata:       make(map[string]interface{}),\r\n\t}\r\n\t\r\n\tif ev.config.EnableHistory {\r\n\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\r\n\t}\r\n\t\r\n\tev.mu.Lock()\r\n\tev.versions[aggregateID] = versionInfo\r\n\tev.mu.Unlock()\r\n\t\r\n\treturn versionInfo, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        },
        {
          "file_path": "E:\\vertikon\\.endurance\\internal\\services\\bloco-1-core\\mcp-core-inventory\\internal\\state\\events\\event_versioning.go",
          "line_number": 216,
          "code_snippet": "   211 | \t\tif ev.config.ConflictResolution == \"reject\" {\r\n   212 | \t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\r\n   213 | \t\t}\r\n   214 | \t\t\r\n   215 | \t\t// Resolve conflict\r\nâ†’  216 | \t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\r\n   217 | \t\tif err != nil {\r\n   218 | \t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\r\n   219 | \t\t}\r\n   220 | \t\t\r\n   221 | \t\tnewVersion = resolvedVersion\r\n",
          "full_function": "func (ev *EventVersioningImpl) IncrementVersion(ctx context.Context, aggregateID string, event *Event) (int64, error) {\r\n\tev.mu.Lock()\r\n\tdefer ev.mu.Unlock()\r\n\t\r\n\tversionInfo, exists := ev.versions[aggregateID]\r\n\tif !exists {\r\n\t\t// Load from store\r\n\t\taggregateInfo, err := ev.store.GetAggregateInfo(ctx, aggregateID)\r\n\t\tif err != nil {\r\n\t\t\treturn 0, fmt.Errorf(\"failed to get aggregate info: %w\", err)\r\n\t\t}\r\n\t\t\r\n\t\tversionInfo = \u0026VersionInfo{\r\n\t\t\tAggregateID:    aggregateID,\r\n\t\t\tAggregateType:  aggregateInfo.AggregateType,\r\n\t\t\tCurrentVersion: aggregateInfo.Version,\r\n\t\t\tMetadata:       make(map[string]interface{}),\r\n\t\t}\r\n\t\t\r\n\t\tif ev.config.EnableHistory {\r\n\t\t\tversionInfo.VersionHistory = make([]VersionHistoryEntry, 0)\r\n\t\t}\r\n\t\t\r\n\t\tev.versions[aggregateID] = versionInfo\r\n\t}\r\n\t\r\n\t// Increment version\r\n\tnewVersion := versionInfo.CurrentVersion + 1\r\n\t\r\n\t// Validate version continuity\r\n\tif event.Version != 0 \u0026\u0026 event.Version != newVersion {\r\n\t\tconflict := \u0026VersionConflict{\r\n\t\t\tAggregateID:     aggregateID,\r\n\t\t\tExpectedVersion: newVersion,\r\n\t\t\tActualVersion:   event.Version,\r\n\t\t\tConflictTime:    time.Now(),\r\n\t\t}\r\n\t\t\r\n\t\tev.stats.TotalConflicts++\r\n\t\tev.conflicts[aggregateID] = append(ev.conflicts[aggregateID], conflict)\r\n\t\t\r\n\t\tif ev.config.ConflictResolution == \"reject\" {\r\n\t\t\treturn 0, fmt.Errorf(\"version conflict: expected %d, got %d\", newVersion, event.Version)\r\n\t\t}\r\n\t\t\r\n\t\t// Resolve conflict\r\n\t\tresolvedVersion, err := ev.resolveVersionConflict(ctx, conflict)\r\n\t\tif err != nil {\r\n\t\t\treturn 0, fmt.Errorf(\"failed to resolve conflict: %w\", err)\r\n\t\t}\r\n\t\t\r\n\t\tnewVersion = resolvedVersion\r\n\t\tconflict.Resolution = fmt.Sprintf(\"resolved to %d\", resolvedVersion)\r\n\t\tev.stats.ResolvedConflicts++\r\n\t}\r\n\t\r\n\t// Update version info\r\n\tversionInfo.CurrentVersion = newVersion\r\n\tversionInfo.LastEventID = event.ID\r\n\tversionInfo.LastEventTime = event.Timestamp\r\n\t\r\n\t// Add to history\r\n\tif ev.config.EnableHistory {\r\n\t\tentry := VersionHistoryEntry{\r\n\t\t\tVersion:   newVersion,\r\n\t\t\tEventID:   event.ID,\r\n\t\t\tTimestamp: event.Timestamp,\r\n\t\t\tEventType: event.Type,\r\n\t\t}\r\n\t\t\r\n\t\tversionInfo.VersionHistory = append(versionInfo.VersionHistory, entry)\r\n\t\t\r\n\t\t// Trim history if needed\r\n\t\tif len(versionInfo.VersionHistory) \u003e ev.config.HistoryRetention {\r\n\t\t\tversionInfo.VersionHistory = versionInfo.VersionHistory[len(versionInfo.VersionHistory)-ev.config.HistoryRetention:]\r\n\t\t}\r\n\t}\r\n\t\r\n\t// Update statistics\r\n\tev.stats.TotalVersions++\r\n\tev.stats.VersionDistribution[newVersion]++\r\n\t\r\n\tev.logger.Debug(\"Version incremented\",\r\n\t\tzap.String(\"aggregate_id\", aggregateID),\r\n\t\tzap.Int64(\"version\", newVersion))\r\n\t\r\n\treturn newVersion, nil\r\n}\r",
          "symbol_name": "",
          "package_name": "events",
          "dependencies": [
            "context",
            "fmt",
            "sync",
            "time",
            "github.com/vertikon/mcp-core-inventory/pkg/logger",
            "go.uber.org/zap"
          ],
          "related_files": null
        }
      ],
      "impact_analysis": {
        "severity": "critical",
        "affected_files": 36,
        "affected_lines": 108,
        "blocks_deploy": true,
        "blocks_tests": false,
        "breaks_api": false,
        "estimated_time": "1-2 horas",
        "priority": 1,
        "risk_level": "high",
        "dependencies": null
      },
      "related_gaps": null,
      "tags": [],
      "error_breakdown": {},
      "top_files": []
    }
  ],
  "technical_debt": null,
  "recommended_tools": [
    {
      "tool_name": "gosec",
      "install_command": "go install github.com/securego/gosec/v2/cmd/gosec@latest",
      "diagnose_command": "gosec ./...",
      "fix_command": "# Manual - corrija issues de seguranca",
      "config_required": false,
      "config_template": "",
      "documentation": "https://github.com/securego/gosec",
      "alternative_tools": null
    },
    {
      "tool_name": "golangci-lint",
      "install_command": "go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest",
      "diagnose_command": "golangci-lint run",
      "fix_command": "# NAO use --fix automaticamente, revise cada issue",
      "config_required": true,
      "config_template": ".golangci.yml com linters selecionados",
      "documentation": "https://golangci-lint.run/",
      "alternative_tools": null
    },
    {
      "tool_name": "staticcheck",
      "install_command": "go install honnef.co/go/tools/cmd/staticcheck@latest",
      "diagnose_command": "staticcheck ./...",
      "fix_command": "# Manual - staticcheck nao tem auto-fix",
      "config_required": false,
      "config_template": "",
      "documentation": "https://staticcheck.io/",
      "alternative_tools": null
    }
  ],
  "next_steps": [
    "ðŸ”´ URGENTE: Resolver 2 bloqueador(es)"
  ],
  "estimated_effort": "2h30m"
}